<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不断努力的Koo</title>
  
  <subtitle>为了心爱的Nozomi</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-30T14:06:18.146Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Koo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HttpComponents相关</title>
    <link href="http://yoursite.com/2020/10/30/HttpComponents/"/>
    <id>http://yoursite.com/2020/10/30/HttpComponents/</id>
    <published>2020-10-30T13:35:42.000Z</published>
    <updated>2020-10-30T14:06:18.146Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="构造URI"><a href="#构造URI" class="headerlink" title="构造URI"></a>构造URI</h1><p>使用URIBuilder进行构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">URI uri = <span class="keyword">new</span> URIBuilder()</span><br><span class="line">        .setScheme(<span class="string">"http"</span>)</span><br><span class="line">        .setPath(path)</span><br><span class="line">        .setHost(host)</span><br><span class="line">        .setParameter(<span class="string">"accept"</span>, <span class="string">"*/*"</span>)</span><br><span class="line">        .setParameter(<span class="string">"connection"</span>, <span class="string">"Keep-Alive"</span>)</span><br><span class="line">        .setParameter(<span class="string">"user-agent"</span>, <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:81.0) Gecko/20100101 Firefox/81.0"</span>)</span><br><span class="line">        .setCustomQuery(query)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h1 id="HttpClient处理"><a href="#HttpClient处理" class="headerlink" title="HttpClient处理"></a>HttpClient处理</h1><h2 id="处理重定向"><a href="#处理重定向" class="headerlink" title="处理重定向"></a>处理重定向</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LaxRedirectStrategy redirectStrategy = <span class="keyword">new</span> LaxRedirectStrategy();</span><br><span class="line">CloseableHttpClient httpClient = HttpClients.custom()</span><br><span class="line">        .setRedirectStrategy(redirectStrategy)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h2 id="携带CookieStore"><a href="#携带CookieStore" class="headerlink" title="携带CookieStore"></a>携带CookieStore</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">httpClient = HttpClients.custom()</span><br><span class="line">        .setDefaultCookieStore(cookieStore)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h1 id="设置请求属性"><a href="#设置请求属性" class="headerlink" title="设置请求属性"></a>设置请求属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RequestConfig requestConfig = RequestConfig.custom()</span><br><span class="line">        .setConnectTimeout(<span class="number">10</span>* <span class="number">1000</span>)</span><br><span class="line">        .setSocketTimeout(<span class="number">10</span> * <span class="number">1000</span>)</span><br><span class="line">        .setProxy(proxy)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h1 id="构造请求"><a href="#构造请求" class="headerlink" title="构造请求"></a>构造请求</h1><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpPost post = <span class="keyword">new</span> HttpPost(uri);</span><br><span class="line">post.setConfig(requestConfig);</span><br><span class="line">CloseableHttpResponse response = httpClient.execute(post);</span><br></pre></td></tr></table></figure><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpGet get = <span class="keyword">new</span> HttpGet(path);</span><br><span class="line">get.setHeader(<span class="string">"Accept-Language"</span>, <span class="string">"zh-CN"</span>);</span><br><span class="line">get.setHeader(<span class="string">"Charset"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">get.setHeader(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br></pre></td></tr></table></figure><p>或者使用URIBuilder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpGet get = <span class="keyword">new</span> HttpGet(uri);</span><br><span class="line">get.setConfig(requestConfig);</span><br><span class="line">CloseableHttpResponse response = httpClient.execute(get);</span><br></pre></td></tr></table></figure><h1 id="实例，模拟登录获取Cookie"><a href="#实例，模拟登录获取Cookie" class="headerlink" title="实例，模拟登录获取Cookie"></a>实例，模拟登录获取Cookie</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CookieStore <span class="title">test</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        LaxRedirectStrategy redirectStrategy = <span class="keyword">new</span> LaxRedirectStrategy();</span><br><span class="line">        CloseableHttpClient httpClient = HttpClients.custom()</span><br><span class="line">                .setRedirectStrategy(redirectStrategy)</span><br><span class="line">                .build();</span><br><span class="line">                </span><br><span class="line">        URI uri = <span class="keyword">new</span> URIBuilder()</span><br><span class="line">                .setScheme(<span class="string">"http"</span>)</span><br><span class="line">                .setPath(path)</span><br><span class="line">                .setHost(host)</span><br><span class="line">                .setParameter(<span class="string">"accept"</span>, <span class="string">"*/*"</span>)</span><br><span class="line">                .setParameter(<span class="string">"connection"</span>, <span class="string">"Keep-Alive"</span>)</span><br><span class="line">                .setParameter(<span class="string">"user-agent"</span>, <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:81.0) Gecko/20100101 Firefox/81.0"</span>)</span><br><span class="line">                .setCustomQuery(<span class="string">"username=admin&amp;password=123456"</span>)</span><br><span class="line">                .build();</span><br><span class="line">                </span><br><span class="line">        HttpPost post = <span class="keyword">new</span> HttpPost(uri);</span><br><span class="line">        HttpClientContext context = HttpClientContext.create();</span><br><span class="line"></span><br><span class="line">        CloseableHttpResponse response = httpClient.execute(post, context);</span><br><span class="line">        System.out.println(response);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历Cookie</span></span><br><span class="line">        <span class="comment">/*List&lt;Cookie&gt; cookies = context.getCookieStore().getCookies();</span></span><br><span class="line"><span class="comment">        for (Cookie cookie: cookies)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(cookie);</span></span><br><span class="line"><span class="comment">        &#125;*/</span>   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> context.getCookieStore();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClientProtocolException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取Cookie"><a href="#获取Cookie" class="headerlink" title="获取Cookie"></a>获取Cookie</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpClientContext context = HttpClientContext.create();</span><br><span class="line">CookieStore cookieStore = context.getCookieStore();</span><br></pre></td></tr></table></figure><p>HttpClientContext 可以从response中获取如CookieStore，重定向地址，缓存，HTTP路由等信息</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;利用HttpComponents模拟登录，处理登录后重定向，获取Cookie&lt;/center&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="J2EE" scheme="http://yoursite.com/categories/Java/J2EE/"/>
    
    
      <category term="J2EE" scheme="http://yoursite.com/tags/J2EE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode</title>
    <link href="http://yoursite.com/2020/10/24/leetcode/"/>
    <id>http://yoursite.com/2020/10/24/leetcode/</id>
    <published>2020-10-24T11:43:55.000Z</published>
    <updated>2020-10-26T03:52:30.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="算法1164题"><a href="#算法1164题" class="headerlink" title="算法1164题"></a>算法1164题</h1><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>寻找两个有序数组的中位数<br>时间复杂度要求$O(log(m+n))$<br><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/" target="_blank" rel="noopener">方法来自扁扁熊</a><br>寻找中位数，即为寻找第$k$小数，因为有序，所以每次排除$k/2$个数，直到$k=1$或某数组为空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> m = nums2.length;</span><br><span class="line">        <span class="keyword">int</span> left = (n + m + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> right = (n + m + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k 。</span></span><br><span class="line">        <span class="keyword">return</span> (getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, left) + getKth(nums1, <span class="number">0</span>, n - <span class="number">1</span>, nums2, <span class="number">0</span>, m - <span class="number">1</span>, right)) * <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> start1, <span class="keyword">int</span> end1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> start2, <span class="keyword">int</span> end2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = end1 - start1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len2 = end2 - start2 + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1</span></span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> getKth(nums2, start2, end2, nums1, start1, end1, k);</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span>) <span class="keyword">return</span> nums2[start2 + k - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> Math.min(nums1[start1], nums2[start2]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = start1 + Math.min(len1, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = start2 + Math.min(len2, k / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums1[i] &gt; nums2[j]) &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, start1, end1, nums2, j + <span class="number">1</span>, end2, k - (j - start2 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getKth(nums1, i + <span class="number">1</span>, end1, nums2, start2, end2, k - (i - start1 + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h1><h2 id="回文链表-2020-10-23"><a href="#回文链表-2020-10-23" class="headerlink" title="回文链表 2020/10/23"></a>回文链表 2020/10/23</h2><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode-solution/" target="_blank" rel="noopener">题解来源</a></p><ul><li>解法1<br>  链表化数组，双指针法<br>  时间复杂度$O(N)$，空间复杂度$O(N)$</li><li>解法2(use)<br>  递归，或者利用栈首尾对比<br>  时间复杂度$O(N)$，空间复杂度$O(N)$</li><li>解法3<br>  快慢指针，反转后半部链表（需修改链表结构）<br>  时间复杂度$O(N)$，空间复杂度$O(1)$  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class="line">        ListNode firstHalfEnd = endOfFirstHalf(head);</span><br><span class="line">        ListNode secondHalfStart = reverseList(firstHalfEnd.next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否回文</span></span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = secondHalfStart;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (result &amp;&amp; p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1.val != p2.val) &#123;</span><br><span class="line">                result = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还原链表并返回结果</span></span><br><span class="line">        firstHalfEnd.next = reverseList(secondHalfStart);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode nextTemp = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">endOfFirstHalf</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数组中的最长山脉"><a href="#数组中的最长山脉" class="headerlink" title="数组中的最长山脉"></a>数组中的最长山脉</h2><p><a href="https://leetcode-cn.com/problems/longest-mountain-in-array/solution/shu-zu-zhong-de-zui-chang-shan-mai-by-leetcode-sol/" target="_blank" rel="noopener">题解来源</a></p><ul><li><p>解法1<br>  动态规划，枚举山顶（动态规划待细学）<br>  时间复杂度$O(N)$，空间复杂度$O(N)$</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            left[i] = A[i - <span class="number">1</span>] &lt; A[i] ? left[i - <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            right[i] = A[i + <span class="number">1</span>] &lt; A[i] ? right[i + <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left[i] &gt; <span class="number">0</span> &amp;&amp; right[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans = Math.max(ans, left[i] + right[i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法2(use)<br>  枚举山脚<br>  从左往右遍历一次，找到山脚间最长串<br>  时间复杂度$O(N)$，空间复杂度$O(1)$<br>  自己思路，先找山脚，再找最长串</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.length &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = getStrat(A, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = A[i];</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; A.length; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                <span class="keyword">if</span> (pre &lt; A[i])&#123;</span><br><span class="line">                    pre = A[i];</span><br><span class="line">                    temp += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pre == A[i])&#123;</span><br><span class="line">                    temp = <span class="number">1</span>;</span><br><span class="line">                    i = getStrat(A, i);</span><br><span class="line">                    <span class="keyword">if</span> (i == -<span class="number">1</span> &amp;&amp; maxLength &lt; <span class="number">3</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (i == -<span class="number">1</span> &amp;&amp; maxLength &gt;= <span class="number">3</span>)</span><br><span class="line">                        <span class="keyword">return</span> maxLength;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        pre = A[i];</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    i -= <span class="number">1</span>;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (pre &gt; A[i])&#123;</span><br><span class="line">                    pre = A[i];</span><br><span class="line">                    temp += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (i == A.length - <span class="number">1</span> &amp;&amp; temp &gt; maxLength)</span><br><span class="line">                        maxLength = temp;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(temp &gt; maxLength)</span><br><span class="line">                        maxLength = temp;</span><br><span class="line">                    temp = <span class="number">1</span>;</span><br><span class="line">                    i-= <span class="number">1</span>;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxLength &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStrat</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; A.length; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; A.length &amp;&amp; A[i] &lt; A[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>  <p>  解答代码</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestMountain</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">2</span> &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> right = left + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[left] &lt; A[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">while</span> (right + <span class="number">1</span> &lt; n &amp;&amp; A[right] &lt; A[right + <span class="number">1</span>]) &#123;</span><br><span class="line">                    ++right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right &lt; n - <span class="number">1</span> &amp;&amp; A[right] &gt; A[right + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (right + <span class="number">1</span> &lt; n &amp;&amp; A[right] &gt; A[right + <span class="number">1</span>]) &#123;</span><br><span class="line">                        ++right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans = Math.max(ans, right - left + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ++right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有多少小于当前数字的数字-2020-10-26"><a href="#有多少小于当前数字的数字-2020-10-26" class="headerlink" title="有多少小于当前数字的数字 2020/10/26"></a>有多少小于当前数字的数字 2020/10/26</h2><p><a href="https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/solution/you-duo-shao-xiao-yu-dang-qian-shu-zi-de-shu-zi--2/" target="_blank" rel="noopener">题解来源</a></p></li><li><p>解法1(use)<br>  暴力解法，双层循环遍历<br>  时间复杂度$O(N^2)$，空间复杂度$O(1)$</p></li><li><p>解法2<br>  快排，记录原始数组数字位置，根据快排升序坐标获取<br>  时间复杂度$O(N\log N)$，空间复杂度$O(N)$</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[][] data = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            data[i][<span class="number">0</span>] = nums[i];</span><br><span class="line">            data[i][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(data, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] data1, <span class="keyword">int</span>[] data2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> data1[<span class="number">0</span>] - data2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> prev = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev == -<span class="number">1</span> || data[i][<span class="number">0</span>] != data[i - <span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">                prev = i;</span><br><span class="line">            &#125;</span><br><span class="line">            ret[data[i][<span class="number">1</span>]] = prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   Arrays.sort 默认是升序排列，使用双轴快速排序，重写Comparator方法进行数的排序，二维数组第二层记录原始位置</p></li><li><p>解法3<br>  计数排序，数组元素值域范围给定，考虑建立频次数组cnt，cnt[i]记录数字i出现次数，对应i而言，小于其数量为sum(cnt[0…i-1])</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cnt[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ret[i] = nums[i] == <span class="number">0</span> ? <span class="number">0</span> : cnt[nums[i] - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;LeetCode部分难题与好思路&lt;/center&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>j2eeutil</title>
    <link href="http://yoursite.com/2020/10/12/j2eeutil/"/>
    <id>http://yoursite.com/2020/10/12/j2eeutil/</id>
    <published>2020-10-12T05:30:55.000Z</published>
    <updated>2020-10-30T13:44:59.737Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="MybatisUtil"><a href="#MybatisUtil" class="headerlink" title="MybatisUtil"></a>MybatisUtil</h1><p>封装Sqlsession及commit，rollback，getMapper操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="comment">//绑定当前线程中的SqlSession</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SqlSession&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(<span class="string">"mybatis/mybatis-config.xml"</span>);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">openSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession = tl.get();</span><br><span class="line">        <span class="keyword">if</span> (sqlSession == <span class="keyword">null</span>)&#123;</span><br><span class="line">            sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">            tl.set(sqlSession);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession = tl.get();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession = openSession();</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        closeSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession = openSession();</span><br><span class="line">        sqlSession.rollback();</span><br><span class="line">        closeSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; mapper)</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession = openSession();</span><br><span class="line">        <span class="keyword">return</span> sqlSession.getMapper(mapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="DownloadUtil"><a href="#DownloadUtil" class="headerlink" title="DownloadUtil"></a>DownloadUtil</h1><p>基于Apache httpcomponents实现多线程下载<br>包括需要Cookie或不需要Cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.http.client.CookieStore;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.CloseableHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.HttpClients;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">//下载资源路径</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="comment">//下载文件保存位置</span></span><br><span class="line">    <span class="keyword">private</span> String targetFile;</span><br><span class="line">    <span class="comment">//定义下载需要的线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threadNum;</span><br><span class="line">    <span class="comment">//定义下载的线程对象</span></span><br><span class="line">    <span class="keyword">private</span> DownThread[] threads;</span><br><span class="line">    <span class="comment">//定义下载文件总大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> fileSize;</span><br><span class="line">    <span class="comment">//CookieStore</span></span><br><span class="line">    <span class="keyword">private</span> CookieStore cookieStore = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownUtil</span><span class="params">(String path, String targetFile, <span class="keyword">int</span> threadNum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">this</span>.targetFile = targetFile;</span><br><span class="line">        <span class="keyword">this</span>.threadNum = threadNum;</span><br><span class="line">        threads = <span class="keyword">new</span> DownThread[threadNum];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownUtil</span><span class="params">(String path, String targetFile, <span class="keyword">int</span> threadNum, CookieStore cookieStore)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">this</span>.targetFile = targetFile;</span><br><span class="line">        <span class="keyword">this</span>.threadNum = threadNum;</span><br><span class="line">        <span class="keyword">this</span>.cookieStore = cookieStore;</span><br><span class="line">        threads = <span class="keyword">new</span> DownThread[threadNum];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        CloseableHttpClient httpClient = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (cookieStore == <span class="keyword">null</span>)</span><br><span class="line">            httpClient = HttpClients.createDefault();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            httpClient = HttpClients.custom()</span><br><span class="line">                    .setDefaultCookieStore(cookieStore)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">        HttpGet get = <span class="keyword">new</span> HttpGet(path);</span><br><span class="line">        get.setHeader(<span class="string">"Accept-Language"</span>, <span class="string">"zh-CN"</span>);</span><br><span class="line">        get.setHeader(<span class="string">"Charset"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">        get.setHeader(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line"></span><br><span class="line">        CloseableHttpResponse response = httpClient.execute(get);</span><br><span class="line"></span><br><span class="line">        System.out.println(response.getEntity().getContentLength());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到文件大小</span></span><br><span class="line">        fileSize = response.getEntity().getContentLength();</span><br><span class="line">        System.out.println(fileSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> currentPartSize = fileSize / threadNum + <span class="number">1</span>;</span><br><span class="line">        RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(targetFile, <span class="string">"rw"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置本地文件大小</span></span><br><span class="line">        file.setLength(fileSize);</span><br><span class="line">        file.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i ++)&#123;</span><br><span class="line">            <span class="comment">//计算每个线程下载的开始位置</span></span><br><span class="line">            <span class="keyword">long</span> startPos = i * currentPartSize;</span><br><span class="line">            <span class="comment">//每个线程使用一个RandomAccessFile进行下载</span></span><br><span class="line">            RandomAccessFile currentPart = <span class="keyword">new</span> RandomAccessFile(targetFile, <span class="string">"rw"</span>);</span><br><span class="line">            <span class="comment">//定位该线程下载位置</span></span><br><span class="line">            currentPart.seek(startPos);</span><br><span class="line">            <span class="comment">//创建下载线程</span></span><br><span class="line">            threads[i] = <span class="keyword">new</span> DownThread(startPos, currentPartSize, currentPart);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取下载的完成百分比</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getCompleteRate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sumSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i ++)&#123;</span><br><span class="line">            sumSize += threads[i].length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumSize * <span class="number">1.0</span> / fileSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DownThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="comment">//当前线程的下载位置</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> startPos;</span><br><span class="line">        <span class="comment">//定义当前线程负责下载的文件大小</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> currentPartSize;</span><br><span class="line">        <span class="comment">//当前线程需要下载的文件块</span></span><br><span class="line">        <span class="keyword">private</span> RandomAccessFile currentPart;</span><br><span class="line">        <span class="comment">//定义该线程已下载的字节数</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> length;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DownThread</span><span class="params">(<span class="keyword">long</span> startPos, <span class="keyword">long</span> currentPartSize, RandomAccessFile currentPart)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.startPos = startPos;</span><br><span class="line">            <span class="keyword">this</span>.currentPartSize = currentPartSize;</span><br><span class="line">            <span class="keyword">this</span>.currentPart = currentPart;</span><br><span class="line">            length = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                CloseableHttpClient httpClient = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (cookieStore == <span class="keyword">null</span>)</span><br><span class="line">                    httpClient = HttpClients.createDefault();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    httpClient = HttpClients.custom()</span><br><span class="line">                            .setDefaultCookieStore(cookieStore)</span><br><span class="line">                            .build();</span><br><span class="line"></span><br><span class="line">                HttpGet get = <span class="keyword">new</span> HttpGet(path);</span><br><span class="line">                get.setHeader(<span class="string">"Accept-Language"</span>, <span class="string">"zh-CN"</span>);</span><br><span class="line">                get.setHeader(<span class="string">"Charset"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">                get.setHeader(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line"></span><br><span class="line">                CloseableHttpResponse response = httpClient.execute(get);</span><br><span class="line"></span><br><span class="line">                InputStream inputStream = response.getEntity().getContent();</span><br><span class="line">                <span class="comment">//跳过startPos个字节，表名该线程只下载自己负责部分</span></span><br><span class="line">                inputStream.skip(<span class="keyword">this</span>.startPos);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span> * <span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> hasRead = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//读取网络数据，并写入文件</span></span><br><span class="line">                <span class="keyword">while</span> (length &lt; currentPartSize &amp;&amp; (hasRead = inputStream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                    currentPart.write(buffer, <span class="number">0</span> , hasRead);</span><br><span class="line">                    length += hasRead;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                currentPart.close();</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取下载百分比</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="comment">//@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (downUtil.getCompleteRate() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"已完成："</span> + downUtil.getCompleteRate());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;J2EE一些工具类&lt;/center&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="J2EE" scheme="http://yoursite.com/categories/Java/J2EE/"/>
    
    
      <category term="J2EE" scheme="http://yoursite.com/tags/J2EE/"/>
    
  </entry>
  
  <entry>
    <title>一些遇到的问题</title>
    <link href="http://yoursite.com/2020/10/12/someproblems/"/>
    <id>http://yoursite.com/2020/10/12/someproblems/</id>
    <published>2020-10-12T05:03:45.000Z</published>
    <updated>2020-10-12T05:40:19.688Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><ol><li><p>前端js提交数据到后端<br>场景：多选框选中后将选中所在行ID以及修改的state属性提交到后端并刷新当前表格<br>不使用ajax方法，利用js构造form表单</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历tr,根据class属性</span></span><br><span class="line">$(<span class="string">'.dataList'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;    </span><br><span class="line">    <span class="comment">//遍历选中框选中数据信息</span></span><br><span class="line">    <span class="comment">//jquery使用is(':checked')判断是否选中</span></span><br><span class="line">    <span class="keyword">if</span>($(<span class="keyword">this</span>).children(<span class="string">'td'</span>).children(<span class="string">'label'</span>).children(<span class="string">'input'</span>).is(<span class="string">':checked'</span>))&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义创建form表单中的input内容函数</span></span><br><span class="line"><span class="keyword">var</span> generateHideElement = <span class="function"><span class="keyword">function</span> (<span class="params">name, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tempInput = <span class="built_in">document</span>.createElement(<span class="string">"input"</span>);</span><br><span class="line">    tempInput.type = <span class="string">"hidden"</span>;</span><br><span class="line">    tempInput.name = name;</span><br><span class="line">    tempInput.value = value;</span><br><span class="line">    <span class="keyword">return</span> tempInput;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建form表单</span></span><br><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.createElement(<span class="string">"form"</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(form);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建input</span></span><br><span class="line"><span class="keyword">var</span> IDListJSON = generateHideElement(<span class="string">"IDList"</span>, <span class="built_in">JSON</span>.stringify(IDList));</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//将input放在form中</span></span><br><span class="line">form.appendChild(IDListJSON);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//以post方式提交form</span></span><br><span class="line">form.method = <span class="string">"post"</span>;</span><br><span class="line">form.action = <span class="string">"/xxx.html"</span></span><br><span class="line">form.submit();</span><br></pre></td></tr></table></figure></li><li><p>前端以JSON格式提交List到后端处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> IDListJSON = generateHideElement(<span class="string">"IDList"</span>, <span class="built_in">JSON</span>.stringify(IDList));</span><br></pre></td></tr></table></figure><p> 后端以String类型接收到如下格式的List</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;id1&quot;,&quot;id2&quot;,&quot;id3&quot;,...]</span><br></pre></td></tr></table></figure><p> 后端需要使用jackson等包对其进行解析，若直接使用List进行强制转换会变成如下情况</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[&quot;id1&quot;,&quot;id2&quot;,&quot;id3&quot;,...]]</span><br></pre></td></tr></table></figure><p> 变成只含有一个数据的List，数据为所需List，类型为String<br> 用Jackson解析</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list = mapper.readValue(IDList, <span class="keyword">new</span> TypeReference&lt;&gt;()&#123;&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>前端form表单中，若input框包含有</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">disabled</span>=<span class="string">"disabled"</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br></pre></td></tr></table></figure><p> 在提交form表单时，其中的value不会被提交</p></li><li><p>前端发送post数据到后端时，后端需要对全数据进行校验，使用者可通过F12修改例如radio选择按钮中的值将其发送到后端</p></li><li><p>Springboot修改初始页面，登陆拦截</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.iiot.demo.component.LoginHandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.ViewControllerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MVCConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">        registry.addViewController(<span class="string">"/login.html"</span>).setViewName(<span class="string">"login"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//Springboot 不用过滤静态资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LoginHandlerInterceptor()).addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">                .excludePathPatterns(<span class="string">"/login.html"</span>, <span class="string">"/"</span>, <span class="string">"/login"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 登陆拦截（验证登录成功后，将&lt;”username”: username&gt;放入session中）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Object user = request.getSession().getAttribute(<span class="string">"username"</span>);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//未登录返回登录页面</span></span><br><span class="line">            request.getRequestDispatcher(<span class="string">"/login.html"</span>).forward(request, response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;J2EE中遇到的一些问题&lt;/center&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="J2EE" scheme="http://yoursite.com/categories/Java/J2EE/"/>
    
    
      <category term="J2EE" scheme="http://yoursite.com/tags/J2EE/"/>
    
  </entry>
  
  <entry>
    <title>最优化方法（1-2）</title>
    <link href="http://yoursite.com/2020/09/25/OptimizationMethod/"/>
    <id>http://yoursite.com/2020/09/25/OptimizationMethod/</id>
    <published>2020-09-25T11:24:44.000Z</published>
    <updated>2020-09-25T12:08:06.373Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>最优化问题简写为：</p>$$\begin{aligned}\begin{cases}\min \quad &f(x)\\\rm s.t. &g_i(x) \le 0\quad i=1,2,\cdots,m\\ &h_i(x)=0 \quad i = m+1,\cdots,p\end{cases}\qquad\qquad (2-1)\end{aligned}$$<p>可行集/容许集$R = \{ x|g_i(x) \le 0\quad i=1,2,\cdots,m; h_i(x)=0 \quad i = m+1,\cdots,p\}$</p><p><strong>注：</strong> $f\in C^2$表示$f$具有2阶连续偏导数，$R^n$表示$n$维欧式空间</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>定义2.1</strong> 若有$x^*\in R$，使得$\forall x\in R$，均有$f(x^*) \le f(x)$，则称$x^*$为问题（2-1）的可行集或容许集，称$x\in R$为（2-1）的可行解或容许解</p><p><strong>定理2.1</strong> 设$f(x), g_i(x), i=1,2,\cdots.m,h_i(x),i=m+1,\cdots,p$在$R^n$上连续，则问题（2-1）的可行集为闭集，他的全局最优解集合亦为闭集</p><p><strong>定理2.2</strong> （一阶必要条件） 设函数$f(x)\in C^1$定义在$\Omega \subset R^n$上，$x^*$是$\Omega$的一个内点，若$x^*$为$f(x)$的一个极小点，则$\nabla f(x^*)=0$</p><p>最优化问题分类</p><ul><li>线性规划（LP）</li><li>二次规划（QP）</li><li>非线性规划（NLP）</li><li>整数规划（IP）</li><li>几何规划</li><li>多目标规划</li></ul><h2 id="凸集，凸优化及凸规划"><a href="#凸集，凸优化及凸规划" class="headerlink" title="凸集，凸优化及凸规划"></a>凸集，凸优化及凸规划</h2><p><strong>定义3.1</strong> 设$\Omega \subset R^n$，如果对于任意的点$x, y\in \Omega$，连接点$x,y$的线段上的一切点都在$\Omega$中，即对于$0\le \mu \le 1$的一切$\mu$，总有$\mu x+(1-\mu)y\in \Omega$，则称$\Omega$为一个凸集</p><p><strong>定义3.2</strong> 设实数$a_i \ge 0(i=1,2,\cdots,p),\sum\limits_{i=1}^p a_i = 1, x^{(i)}\in R^n(i=1,2,\cdots,p)$，则称$x=\sum\limits_{i=1}^p a_ix^{(i)}$为点$x^{(1)}，x^{(2)},\cdots,x^{(p)}$的一个凸组合</p><p><strong>定理3.1</strong> 集合$\Omega \subset R^n$为凸集的充要条件是：点$x^{(i)}\in \Omega\quad (i=1,2,\cdots,p)$的任意凸组合仍包含在$\Omega$中</p><p><strong>定理3.2</strong> 任意一组凸集的交集仍为凸集</p><p><strong>定义3.3</strong> 包含集合$\Omega \subset R^n$的所有凸集的交集称为$\Omega$的包，记为$Co(\Omega)$或$H(\Omega)$</p><p><strong>定义3.4</strong> 设$\Omega \subset R^n$，如果对于任何$x\in \Omega$及所有的$\alpha\ge 0$，都有$\alpha x\in \Omega$，则称集合$\Omega$为一个锥。一个同时为凸集的锥，称为凸锥</p><p><strong>定义3.5</strong> 设$f(x)$是定义在非空凸集$\Omega \subset R^n$上的函数，若对任意$x,y\in \Omega$，不等式<br>$$<br>f(\lambda x + (1-\lambda)y)\le \lambda f(x) + (1-\lambda)f(y)\qquad\qquad (3-1)<br>$$<br>对于$0\le \lambda\le 1$中的一切$\lambda$都成立，则称$f(x)$为$\Omega$上的凸函数</p><p>若对于$0\le \lambda\le 1$中的一切$\lambda$和$x\not= y(x,y\in \Omega)$，都有<br>$$<br>f(\lambda x + (1-\lambda)y)&lt; \lambda f(x) + (1-\lambda)f(y)\qquad\qquad (3-2)<br>$$<br>成立，则称$f(x)$为$\Omega$上的严格凸函数</p><p><strong>定理3.3</strong> 设$f_1(x),f_2(x)$是凸集$\Omega\subset R^n$上的凸函数，则$f_1(x)+f_2(x)$在$\Omega$上也是凸的</p><p><strong>定理3.4</strong> 设$f(x)$是凸集$\Omega\subset R^n$上的凸函数，则对任意常数$a&gt;0$，函数$af(x)$也是凸的</p><p><strong>定理3.5</strong> 设$f(x)$是凸集$\Omega \subset R^n$上的凸函数，则对任意一个实数$c$，水平集</p>$$\Omega_c=\{x| x\in \Omega,f(x)\le c\}$$<p>是凸集</p><p><strong>定理3.5 推论</strong> 设$f_i(x)(i=1,2,\cdots,p)$为凸集$\Omega\subset R^n$上的凸函数，$c_i(i=1,2,\cdots,p)$为实常数，则$\Omega$中同时满足$f_1(x)\le c_1,f_2(x)\le c_2,\cdots,f_p(x)\le c_p$的点所构成的集合$\Omega_c$为凸集</p><p><strong>定理3.6</strong> 定义在凸集$\Omega \subset R^n$上的可微函数$f(x)$为凸函数的充要条件是：对于所有的$x,y\in \Omega$都有<br>$$<br>f(y)\ge f(x)+(\nabla f(x))^T(y-x)\qquad\qquad (3-3)<br>$$<br><strong>定理3.7</strong> 设$\Omega\subset R^n$为含有内点的凸集，$f(x)\in C^2$，则$f$在$\Omega$上为凸函数的充要条件是：$f(x)$的$Hesse$矩阵$F(x)=\nabla^2 f(x)$在整个$\Omega$上式半正定的</p><p><strong>定理3.8</strong> 设$\Omega \subset R^n$为非空开凸集，$f\in C^2$，若$\nabla^2f(x)$在$\Omega$上处处正定，则$f(x)$是$\Omega$上的严格凸函数</p><p><strong>定义3.6</strong>  规划问题</p>$$\begin{aligned}\begin{cases}\min \quad &f(x)\\\rm s.t. &g_i(x) \le 0\quad i=1,2,\cdots,l\qquad\qquad (3-8)\\ \end{cases}\end{aligned}$$<p>若$f(x),g_i(x)(i=1,2,\cdots,l)$均为可行集$R$上的凸函数，则称这样的问题为凸规划问题</p><p><strong>定理3.9</strong> 凸规划问题（3-8）的可行集$R$是凸集</p><p><strong>定理3.10</strong> 对于凸规划问题（3-8），目标函数$f(x)$的任一局部极小点都是$f(x)$在非空可行集$R$上的全局极小点</p><p><strong>定理3.11</strong> 对于凸规划问题（3-8），若$f(x)$在非空可行集$R$上是严格凸函数，则问题（3-8）的全局极小点唯一</p><h2 id="拟凸函数，伪凸函数"><a href="#拟凸函数，伪凸函数" class="headerlink" title="拟凸函数，伪凸函数"></a>拟凸函数，伪凸函数</h2><p><strong>定义3.7</strong> 设$\Omega\subset R^n$为非空凸集，$f:\Omega\rightarrow R^1$，若$\forall x,y\in\Omega$，均有</p>$$f(\lambda x + (1-\lambda)y)\le \max\{f(x),f(y)\},\forall\lambda\in(0,1)$$<p>成立，则称$f(x)$在$\Omega$上为拟凸函数</p><p>若$\forall x,y\in\Omega,f(x)\not=f(y)$，均有</p>$$f(\lambda x + (1-\lambda)y)< \max\{f(x),f(y)\},\forall\lambda\in(0,1)$$<p>成立，则称$f(x)$在$\Omega$上为严格拟凸函数</p><p><strong>注：严格拟凸函数不一定是拟凸函数，凸函数必为拟凸函数</strong></p><p><strong>定理3.12</strong> 设$\Omega\subset R^n$为非空凸集，$f:\Omega\rightarrow R^1$，则$f$是$\Omega$上的拟凸函数的充要条件是：$\forall c\in R^1$，水平集$H_c(f)=\{x|x\in \Omega,f(x)\le c\}$是凸集</p><p><strong>定理3.13</strong> 设$\Omega\subset R^n$为非空凸集，$f:\Omega\rightarrow R^1$为可微函数，则$f$是$\Omega$上的拟凸函数的充要条件是，若</p><p>$f(x^{(1)})\le f(x^{(2)}),\forall x^{(1)},x^{(2)}\in\Omega$则$\nabla f(x^{(2)}))(x^{(1)}-x^{(2)})\le c$</p><p><strong>定义3.8</strong> 设$\Omega\subset R^n$为非空开凸集，$f:\Omega\rightarrow R^1$为可微函数，如果对于<br>$$<br>\nabla f(x^{(1)})^T(x^{(1)}-x^{(2)})\le 0,\quad \forall x^{(1)},x^{(2)}\in \Omega<br>$$<br>必有$f(x^{(1)})\le f(x^{(2)})$，则称$f(x)$是$\Omega$上的伪凸函数</p><p>在上述条件下，若$x^{(1)}\not=x^{(2)}$，必有$f(x^{(1)})&lt; f(x^{(2)})$，则称$f(x)$是$\Omega$上的严格伪凸函数</p><p><strong>定理3.14</strong> 设$\Omega\subset R^n$为非空凸集，$f:\Omega\rightarrow R^1$为可微函数，若$f$是$\Omega$上的伪凸函数，则$f$是$\Omega$上的严格拟凸函数和拟凸函数</p><h2 id="广义凸规划"><a href="#广义凸规划" class="headerlink" title="广义凸规划"></a>广义凸规划</h2><p><strong>定理3.15</strong> 设（3-8）的可行集$R$是凸集，$f(x)$是$R$上的严格拟凸函数，则广义凸规划（3-8）的任一局部最优解$x^*$也是它的全局最优解</p><p><strong>定理3.16</strong> 设（3-8）的可行集$R$是开凸集，$f(x)$是$R$上的伪凸函数，$x^<em>\in R$，若$\nabla f(x^</em>)=0$，则$x^*$是（3-8）的全局最优解</p><h1 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h1><p>标准形式的线性规划问题</p>$$\begin{aligned}\begin{cases}\min \quad &c^Tx\\\rm s.t. &Ax=b,x\ge0 \qquad\qquad(1-2)\end{cases}\end{aligned}$$<p>展开为：</p>$$\begin{aligned}\begin{cases}\min \quad &y=\sum\limits_{i=1}^m c_ix_i\\\rm s.t. &\sum\limits_{j=1}^n a_{ij}x_j\quad i=1,2,\cdots,m\\&x_j\ge0\quad j=1,2,\cdots,n\end{cases}\end{aligned}$$<p>其中，变量个数$n$称为线性规划的维数，等式约束方程数目$m$称为线性规划的阶数，$m&lt;n$</p><p>满足约束条件的点$x=(x_1,x_2,\cdots,x_n)$称为可行解</p><p>设$A$的秩为$m$，则可从$A$的$n$列中选出$m$列，使它们线性无关，令$B=(a_1,a_2,\cdots,a_m)$，使得方程$Bx_B=b$有唯一解$x_B=B^{-1}b$，令$x^T=(x_B^T,0^T)$</p><p>称$B$为基底，$x$为关于基底$B$的基本解，当基本解中有一个或一个以上的基本变量$x_i=0$时，称这个解为退化的基本解</p><p>当一个可行解$x$又是基本解时，称它为基本可行解，若它是退化的，称为退化的基本可行解</p><p>一个基本可行解$x$是一个不超过$m$个正$x_i$的可行解，而一个非退化的基本可行解$x$是恰有$m$个正$x_i$的可行解</p><p>一个$m$阶，$n$维的线性规划问题，其基本可行解个数不超过$C_{n}^m$</p><h2 id="基本定理"><a href="#基本定理" class="headerlink" title="基本定理"></a>基本定理</h2><p><strong>定义2.1</strong> 称$H^+=\{x|x\in R^n,c^Tx\ge b\}$为正闭半空间，$H^-=\{x|x\in R^n ,c^Tx\le b\}$为负闭半空间。$H^+,H^-$统称为闭半空间</p><p><strong>定义2.2</strong> 有限个闭半空间的交集称为多面凸集，亦即集合$S=\{x|Ax\le b\}$（其中$A=(a_{ij})_{m\times n}$）称为多面凸集或凸多胞形</p><p><strong>定义2.3</strong> 有界且非空的多面凸集称为多面凸体或凸多面体</p><p><strong>定义2.4</strong> 设$S$为凸集，$x\in S$，若对于$x$找不到$x_1,x_2\in S(x_1\not= x_2)$，使$x=ax_1+(1-a)x_2(0&lt;a&lt;1)$成立，则称$x$为凸集$S$的极点，或顶点</p><p><strong>定理2.1</strong> 设$A=(a_{ij})_{m\times n}$，其秩为$m$，且<br>$m&lt;n,x=(x_1,x_2,\cdots,x_n)^T,b=(b_1,b_2,\cdots,b_m)^T$，则矢量$x$为凸集</p>$$R=\{x|Ax=b,x\ge 0\}\qquad\qquad (2-1)$$<p>的一个极点的充要条件是$x$为<br>$$<br>Ax=b,\quad x\ge 0\qquad\qquad(2-2)<br>$$<br>的一个基本可行解</p><p><strong>定理2.2</strong> 设给定的线性规划问题形如（1-2）</p><ul><li>若（1-2）有可行解，则其必有基本可行解</li><li>若（1-2）有最优可行解，则必有最优基本可行解</li></ul><p>即若（1-2）有最优解，则一定在可行集的极点上达到</p><p><strong>定理2.2 推论1</strong> 若由（1-2）确定的可行集$R=\{x|Ax=b,x\ge 0\}$是非空的，则它至少有一个极点</p><p><strong>定理2.2 推论2</strong> 如果一个线性规划问题（1-2）存在有限的最优解，则至少存在一个是可行集$R$的极点的有限最优解</p><p><strong>定理2.2 推论3</strong> 对应于（1-2）的可行集$R$至多具有有限多个极点</p><h2 id="化为标准形式"><a href="#化为标准形式" class="headerlink" title="化为标准形式"></a>化为标准形式</h2><p>如果在一个线性规划问题中，有一部分变量不要求取非负值，则这些变量就称为自由变量，可有两种方式化为标准形式</p><ul><li><p>令$x_i=u_i-v_i,u_i,v_i\ge0$</p></li><li><p>从约束方程之一解出$x_i$，代入其他的约束方程和目标函数，则问题转化为$n-1$个变量和$m-1$个约束的LP问题</p></li></ul><h2 id="单纯形法"><a href="#单纯形法" class="headerlink" title="单纯形法"></a>单纯形法</h2><p>基本思想：使由LP问题的一个基本可行解（极点）转移到另一个基本可行解，目标函数值是减小的</p><p>约束方程的规范形式</p>$$\begin{aligned}\begin{cases}x_1\qquad \qquad \qquad +y_{1\cdot {m+1}}x_{m+1}+\cdots+y_{1n}x_n=y_{10}\\\qquad x_2\qquad \qquad +y_{2\cdot {m+1}}x_{m+1}+\cdots+y_{2n}x_n=y_{20}\\\qquad\qquad\ddots\qquad\qquad\vdots\\\qquad \qquad \qquad x_m +y_{m\cdot {m+1}}x_{m+1}+\cdots+y_{mn}x_n=y_{m0}\\\end{cases}\end{aligned}$$<p>简写为：<br>$$<br>x_i+\sum\limits_{j=m+1}^n y_{ij}x_j=y_{i0},i=1,2,\cdots,m<br>$$<br>对应的基本解为<br>$$<br>x=(y_{10},y_{20},\cdots,y_{m0},0,\cdots,0)<br>$$<br>令$x_B=(x_1,x_2,\cdots,x_m)^T,x_N=(x_{m+1},\cdots,x_n)^T$</p><p>规范形式可写为</p>$$\begin{aligned}\quad[I_m,N]\begin{bmatrix}x_B\\x_N\end{bmatrix}=y_0\quad\end{aligned}$$<p>基本解转换</p><p>将基本变量$x_p$用非基本变量$x_q$代替，$1\le p\le m, y_{pq}\not= 0$，新约束方程组系数为</p>$$\begin{aligned}\begin{cases}y_{ij}^{'}=y_{ij}-\dfrac{y_{pj}}{y_{pq}} y_{iq},i\not =p\\y_{pj}^{'}=\dfrac{y_{pj}}{y_{pq}}\end{cases}\end{aligned}$$<p>$y_{pq}$为主元</p><p>为保证基本解的可行性，需确定离基矢量</p><p>假设进基矢量为$a_k$</p><p>则离基矢量为$\min\limits_{1\le i < k} \{ \dfrac{y_{i0}}{y_{ik}}|y_{ik} > 0 \}$</p><p>其中$y_{i0}$是基本解的基本变量，$y_{ik}$是约束方程组系数</p><p><strong>定理3.1</strong> 已知一个非退化的基本可行解，其目标函数值为$z_0$，假定对于某一个$j$，有$c_j-z_j&lt;0$，那么存在一个可行解，使其对应的目标函数值$z&lt;z_0$。如果能用非基矢量$a_j$代替原基中的某一矢量$a_r$，而产生的一个新的基本可行解，则这个新的解将使$z&lt;z_0$。如果不能用$a_j$来代替而产生的一个基本可行解，则可行集$R$是无界的，而且目标函数值可以任意的小</p><p><strong>定理3.2</strong> 如果某一个基本可行解，对所有的$j$，都有$c_j-z_j\ge 0$，那么这个解就是最优解</p><p>称$c_j-z_j=r_j$为相对成本系数或检验数</p><p>单纯形法计算步骤</p><ul><li><p>把一般LP问题化为标准形式</p>$$  \begin{aligned}  \begin{cases}  \min \quad &c^Tx\\  \rm s.t. &Ax=b\\&x\ge0  \end{cases}  \end{aligned}  $$</li><li><p>建立初始单纯形表</p><table><thead><tr><th align="center">基矢量</th><th align="center">$a_1$</th><th align="center">$a_2$</th><th align="center">$\cdots$</th><th align="center">$a_n$</th><th align="center">b</th></tr></thead><tbody><tr><td align="center">$a_{n-m +1}$</td><td align="center">$y_{11}$</td><td align="center">$y_{12}$</td><td align="center"></td><td align="center">$y_{1n}$</td><td align="center">$y_{10}$</td></tr><tr><td align="center">$a_{n-m+2}$</td><td align="center">$y_{21}$</td><td align="center">$y_{22}$</td><td align="center"></td><td align="center">$y_{2n}$</td><td align="center">$y_{20}$</td></tr><tr><td align="center">$\vdots$</td><td align="center">$\vdots$</td><td align="center">$\vdots$</td><td align="center"></td><td align="center">$\vdots$</td><td align="center">$\vdots$</td></tr><tr><td align="center">$a_n$</td><td align="center">$y_{m1}$</td><td align="center">$y_{m2}$</td><td align="center">$\cdots$</td><td align="center">$y_{mn}$</td><td align="center">$y_{m0}$</td></tr><tr><td align="center">检验数</td><td align="center">$c_1$</td><td align="center">$c_2$</td><td align="center">$\cdots$</td><td align="center">0</td><td align="center">$-z_0$</td></tr></tbody></table>$$  \begin{aligned}  \begin{cases}  c=[c_1,c_2,\cdots,c_m,0,\cdots,0]^T\\  x=[x_1,x_2,\cdots,x_m,0,\cdots,0]^T\\  z_0=c^Tx\quad or \quad c_B^Tx_B  \end{cases}  \end{aligned}  $$</li><li><p>若所有检验数$c_j-z_j=r_j\ge0$，得到一个最优解，否则继续</p><p>非基矢量计算检验数</p><p>$c_j\in c$，$c_B^T$与对应$a_j$的列相乘获得$z_j$</p><p>$c_B^T$是基矢量$x_B$对应$c$中系数组成的集合</p></li><li><p>当有多个$r_j&lt;0$时，通常选择$\min\{r_j|r_j<0\}=r_k$的$a_k$为进基矢量< p></0\}=r_k$的$a_k$为进基矢量<></p></li><li><p>对所有的$y_{ik}&gt;0$，计算$\min\limits_{1 \le i < k}\{\dfrac{y_{i0}}{y_{ik}}|y_{ik}>0\}$，继续，若所有的$y_{ik} \le 0$，则LP问题的可行集$R$无界，且目标函数无界，结束</p></li><li><p>进行$Gauss$消元，获取新的基本可行解，回到检验数继续</p></li></ul><h2 id="确定初始基本可行解"><a href="#确定初始基本可行解" class="headerlink" title="确定初始基本可行解"></a>确定初始基本可行解</h2><h3 id="大M法"><a href="#大M法" class="headerlink" title="大M法"></a>大M法</h3><p>LP问题标准形式</p>$$\begin{aligned}\begin{cases}\min \quad &c^Tx\\\rm s.t. &Ax=b\qquad\qquad (4-1)\\&x\ge0\end{cases}\end{aligned}$$<p>为获得一个初始基本可行解，引入人工变量$y_1,y_2,\cdots,y_m$，令$y=[y_1,y_2,\cdots,y_m]^T$</p><p>考察另一个LP问题</p>$$\begin{aligned}\begin{cases}\min \quad &c^Tx + ME^Ty\\\rm s.t. &Ax + y=b\qquad\qquad (4-2)\\&x\ge0,y\ge0\end{cases}\end{aligned}$$<p>其中$M&gt;0$是一个充分大的数，$E=[1,1,\cdots,1]^T\in R^m$</p><p><strong>定理4.1</strong> 设$\begin{aligned}\begin{bmatrix}x^*\\y^*\end{bmatrix}\end{aligned}$是问题（4-2）的最优解，若$y^*=0$，则$x^*$是问题（4-1）的最优解；若$y^*\not=0$，则问题（4-1）没有可行解。反之，若$x^*$是问题（4-1）的最优解，则$\begin{aligned}\begin{bmatrix}x^*\\0\end{bmatrix}\end{aligned}$是问题（4-2）的最优解</p><h3 id="二阶段法"><a href="#二阶段法" class="headerlink" title="二阶段法"></a>二阶段法</h3><p>设要求解的LP问题为（4-1），引入人工变量$y_1,y_2,\cdots,y_m$，令$y=[y_1,y_2,\cdots,y_m]^T$</p><p>构造一个辅助的LP问题</p>$$\begin{aligned}\begin{cases}\min \quad &z=\sum\limits_{i=1}^m y_i\\\rm s.t. &Ax + y=b\qquad\qquad (4-5)\\&x\ge0,y\ge0\end{cases}\end{aligned}$$<p><strong>定理4.2</strong> 若问题（4-5）的最优基本可行解为$\begin{aligned}\begin{bmatrix}x^*\\0\end{bmatrix}\end{aligned}$，则$x^*$为问题（4-1）的一个基本可行解；若问题（4-5）的最优基本可行解为$\begin{aligned}\begin{bmatrix}x^*\\y^*\end{bmatrix}\end{aligned}$，且$y^*\not=0$，则问题（4-1）没有可行解</p><p>求解步骤为：</p><ul><li><p>求解辅助LP问题，使用单纯形法</p></li><li><p>若找到最优基本可行解为$\begin{aligned}  \begin{bmatrix}  x^*\\0  \end{bmatrix}  \end{aligned}$，继续</p></li><li><p>将辅助LP问题的单纯形表中人工变量所在列移除，重新计算$r_j,z_0$</p></li><li><p>利用移除后的单纯形表进行迭代获取最优解</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>若系数矩阵为方阵，直接添加人工变量使用单纯形法求解，系数矩阵$A_{m\times n},m&lt;n$时，若存在单个未知量$x_i$在某个约束方程中存在，使用大M法，否则使用二阶段法</p><h2 id="单纯形法矩阵形式"><a href="#单纯形法矩阵形式" class="headerlink" title="单纯形法矩阵形式"></a>单纯形法矩阵形式</h2><p>对于LP问题（4-1），设其中矩阵$A$的秩$r(A)=m&lt;n,b\ge0$</p><p>设$B$为基，由$A$的前$m$列组成，把$A,x,c$分块为</p>$A=(B,N),x=\begin{bmatrix}x^*\\y^*\end{bmatrix},c=\begin{bmatrix}c_B\\c_N\end{bmatrix}$<p>于是问题（4-1）可写成</p>$$\begin{aligned}\begin{cases}\min \quad &z=c_B^Tx_B+c_N^Tx_N\\\rm s.t. &Bx_B+Nx_N=b\qquad\qquad (4-6)\\&x_B,x_N\ge0\end{cases}\end{aligned}$$<p>令$x_N=0$，则得$x_B=B^{-1}b$，于是得到与基$B$对应的基本可行解（假设可行）$x^{(0)}=\begin{bmatrix}x^*\\0\end{bmatrix}=\begin{bmatrix}B^{-1}b\\0\end{bmatrix}$</p><p>对应的目标函数值为$z_0=c_B^Tx_B=c_B^TB^{-1}b$</p><p>对任意的$x_N$，有$x_B=B^{-1}b-B^{-1}Nx_N$</p><p>对应的目标函数值为$z=c_B^Tx_B=c_B^TB^{-1}b+(c_N^T-c_B^TB^{-1}N)x_N=z_0+r_N^Tx_N$</p><p>其中$r_N^T=c_N^T-c_B^TB^{-1}N=c_N^T-\pi^TN$</p><p>其中$\pi^T=c_B^TB^{-1}$称为<strong>单纯形乘子矢量</strong></p><p>$r_N$是与非基变量对应的检验数构成的矢量，$r_B$表示与基变量对应的检验数构成的矢量，$r_B=0$</p><p>称$r=\begin{bmatrix}r_B\\r_N\end{bmatrix}$为<strong>相对成本矢量或检验矢量</strong></p><p>与基$B$对应的矩阵形式单纯形表可写成​</p>$$\begin{aligned}T(B)=\begin{bmatrix}I_m&&B^{-1}N&&B^{-1}b\\0&&c_N^T-c_B^TB^{-1}N&&-c_B^TB^{-1}b\end{bmatrix}\end{aligned}$$<p>更一般的写为</p>$$\begin{aligned}T(B)=\begin{bmatrix}B^{-1}A&&B^{-1}b\\c_N^T-c_B^TB^{-1}A&&-c_B^TB^{-1}b\end{bmatrix}\end{aligned}$$<p>检验矢量$r^T=c_N^T-c_B^TB^{-1}A=c^T-\pi^TA$</p><h2 id="修正单纯形法"><a href="#修正单纯形法" class="headerlink" title="修正单纯形法"></a>修正单纯形法</h2><p>节约存储，通常使用在计算机计算中，手算无优势，使用上面矩阵形式计算</p><h2 id="退化与循环"><a href="#退化与循环" class="headerlink" title="退化与循环"></a>退化与循环</h2><p>避免迭代过程出现循环，有如下三种方法</p><ul><li>摄动法</li><li>字典序法</li><li>Bland法<ul><li>若$\min\{i|r_i<0\}=k$，选择$y_k$为进基矢量< li><li>若$\min\{\dfrac{y_{i0}}{y_{ik}}|y_{ik}>0\}=\dfrac{y_{i0}}{y_{ik}}$，则选择$y_{ik}$为主元，$y_i$为离基矢量</li></0\}=k$，选择$y_k$为进基矢量<></li></ul></li></ul><h2 id="对偶LP与对偶单纯形法"><a href="#对偶LP与对偶单纯形法" class="headerlink" title="对偶LP与对偶单纯形法"></a>对偶LP与对偶单纯形法</h2><h3 id="对偶LP问题"><a href="#对偶LP问题" class="headerlink" title="对偶LP问题"></a>对偶LP问题</h3><p>设有LP问题</p>$$\begin{aligned}\begin{cases}\min \quad &f(x)=c^Tx\\\rm s.t. &Ax\ge b\qquad\qquad(5-1)\\&x\ge0 \end{cases}\end{aligned}$$<p>其对偶LP问题定义为</p>$$\begin{aligned}\begin{cases}\max \quad &g(\lambda)=b^T\lambda\\\rm s.t. &\lambda^TA\le c^T\qquad\qquad(5-2)\\&\lambda\ge0 \end{cases}\end{aligned}$$<p>其中$A=(a_{ij})_{m\times n},x,c\in R^n,b,\lambda\in R^m$</p><p>由原始规划转换成对偶规划步骤</p><ul><li>交换常矢量$c,b$的位置，变矢量$x$用$\lambda$替换</li><li>改变约束不等式的不等号方向，min为大于等于（原始），max为小于等于（对偶）</li><li>把min改成max</li><li>交换$A$与变矢量的位置，并按需要做适当的转置</li></ul><h3 id="对偶定理"><a href="#对偶定理" class="headerlink" title="对偶定理"></a>对偶定理</h3><p>标准LP问题形式</p>$$\begin{aligned}&\begin{cases}\min \quad&c^Tx\\\rm s.t. & Ax= b\qquad\qquad(5-3)\\&x\ge0 \end{cases}\\\Rightarrow&\begin{cases}\min \quad &c^Tx\\\rm s.t. &\begin{bmatrix}A\\-A\end{bmatrix}x\ge\begin{bmatrix}b\\-b\end{bmatrix}\\&x\ge0 \end{cases}\\\Rightarrow&\begin{cases}\max \quad &(u^T,v^T)\begin{bmatrix}b\\-b\end{bmatrix}\\\rm s.t. &[u^T,v^T]\begin{bmatrix}A\\-A\end{bmatrix}\le c^T\\&u\ge 0,v\ge0 \end{cases}\\\Rightarrow&\begin{cases}\max \quad &(u^T-v^T)b\\\rm s.t. &(u^T-v^T)A\le c^T\\&u\ge 0,v\ge0 \end{cases}\\\end{aligned}$$<p>其对偶形式</p>$$\begin{aligned}\begin{cases}\max \quad &w^Tb\\\rm s.t. &w^TA\le c^T\qquad\qquad(5-4)\\\end{cases}\end{aligned}$$<p>其中$w=u-v$</p><p><strong>引理 1</strong>  若$x$和$w$分别是（5-3），（5-4）的可行解，则$c^Tx\ge w^Tb$</p><p><strong>推论</strong> 设$x^*,w^*$分别是（5-3），（5-4）的可行解，且$c^Tx^*=w^{*T}b$，则$x^*,w^*$分别是（5-3），（5-4）的最优解</p><p><strong>线性规划的对偶定理</strong> 若（5-3）或（5-4）二者有一个有有限的最优解，则另一个也有有限的最优解，而且二者的目标函数值相同。若任一个问题的目标函数值无界，则另一个问题没有可行解</p><p>设$x^*$是（5-3）的最优基本可行解，$B$为对应的最优基，则校验矢量$r$应满足</p>$$r^T=c^T-\pi^TA\ge0\qquad\qquad (5-6)\\$$<p>其中$\pi=c^T_BB^{-1}$，单纯形矢量乘子矢量，参见单纯形法矩阵形式</p><h3 id="对偶单纯形法"><a href="#对偶单纯形法" class="headerlink" title="对偶单纯形法"></a>对偶单纯形法</h3><p><strong>定理5.1</strong> 设$x$为（5-3）的任一基本解，对应的基为$B$，令$w^T=c_B^TB^{-1}$。若$x,w$分别是（5-3）和（5-4）的可行解，则$x,w$也分别是（5-3）和（5-4）的最优解</p><p><strong>定义5.1</strong> 若$x$是（5-3）的一个基本解（设对应的基为$B$），且它对应的检验矢量$r\ge 0$（即$w=\pi=(c_B^TB^{-1})^T$为（5-4）的可行解），则称$x$为（5-3）的对偶可行解或正则解</p><p><strong>基本思想</strong></p><p>从原始问题（5-3）的一个对偶可行的基本解开始，逐次迭代，保持对偶可行性的条件下，逐步使原始问题（5-3）的基本解$x$的不可行性消失（即使$x\ge 0$），直到获得（5-3）的一个基本可行解为止，而它即为原始问题的最优解</p><p><strong>计算步骤</strong></p><ul><li><p>把一般的LP问题化为（5-3）形式，不要求$b\ge0$</p></li><li><p>列出初始单纯形表，求出（5-3）的一个对偶可行的基本解$x=\begin{bmatrix}x_B\\0\end{bmatrix}$</p></li><li><p>若$x_B\ge0$，则现行解为最优解，计算结束，否则$x_B\not\ge0$，令$x_{B_i}=\min\{x_{B_j}|j=1,2,\cdots,m\}$，由此确定$a_{B_i}$为离基矢量</p></li><li><p>用$y_{ij}$表示单纯形表中第$B_i$行的各个元素，若所有的$y_{ij}\ge0(j=1,1,\cdots,n)$，则对偶问题（5-4）的目标无上界，原始问题（5-3）没有可行解，否则必有某个$j$使$y_{ij}&lt;0$，令</p>$$  \epsilon=\min\limits_{1\le j\le n}\{\dfrac{z_j-c_j}{y_{ij}}|y_{ij}<0\}=\dfrac{z_k-c_k}{y_{ik}} $$ <p>其中<br>$$<br>\begin{aligned}<br>&amp;z_j=w^Ta_j,j=1,2,\cdots,n\<br>&amp;w^T=c_B^TB^{-1}<br>\end{aligned}<br>$$<br>决定$a_k$为进基矢量，$y_{ik}$为主元素<p></p></0\}=\dfrac{z_k-c_k}{y_{ik}}></li><li><p>用$a_k$代替$a_{B_i}$形成一个新基，再用这个新基来确定相应的对偶可行的基本解，然后返回第三步</p></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>原始问题使用单纯形法求解，先计算进基矢量，在离基矢量，对偶单纯形法中，先确定离基矢量，再确定进基矢量</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;最优化方法知识点归纳&lt;/br&gt;凸集凸函数与线性规划&lt;/center&gt;
    
    </summary>
    
    
      <category term="Course" scheme="http://yoursite.com/categories/Course/"/>
    
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Course" scheme="http://yoursite.com/tags/Course/"/>
    
  </entry>
  
  <entry>
    <title>最优化方法（3-4）</title>
    <link href="http://yoursite.com/2020/09/25/OptimizationMethod1/"/>
    <id>http://yoursite.com/2020/09/25/OptimizationMethod1/</id>
    <published>2020-09-25T11:24:44.000Z</published>
    <updated>2020-09-25T13:06:59.892Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="无约束优化方法"><a href="#无约束优化方法" class="headerlink" title="无约束优化方法"></a>无约束优化方法</h1><h2 id="下降递推算法"><a href="#下降递推算法" class="headerlink" title="下降递推算法"></a>下降递推算法</h2><p>最优化算法的迭代过程一般分为如下四步：</p><ul><li>选择初始点$x^{(0)}$</li><li>如果$x^{(k)}$已求得，且$x^{(k)}$不是极小点，设法选取一个方向$s^{(k)}$，使目标函数$f(x)$沿$s^{(k)}$是下降的，至少是不增的，$s^{(k)}$称为搜索方向</li><li>在方向$s^{(k)}$确定以后，在射线$x^{(k)}+\lambda s^{(k)}(\lambda\ge0)$上选取适当的步长$\lambda_K$，使$f(x^{(k)}+\lambda_k s^{(k)})\le f(x^{(k)})$，如此确定出下一个点$x^{(k+1)}=x^{(k)}+\lambda_k s^{(k)}$（在多数算法中，$\lambda_k$的选取是使$f(x)$的值下降最多，即沿射线$x^{(k)}+\lambda s^{(k)}$求$f(x)$的极小值，这是关于单变量$\lambda$的函数求极小的问题）。这种确定步长的方法称为<strong>一维搜索或线搜索</strong></li><li>检验所得的新点$x^{(k+1)}$是否为极小点，或满足精度要求的近似极小点</li></ul><p><strong>定义1.1</strong> 设$x^*$为问题$\min f(x),x\in R^n$的最优解，由算法$A$产生的序列${x^{(k)}}$收敛于$x^*$，即</p>$$\lim_{k\rightarrow+\infty} x^{(k)}=x^*\qquad\qquad (1-3)$$<p>${x^{(k)}}$若存在一个与$k$无关的常数$\beta\in(0,1)$，某个正整数$k_0$，使当$k&gt;k_0$时</p>$$\Vert x^{(k+1)}-x^*\Vert\le \beta \Vert x^{(k)}-x^*\Vert\qquad\qquad(1-4)$$<p>成立，则称序列${x^{(k)}}$为线性收敛，线性收敛速度相当于响应的等比序列的收敛速度</p>$$\Vert x^{(k)}-x^*\Vert\le \beta \Vert x^{(k-1)}-x^*\Vert\le\beta^2 \Vert x^{(k-2)}-x^*\Vert\le\cdots\le\beta^k \Vert x^{(0)}-x^*\Vert$$<p><strong>定义1.2</strong> 设由算法$A$产生的序列${x^{(k)}}$收敛于最优解$x^*$，如果存在一个与$k$无关的常数$\beta&gt;0$和$\alpha&gt;1$，某个正整数$k_0$，使当$k&gt;k_0$时，</p>$$\Vert x^{(k+1)}-x^*\Vert\le \beta \Vert x^{(k)}-x^*\Vert^\alpha\qquad\qquad(1-5)$$<p>成立，则称序列${x^{(k)}}$的收敛阶为$\alpha$，或称序列${x^{(k)}}$是$\alpha$阶收敛</p><p>当$\alpha=2$时，称序列${x^{(k)}}$是二阶收敛的</p><p>当$1&lt;\alpha&lt;2$时，称序列${x^{(k)}}$是超线性收敛的</p><p>迭代终止条件</p><ul><li>$\Vert x^{(k+1)}-x^*\Vert\le \epsilon$</li><li>$| f(x^{(k+1)})-f(x^{(k)})|\le \epsilon$</li></ul><h2 id="一维搜索"><a href="#一维搜索" class="headerlink" title="一维搜索"></a>一维搜索</h2><p>精确一维搜索方法，可以分为两类</p><ul><li><p>不用导数的方法</p><p>0.618法，分数法，“成功-失败”法</p></li><li><p>使用导数的方法</p><p>$Newton$法，抛物线法，三次插值法</p></li></ul><h2 id="Newton法"><a href="#Newton法" class="headerlink" title="Newton法"></a>Newton法</h2><p><strong>基本思想</strong></p><p>用$\varphi(x)$在已知点$x_0$处的二阶$Taylor$展开式来近似代替$\varphi(x)$，即取$\varphi(x)\approx g(x)$，其中<br>$$<br>g(x)=\varphi(x_0)+\varphi^{‘}(x_0)(x-x_0)+\dfrac{1}{2}\varphi^{‘’}(x_0)(x-x_0)^2<br>$$<br>用$g(x)$的极小点$\hat x$作为$\varphi(x)$的近似极小点</p><p>由于$g^{‘}(x)=\varphi^{‘}(x_0)+\varphi^{‘’}(x_0)(x-x_0)=0$</p><p>$x_1=x_0-\dfrac{\varphi^{‘}(x_0)}{\varphi^{‘’}(x_0)}$</p><p>迭代通式为$x_{k+1}=x_k-\dfrac{\varphi^{‘}(x_k)}{\varphi^{‘’}(x_k)}\quad k=1,2,\cdots$</p><p><strong>注</strong> $Newton$法产生的序列即使收敛，其极限也不一定是$f(x)$的极小点，只能保证它是$f(x)$的驻点，驻点可能是极小点，也可能是极大点，也可能是两者都不是</p><h2 id="抛物线法"><a href="#抛物线法" class="headerlink" title="抛物线法"></a>抛物线法</h2><p><strong>基本思想</strong></p><p>利用$f(x)$在三个点$x_0,x_1,x_2$处的函数值来构造一个二次函数$y=g(x)=a_0+a_1x+a_2x^2$，使其满足</p>$$\begin{aligned}\begin{cases}y_1=g(x_0)=f(x_0)\\y_2=g(x_1)=f(x_1)\qquad\qquad(2-4)\\y_3=g(x_2)=f(x_2)\end{cases}\end{aligned}$$<p>则$g^{‘}(x)=a_1+2a_2x$。令$g^{‘}(x)=0$得</p><p>$\overline{x}=-\dfrac{a_1}{2a_2}$</p><p>根据（2-4）计算出$a_1,a_2$即可</p><p><strong>注</strong> </p><ul><li><p>通常假设$f(x)\in C^1,x_1&lt;x_0&lt;x_2,f(x_0)&lt;f(x_1),f(x_0)&lt;f(x_2)$，可证$a_2&gt;0$，因而求得的$\overline x$确是$g(x)$的极小点，且$\overline x\in [x_1,x_2]$</p></li><li><p>迭代结束准则</p><ul><li>$|f(\overline x)-f(x_0)|&lt;\epsilon$</li><li>$|x_0-\overline x|&lt;\epsilon$</li><li>$|f(\overline x)-g(\overline x)|&lt;\epsilon$</li></ul></li></ul><h2 id="三次插值法"><a href="#三次插值法" class="headerlink" title="三次插值法"></a>三次插值法</h2><p><strong>基本思想</strong></p><p>用$a,b$两点出的函数值$f(a),f(b)$和导数值$f^{‘}(a),f^{‘}(b)$来构造三次插值多项式，并以$g(x)$的极小点作为$f(x)$的近似极小点，一般情况下，三次插值法比抛物线法收敛速度快</p><p>为保证$f(x)$的极小点$x^*\in[a,b]$，假定$f(x)\in C^1$</p><p>$a&lt;b,f^{‘}(a)&lt;0,f^{‘}(b)&gt;0$</p><p>设插值多项式为</p><p>$g(x)=\alpha(x-a)^3+\beta(x-a)^2+\gamma(x-a)+\delta$</p><p>根据插值条件有</p>$\begin{cases}\delta = f(a)\\\gamma = f^{'}(a)\\\alpha(b-a)^3+\beta(b-a)^2+\gamma(b-a)+\delta = f(b)\\3\alpha(b-a)^2+2\beta(b-a)+\gamma=f^{'}(b)\end{cases}$<p>求$f(x)$的近似极小点</p><p>$g^{‘}(x)=3\alpha(x-a)^2+2\beta(x-a)+\gamma$</p><p>令$g^{‘}(x)=0$</p><ul><li><p>当$\alpha=0$时</p><p>$\hat x=a-\dfrac{\gamma}{2\beta}$</p></li><li><p>当$\alpha \not=0$时</p><p>$\hat x=a+\dfrac{-\beta\pm\sqrt{\beta^2-3\alpha \gamma}}{3\alpha}$</p><p>为保证所求根为$g(x)$的极小点，在该点还需满足</p><p>$g^{‘’}(x)=6\alpha(x-a)+2\beta&gt;0$</p><p>$\Rightarrow \pm 2\sqrt{\beta^2-3\alpha \gamma}&gt;0$</p><p>$\Rightarrow\hat x=a+\dfrac{-\beta+\sqrt{\beta^2-3\alpha \gamma}}{3\alpha}=a-\dfrac{\gamma}{\beta+\sqrt{\beta^2-3\alpha\gamma}}$</p></li></ul><p>  $\alpha(b-a)^3+\beta(b-a)^2+\gamma(b-a)+\delta = f(b)\Rightarrow \alpha(b-a)^2+\beta(b-a)=\dfrac{f(b)-\delta}{b-a}-\gamma$</p><p>  $3\alpha(b-a)^2+2\beta(b-a)+\gamma=f^{‘}(b)\Rightarrow 3\alpha(b-a)^2+2\beta(b-a)=f^{‘}(b)-\gamma $</p><p>  令$u=\dfrac{f(b)-\delta}{b-a}-\gamma,v=f^{‘}(b)-\gamma$</p><p>  $\Rightarrow \beta = \dfrac{3u-v}{b-a},\alpha=\dfrac{v-2u}{(b-a)^2}$</p><p>  将$\alpha,\beta,\gamma$代入$\hat x$</p><p>  若$|f^{‘}(\hat x)|&lt;\epsilon$，终止迭代，否则当$f^{‘}(\hat x)&gt;0$时，用$\hat x$代替$b$，否则代替$a$</p><h2 id="平分法"><a href="#平分法" class="headerlink" title="平分法"></a>平分法</h2><p><strong>基本思想</strong></p><p>类似二分法求零点，平分法求导函数零点</p><h2 id="“成功-失败”法"><a href="#“成功-失败”法" class="headerlink" title="“成功-失败”法"></a>“成功-失败”法</h2><p><strong>基本步骤</strong></p><ul><li><p>取定初始点$x_0\in R$，搜索步长$h&gt;0$及精度$\epsilon&gt;0$</p></li><li><p>计算$x_1=x_0+h,f(x_1)$</p></li><li><p>若$f(x_1)&lt;f(x_0)$，搜索成功，用$x_1$代替$x_0$。$2h$代替$h$，继续搜索</p><p>若$f(x_1)\ge f(x_0)$，搜索失败，若$|h|&lt;\epsilon$，取$x^*=x_0$，计算结束，否则用$-\dfrac{h}{4}$代替$h$，继续搜索</p></li></ul><h2 id="0-618法"><a href="#0-618法" class="headerlink" title="0.618法"></a>0.618法</h2><p>一维搜索问题</p>$\begin{cases}\min &\varphi(\lambda)\\\rm s.t. &a_1 < \lambda < b_1\end{cases}$<p>其中$\varphi(\lambda)$为凸函数或拟凸函数</p><p>设$\epsilon&gt;0，\alpha=0.618$</p><p><strong>计算步骤</strong></p><ul><li><p>计算</p>$\begin{aligned}&\lambda_1=a_1+(1-\alpha)(b_1-a_1),\varphi(\lambda)\\&\mu_1=a_1+\alpha(b_1-a_1),\varphi(\mu_1)\end{aligned}$</li><li><p>若$b_k-a_k&gt;\epsilon$，则计算结束，最优解$\lambda^*\in[a_k,b_k]$</p><ul><li><p>若$\varphi(\lambda_k)&gt;\varphi(\mu_k)$</p><p>令$a_{k+1}=\lambda_k,b_{k+1}=b_k,\lambda_{k+1}=\mu_k,\mu_{k+1}=a_{k+1}+\alpha(b_{k+1}-a_{k+1})$，继续</p></li><li><p>若$\varphi(\lambda_k)\le\varphi(\mu_k)$</p><p>令$a_{k+1}=a_k,b_{k+1}=\mu_k,\mu_{k+1}=\lambda_k,\lambda_{k+1}=a_{k+1}+(1-\alpha)(b_{k+1}-a_{k+1})$，继续</p></li></ul></li></ul><p><strong>本质是平分法变种</strong></p><h2 id="初始搜索区间和初始点确定"><a href="#初始搜索区间和初始点确定" class="headerlink" title="初始搜索区间和初始点确定"></a>初始搜索区间和初始点确定</h2><ul><li>选定初始点的一个估计值$t_0$，初始步长$h&gt;0$，计算$\varphi(t_0)$</li><li>令$t_2=t_0+h$，计算$\varphi(t_2)$</li><li>若$\varphi(t_2)&gt;\varphi(t_0)$，令$h=-h$</li><li>令$t_1=t_0+h$，计算$\varphi(t_1)$</li><li>若$\varphi(t_1)\le \varphi(t_0)$，令$h=2h,t_2=t_0,t_0=t_1$，迭代4，若$\varphi(t_1)&gt;\varphi(t_0)$，下6</li><li>令$a=\min(t_1,t_2),b=\max(t_1,t_2),t_0=\dfrac{a+b}{2}$，结束</li></ul><h2 id="不精确一维搜索"><a href="#不精确一维搜索" class="headerlink" title="不精确一维搜索"></a>不精确一维搜索</h2><p>针对$\min \varphi(\lambda)=f(x^{(k)}+\lambda s^{(k)})$</p><p>常用$Wolfe-Powell$准则</p><p>对给定的常数$c_1,c_2,0&lt;c_1&lt;c_2&lt;1$，要求$\lambda_k$满足</p><ul><li>$f(x^{(k)})-f(x^{(k+1)})\ge -c_1\lambda_k\nabla f(x^{(k)})^Ts^{(k)}$</li><li>$\nabla f(x^{(k+1)})^Ts^{(k)}\ge c_2 \nabla f(x^{(k)})^Ts^{(k)}$</li></ul><p><strong>常取$c_1=0.1,c_2=0.5$</strong></p><p><strong>计算步骤</strong></p><ul><li><p>给定$c_1\in(0,1),c_2\in(c_1,1)$，令$a=0,b=-\infty,\lambda=1,j=0$</p></li><li><p>令$x^{(k+1)}=x^{k}+\lambda s^{(k)}$，计算$f_{k+1},g_{k+1}$，若$\lambda$满足条件，令$\lambda_k=\lambda$，计算结束</p><p>否则令$j=j+1$</p><ul><li><p>$\lambda$不满足条件1</p><p>令$b=\lambda,\lambda=\dfrac{\lambda+a}{2}$，继续</p></li><li><p>$\lambda$满足条件1不满足条件2</p><p>令$a=\lambda,\lambda=\min{2\lambda,\dfrac{\lambda+b}{2}}$，继续</p><p><strong>注</strong> 放大缩小的系数可以改成$0&lt;\beta_1&lt;1,\beta_2&gt;1$</p></li></ul></li></ul><p>二次插值法（略）</p><h2 id="多变量函数极值基本下降法"><a href="#多变量函数极值基本下降法" class="headerlink" title="多变量函数极值基本下降法"></a>多变量函数极值基本下降法</h2><h2 id="最速下降法"><a href="#最速下降法" class="headerlink" title="最速下降法"></a>最速下降法</h2><p><strong>迭代步骤</strong></p><ul><li>给定初始点$x^{(0)}$，精度$\epsilon&gt;0$，令$k=0$</li><li>计算$\nabla f(x^{(k)})$</li><li>若$\Vert \nabla f(x^{(k)})\Vert&lt;\epsilon$，则迭代结束，取$x^*=x^{(k)}$，否则向下继续</li><li>使用精确一维搜索求$\varphi(\lambda)=f(x^{(k)}-\lambda \nabla f(x^{(k)}))$的一个极小点$\lambda_k$，使$f(x^{(k)}-\lambda_k \nabla f(x^{(k)}))&lt;f(x^{(k)})$</li><li>令$x^{(k+1)}=x^{(k)}-\lambda_k\nabla f(x^{(k)}),k=k+1$，返回2</li></ul><h2 id="Newton法-1"><a href="#Newton法-1" class="headerlink" title="Newton法"></a>Newton法</h2><p>同一维搜索部分</p><p>$x^{(k+1)}=x^{(k)}-(\nabla^2f(x^{(k)}))^{-1}\nabla f(x^{(k)})$</p><p>迭代终止条件$\Vert\nabla f(x^{(k)})\Vert&lt;\epsilon$，下同</p><h2 id="阻尼Newton法"><a href="#阻尼Newton法" class="headerlink" title="阻尼Newton法"></a>阻尼Newton法</h2><p>在Newton法中，步长$\lambda_k$总为1</p><p>阻尼Newton法中，每步迭代沿方向$s^{(k)}=-(\nabla^2f(x^{(k)})^{-1}\nabla f(x^{(k)})$进行一维搜索来决定$\lambda_k$</p><p>即取$\lambda_k$使$f(x^{(k)}+\lambda_k s^{(k)})=\min\limits_{\lambda\ge 0}f(x^{(k)}+\lambda s^{(k)})\qquad\qquad(4-3)$</p><p>$x^{(k+1)}=x^{(k)}-\lambda_k(\nabla^2f(x^{(k)}))^{-1}\nabla f(x^{(k)})$</p><h2 id="共轭方向法与共轭梯度法"><a href="#共轭方向法与共轭梯度法" class="headerlink" title="共轭方向法与共轭梯度法"></a>共轭方向法与共轭梯度法</h2><p><strong>定义4.1</strong> 设$A$为$n$阶对称矩阵，$p,q$为$n$维列向量，若$p^TAq=0$，则称$p,q$为$A-$正交，或关于$A-$共轭。如果对于有限个向量$p_1,p_2,\cdots,p_m$，有$p_i^TAp_j=0(i\not=j,j=1,2,\cdots,m)$成立，则称这个向量组为$A-$正交（或共轭）向量组，也称它们是一组$A$共轭方向</p><p><strong>定理4.1</strong> 设$V$为$n$维欧式空间，向量$p_i\in V(i=1,2,\cdots,n)$是线性无关的，$q\in V$，若$q$与$p_1,p_2,\cdots,p_n$都正交，则$q=0$</p><p><strong>定理4.2</strong> 设$A$为$n$阶正定矩阵，$p_1,p_2,\cdots,p_n$为$A-$共轭的$n$维非零向量组，这次向量组必为线性无关的</p><p>$n$元二次函数无约束优化问题</p><p>$\min f(x)=c+b^Tx+\dfrac{1}{2}x^THx$</p><p>其中$c$为常数，$x,b$为$n$维列向量，$H$为$n$阶对称正定矩阵。</p><p>这时$\nabla f(x)=b+Hx,\nabla^2 f(x)=H$，$f(x)$有唯一的极小点</p><p>在极小点$x^*$处，$\nabla f(x^*)=b+Hx^*=0$，则$x^*=-H^{-1}b$</p><p><strong>定理4.3</strong> 设$H$为$n$阶对称正定矩阵，$s^{(0)},s^{(1)},\cdots,s^{(n-1)}\in R^n$是一组$H$共轭方向，对上述无约束优化问题，若从任一初始点$x^{(0)}\in R^n$出发，依次沿方向$s^{(0)},s^{(1)},\cdots,s^{(n-1)}$进行精确一维搜索，则至多经过$n$次迭代，即可求得$f(x)$的最小点</p><h3 id="共轭方向生成"><a href="#共轭方向生成" class="headerlink" title="共轭方向生成"></a>共轭方向生成</h3><ul><li><p>任给初始点$x^{(0)}$，令$s^{(0)}=-\nabla f(x^{(0)})$，代入到（4-3）中，确定$\lambda_0$</p></li><li><p>令$x^{(1)}=x^{(0)}+\lambda_0 s^{(0)},s^{(1)}=-\nabla f(x^{(1)})+\mu_{10}s^{(0)}$，其中$\mu_{10}$为待定系数，使$s^{(0)},s^{(1)}$是$H$共轭的</p><p>故$\mu_{10}=\dfrac{(\nabla f(x^1))^THs^{(0)}}{(s^{(0)})^THs^{(0)}}$</p></li><li><p>将$\mu_{10}$代入$s^{(1)}$表达式，求出搜索方向$s^{(1)}$</p></li><li><p>令$x^{(2)}=x^{(1)}+\lambda_1s^{(1)},s^{(2)}=-\nabla f(x^{(2)})+\mu_{20}s^{(0)}+\mu_{21}s^{(1)}$其中$\mu_{20},\mu_{21}$为待定系数，使$s^{(2)},s^{(1)},s^{(0)}$是$H$共轭的</p></li><li><p>$\cdots\cdots$</p></li></ul><h3 id="共轭梯度法"><a href="#共轭梯度法" class="headerlink" title="共轭梯度法"></a>共轭梯度法</h3><p><strong>计算步骤</strong> </p><ul><li><p>给定初始点$x^{(0)}$及精度$\epsilon&gt;0$</p></li><li><p>计算$g_0=\nabla f(x^{0})$，令$s^{(0)}=-g_0,k=0$</p></li><li><p>求$\min\limits_{\lambda\ge 0} f(x^{(k)}+\lambda s^{(k)})$决定$\lambda_k$，计算</p><p>$x^{(k+1)}=x^{(k)}+\lambda_k s^{(k)},g_{k+1}=\nabla f(x^{(k+1)})$</p></li><li><p>若$\Vert g_{k+1}\Vert&lt;\epsilon$，迭代结束，否则向下继续</p></li><li><p>若$k&lt;n-1$，计算$\mu_{k+1}=\dfrac{\Vert g_{k+1}\Vert^2}{\Vert g_k\Vert^2},s^{(k+1)}=-g_{k+1}+\mu_{l+1}s^{(k)}$，令$k=k+1$转回3</p><p>若$k=n-1$，令$x^{(0)}=x^{(n)}$，转回2</p><p>$n$为维数，即共轭方向个数</p></li></ul><h2 id="变尺度法"><a href="#变尺度法" class="headerlink" title="变尺度法"></a>变尺度法</h2><h3 id="对称秩1算法"><a href="#对称秩1算法" class="headerlink" title="对称秩1算法"></a>对称秩1算法</h3><p>略</p><h3 id="DFP算法"><a href="#DFP算法" class="headerlink" title="DFP算法"></a>DFP算法</h3><p>是一种秩2对称算法</p><p><strong>计算步骤</strong></p><ul><li><p>给定初始$x^{(0)}$，计算精度$\epsilon&gt;0$和初始矩阵$H_0=I$，令$k=0$</p></li><li><p>计算$s^{(k)}=-H_kg_k$，沿$s^{(k)}$进行精确一维搜索，求出步长$\lambda_k$，使</p><p>$f(x^{(k)}+\lambda_k s^{(k)})=\min\limits_{\lambda\ge 0} f(x^{(k)}+\lambda s^{(k)})$</p><p>令$x^{(k+1)}=x^{(k)}+\lambda_k s^{(k)}$</p></li><li><p>若$\Vert g_{k+1}\Vert&lt;\epsilon$，则取$x^*=x^{(k+1)}$，计算结束</p><p>否则，计算$H_{k+1}$</p><p>$H_{K+1}=H_K+\dfrac{\Delta x_k\Delta x_k^T}{\Delta x_k^T\Delta g_k}-\dfrac{H_k\Delta g_k(H_k\Delta g_k)^T}{\Delta g_k^TH_k\Delta g_k}$</p><p>若$k\not= n-1$，则令$k=k+1$，继续</p><p>若$k=n-1$，则$x^{(0)}=x^{(k+1)},k=0$，继续</p><p><strong>注</strong> $\Delta x_k = x_{k+1}-x_k$</p></li></ul><h3 id="吴桂变尺度法"><a href="#吴桂变尺度法" class="headerlink" title="吴桂变尺度法"></a>吴桂变尺度法</h3><p>略</p><h3 id="Huang类算法"><a href="#Huang类算法" class="headerlink" title="Huang类算法"></a>Huang类算法</h3><p>略</p><h3 id="自调节变尺度算法类"><a href="#自调节变尺度算法类" class="headerlink" title="自调节变尺度算法类"></a>自调节变尺度算法类</h3><p>略</p><h3 id="BFGS算法"><a href="#BFGS算法" class="headerlink" title="BFGS算法"></a>BFGS算法</h3><p>略</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>$Newton$法，阻尼$Newton$法以及共轭梯度法最大区别在于求$\lambda$处</p><p>$Newton$法，$\lambda$恒为1</p><p>最速下降法，$\varphi(\lambda)=f(x^{(k)}-\lambda \nabla f(x^{(k)}))$</p><p>阻尼$Newton$法，$\min\limits_{\lambda\ge 0}f(x^{(k)}+\lambda s^{(k)}),s^{(k)}=-(\nabla^2f(x^{(k)})^{-1}\nabla f(x^{(k)})$</p><p>共轭梯度法，$x^{(k+1)}=x^{(k)}+\lambda_k s^{(k)},s^{(k+1)}=-g_{k+1}+\mu_{l+1}s^{(k)},s^{(1)}=-g_0$</p><h2 id="直接搜索法"><a href="#直接搜索法" class="headerlink" title="直接搜索法"></a>直接搜索法</h2><p>略</p><h1 id="约束优化方法"><a href="#约束优化方法" class="headerlink" title="约束优化方法"></a>约束优化方法</h1><h2 id="Kuhn-Tucker条件"><a href="#Kuhn-Tucker条件" class="headerlink" title="Kuhn-Tucker条件"></a>Kuhn-Tucker条件</h2><p>一般约束优化问题为</p>$$\begin{aligned}&\begin{cases}\min &f(x)\\\rm s.t. &g_i(x)\le 0, i=1,2,\cdots,m\qquad\qquad(1-1)\\&h_j(x)=0,j=1,2,\cdots,p\\&x\in X\subset R^n\end{cases}\\&x=(x_1,x_2,\cdots,x_n)\\&S=\{x|x\in X,g_i(x)\le 0,i=1,2,\cdots,m,h_j(x)=0,j=1,2,\cdots,p\}\\&I(x^0)=\{i|g_i(x^0)=0,1\le i\le m\}\end{aligned}$$<p>当$i\in I(x^0)$时，对应的约束$g_i(x)\le 0$称为在$x^0$处的紧约束，或起作用约束，而$I(x^0)$称为$x^0$点紧约束指标集</p><p><strong>定理1.1</strong> 最优性的一阶必要条件</p><p>设$x^{*}$是问题（1-1）的一个可行解，$X\subset R^n$为非空开集，$f,g_i(i\in I(x^{*}))$在$x^{*}$可微，$g_i(i\not\in I(x^*))$在$x^{*}$点连续，$\nabla g_i(x^*),i\in I(x^*),\nabla h_j(x^*),j=1,2,\cdots,p$线性无关，若$x^{*}$是（1-1）的局部最优解，则有实数$u_i,v_j$（其中$i\in I(x^*),j=1,2,\cdots,p$）使得</p>$\nabla f(x^{*}) + \sum\limits_{i \in I} u_i \nabla g_i(x^{*}) + \sum\limits_{j = 1}^p v_j\nabla h_j(x^{*})=0\qquad u_i \ge 0,i \in I(x^{*})$<p>如果加上$i\in I$时，$g_i$在$x^*$点可微，则上述条件可改写为</p>$\nabla f(x^{*})+\sum\limits_{i = 1}^{m} u_i\nabla g_i(x^{*})+\sum\limits_{j = 1}^p v_j\nabla h_j(x^{*})=0\qquad u_i \ge 0,u_ig_i(x^{*}) = 0,i=1,2,\cdots,m$<p>上述条件称为$Kuhn-Tucker$最优性必要条件，满足条件的点称为$K-T$点</p><p><strong>定理1.2</strong> 最优性的充分条件</p><p>设$X\subset R^n$为非空开集，$x^*\in S$，在$x^*$，$K-T$条件成立，即存在数$u_i\ge 0(i\in I(x^*)),v_i(i=1,2,\cdots,p)$，使得</p>$\nabla f(x^*)+\sum\limits_{i\in I} u_i\nabla g_i(x^*)+\sum\limits_{j=1}^p v_j\nabla h_j(x^*)=0$<p>令$J={i|v_i&gt;0},K={i|v_i&lt;0}$，设$f$在$x^*$点伪凸，$g_i(i\in I)$在$x^*$点拟凸，$h_i(i\in J)$在$x^*$点拟凸，$h_i(i\in K)$在$x^*$点拟凹，则$x^*$是问题（1-1）的全局最优解</p><h3 id="判断一个点是否是K-T点"><a href="#判断一个点是否是K-T点" class="headerlink" title="判断一个点是否是K-T点"></a>判断一个点是否是K-T点</h3><ul><li><p>获取$x^*\in S$，是一个可行解</p></li><li><p>计算$\nabla f(x^*)$，根据</p>$\nabla f(x^*)+\sum\limits_{i\in I} u_i\nabla g_i(x^*)+\sum\limits_{j=1}^p v_j\nabla h_j(x^*)=0\qquad u_i\ge0,i\in I(x^*)$计算$u_i,v_j$，非紧约束对应的$u_i=0$</li><li><p>若$u_i&gt;0$，且$f,g_i(i\in I)$在$x^*$拟凸，$h_i$根据对应$v_i$正负为拟凸/凹，则是K-T点</p></li></ul><h2 id="惩罚函数法"><a href="#惩罚函数法" class="headerlink" title="惩罚函数法"></a>惩罚函数法</h2><p>在问题（1-1）中，定义$f,g_i,h_j\in C^1$</p><p>针对上述定义乘法函数</p><p>$F(x.M)=f(x)+Mp(x)$</p><p>其中$M&gt;0$为常数，称为<strong>惩罚因子</strong>，$p(x)$是定义在$R^n$上的一个函数，称为<strong>惩罚项</strong>，满足</p><ul><li>$p(x)$连续</li><li>对任意$x\in R^n$，有$p(x)\ge 0$</li><li>当且仅当$x\in S$时，$p(x)=0$</li></ul><p>通常对等式约束，定义$g_j^+(x)=(h_j(x))^2,j=1,2,\cdots,p$</p><p>对不等式约束，定义$g_{i+p}^+(x)=\begin{cases}0\quad &g_i(x)\le 0\\(g_i(x))^2&g_i(x)>0\end{cases}\quad i=1,2,\cdots,m$</p><p>注：这里只惩罚紧约束的$g_i(x)$</p><p>令$L=p+m$，于是惩罚函数为$F(x,M_k)=f(x)+M_k\sum\limits_{i=1}^Lg_i^+(x)$</p><p>其中$M_k&gt;0,M_1&lt;M_2&lt;\cdots&lt;M_k&lt;\cdots,\lim\limits_{k\rightarrow\infty}M_k=+\infty$</p><ul><li>可微则连续</li><li>$g_i^+&gt;0$</li><li>$x\in S$，满足约束</li></ul><h3 id="SUMT外点法"><a href="#SUMT外点法" class="headerlink" title="SUMT外点法"></a>SUMT外点法</h3><p>计算步骤</p><ul><li><p>选取$M_1&gt;0$，精度$\epsilon&gt;0,c\ge2$，初始点$x^{(0)}$，令$k=1$</p></li><li><p>以$x^{(k-1)}$为初始点，求解无约束优化问题</p><p>$\min F(x,M_k)=f(x)+M_k\sum\limits_{i=1}^L g_i^+(x)$</p><p>设其最优解为$x^{(k)}=x(M_k)$</p></li><li><p>令</p>$\tau_1=\max\limits_{1\le i\le p}\{|h_j(x^{(k)})|\},\tau_2=\max\limits_{1\le i\le m}\{|g_i(x^{(k)})|\},\tau=\max\{\tau_1,\tau_2\}$</li><li><p>若$\tau&lt;\epsilon$，迭代结束，取$x^*=x^{(k)}$，否则令$M_{k+1}=cM_k,k=k+1$，回到2</p><p>结束条件也可为$M_kp(x^{(k)})&lt;\epsilon$</p></li></ul><p><strong>收敛性分析</strong></p><p>略</p><p><strong>SUMT外点法手解</strong></p><p>在上面步骤中，取$M\rightarrow +\infty$，将$M$作为未知数代入求$\nabla F,\nabla^2F$</p><h2 id="碰壁函数法"><a href="#碰壁函数法" class="headerlink" title="碰壁函数法"></a>碰壁函数法</h2><p>$\rm intS$表示可行集$S$内部</p><p>从一个可行点$x^{(0)}$出发，在可行点之间迭代。为使迭代点保持为可行点，在约束集$S$边界上建造一道围墙，阻挡迭代点列离开可行集</p><p>碰壁项是定义于$\rm intS$上的一个函数$B(x)$，满足</p><ul><li>$B(x)$是连续的</li><li>$B(x)\ge 0$</li></ul><ul><li>当$x$趋近于$S$的边界时，$B(x)\to \infty$</li></ul><p>通常定义碰壁项为$B(x)=\sum\limits_{i=1}^mg_i^+(x)$</p><p>$g_i^+(x)=-\dfrac{1}{g_i(x)}\quad or\quad g_i^+(x)=-\ln(-g_i(x))\quad i=1,2,\cdots,m$</p><p>碰壁函数定义为$F(x,r_k)=f(x)+r_kB(x)$</p><p>其中$r_k&gt;0,r_1&gt;r_2&gt;\cdots&gt;r_k&gt;\cdots,\lim\limits_{k\to +\infty}r_k=0$</p><h3 id="SUMT内点法"><a href="#SUMT内点法" class="headerlink" title="SUMT内点法"></a>SUMT内点法</h3><p>计算步骤</p><ul><li><p>选取$r_1&gt;0$（如取$r_1=1$），$c\ge2$（一般取$c\in [2,50]$，常取$c\in [4,10]$），精度$\epsilon&gt;0$</p></li><li><p>求可行集$S$的一个内点$x^{(0)}\in \rm intS$，令$k=1$</p></li><li><p>以$x^{(k-1)}$为初始点，使用求解无约束优化问题的方法求解</p> $\begin{cases}\min &F(x,r_k)=f(x)+r_kB(x)\\ \rm s.t.&x\in \rm intS\end{cases}$ <p>设其最优解为$x^{(k)}=x(r_k)$</p></li><li><p>若$x^{(k)}$满足以下结束准则之一，结束迭代（常用第四个），否则取<br>$r_{k+1}&lt;r_k\quad (eg:r_{k+1}=\dfrac{r_k}{c})$，$k=k+1$继续迭代</p><ul><li>$\Vert x^{(k)}-x^{(k-1)}\Vert&lt;\epsilon$</li><li>$|f(x^{(k)})-f(x^{(k-1)})|&lt;\epsilon$</li><li>$\left\vert\dfrac{f(x^{(k)})-f(x^{(k-1)})}{f(x^{(k)})}\right\vert&lt;\epsilon$</li><li>$r_kB(x^{(k)})&lt;\epsilon$</li></ul></li></ul><p><strong>收敛性分析</strong></p><p>略</p><p><strong>SUMT内点法手解</strong></p><p>在上面步骤中，取$r\rightarrow 0$，将$r$作为未知数代入求$\nabla F,\nabla^2F$</p><h2 id="可行方向法"><a href="#可行方向法" class="headerlink" title="可行方向法"></a>可行方向法</h2><p>非线性规划问题</p>$\begin{cases}\min &f(x)\\\rm s.t.&x\in \rm S\subset R^n\end{cases}\qquad\qquad(4-1)$<p><strong>定义</strong> 非零向量$d$称为在点$x\in S$的一个可行方向，如果存在一个数$\delta&gt;0$，使得对$\forall \lambda\in(0,\delta)$，都有$x+\lambda d\in S$。$d\not=0$称为在点$x\in S$的一个改进的可行方向，如果存在$\delta&gt;0$，使得对$\forall \lambda\in(0,\delta)$，都有$f(x+\lambda d)&lt;f(x)$，且$x+\lambda d\in S$</p><p><strong>定理4.1</strong> 设$x$是问题</p>$\begin{cases}\min &f(x)\\\rm s.t.&Ax\le b\\&Ex=e\\&x\in \rm S^n\end{cases}\qquad\qquad(4-2)$<p>的一个可行解，假定$A_1x=b_1,A_2x&lt;b_2$，其中$A^T=(A_1^T,A_2^T),b^T=(b_1^T,b_2^T)$，$A$是$m\times n$矩阵，$E$是$l\times n$矩阵，$b\in R^m,e\in R^l$，则一个非零向量$d$是在$x$点的可行方向，当且仅当$A_1d\le 0,Ed=0$，如果$\nabla f(x)^T d&lt;0$，则$d$是一改进方向。其中$f(x)$在$x$点可微</p><p><strong>定理4.2</strong>  设$x$是问题</p>$\begin{cases}\min &f(x)\\\rm s.t.&g_i(x)\le 0,i=1,2,\cdots,m\\&x\in \rm S^n\end{cases}\qquad\qquad(4-3)$<p>的一个可行解，令$S=\{x|x\in R^n,g_i(x)\le 0,i=1,\cdots,m\},I=\{i|g_i(x)=0\}$，即$I$是$x\in S$点紧约束的指标集，设$f,g_i(i\in I)$在$x$点可微，$g_o(i\not\in I)$在$x$点连续，如果$\nabla f(x)^Td&lt;0,\nabla g_i(x)^Td&lt;0(i\in I)$，则$d$是一改进的可行方向</p><h3 id="Zoutendijk的可行方向法"><a href="#Zoutendijk的可行方向法" class="headerlink" title="Zoutendijk的可行方向法"></a>Zoutendijk的可行方向法</h3><ul><li><p>线性约束的</p><p>可通过求如下3个问题获取$d$</p><ul><li>$\begin{cases}\min &z=\nabla f(x)^Td\\\rm s.t.&A_1d\le 0\\&Ed=0\\&-1\le d_j\le1,j=1,2,\cdots,n\end{cases}$</li><li>$\begin{cases}\min &z=\nabla f(x)^Td\\\rm s.t.&A_1d\le 0\\&Ed=0\\&d^Td\le1\end{cases}$</li><li>$\begin{cases}\min &z=\nabla f(x)^Td\\\rm s.t.&A_1d\le 0\\&Ed=0\\&\nabla f(x)^Td\ge -1\end{cases}$</li></ul><p>其中$d=(d_1,d_2,\cdots,d_n)^T$，最后一个约束是为了保证解有界的规格化约束</p><p>第二个问题的约束是<strong>二次</strong>的，可化简</p><p>上述任一问题，$d=0$都是可行解，且目标函数值$z=0$，所以上述问题的最优目标函数值$z^*\le 0$</p><p>若$z^*&lt;0,d\not = 0$，则$d$是一个改进的可行方向，而$z=0$当且仅当$x$是K-T点</p><p><strong>计算方法</strong></p><ul><li><p>求（4-2）的一初始可行解$x^{(1)}$，令$k=1$</p></li><li><p>对于可行点$x^{(k)}$，设<br>$A_1x^{(k)}=b_1,A_2x^{(k)}&lt;b_2,A^T=(A^T_1,A_2^T),b^T=(b^T_1,b_2^T)$<br>求解问题1（2,3），得到最优解$d_k$，如果$\nabla f(x^{(k)})^T d_k=0$，计算结束，$x^{(k)}$是K-T点，否则继续</p></li><li><p>求解线搜索问题</p>$\begin{cases}\min &f(x^{(k)}+\lambda d_k)\\\rm s.t.&0\le \lambda\le \lambda_{max}\end{cases}$<p>其中</p>$\lambda_{max}=\begin{cases}\min \{\dfrac{\hat b_i}{\hat d_i}|\hat d_i>0\},if \quad\hat d\not\le0\\+\infty,if\quad \hat d\le 0\end{cases}$<p>$\hat b=b_2-A_2x^{(k)},\hat d=A_2d_k$</p><p>设$\lambda_k$是最优解，令$x^{(k+1)}=x^{(k)}+\lambda_kd_k,k=k+1$，回到2</p></li></ul></li></ul><ul><li><p>非线性不等式约束</p><p>可通过如下方法求得$d$</p> $\begin{cases}\min &z\\\rm s.t.&\nabla f(x)^Td-z\le 0\\&\nabla g_i(x)^Td-z\le0,i\in I(x)\\&-1\le d_j\le1,j=1,2,\cdots,n\end{cases}$ <p>令$(\overline z,\overline d)$为最优解，有$\overline z\le 0$，若$\overline z&lt; 0$，则$\overline d$是一个改进的可行方向，否则，$x$是K-T点的充要条件为$\overline z=0$</p><p><strong>计算方法</strong></p><ul><li><p>选取允许误差$\epsilon_1&gt;0,\epsilon_2&gt;0$，求一初始可行点$x^{(1)},k=1$</p></li><li><p>确定指标集$I(x^{(k)})={i|g_i(x^{(k)})=0}$</p></li><li><p>若$I(x^{(k)})=\emptyset,\Vert\nabla f(x^{(k)}\Vert\le \epsilon_1$，计算结束，取$x^*=x^{(k)}$</p><p>若$I(x^{(k)})=\emptyset,\Vert\nabla f(x^{(k)}\Vert&gt; \epsilon_1$，转到6</p><p>若$I(x^{(k)})\not=\emptyset$，转到4</p></li><li><p>令$x=x^{(k)}$，求$(\overline z_k,\overline d_k)$</p></li><li><p>若$|\overline z_k|&lt;\epsilon_2$，计算结束，否则令$d_k\overline d_k$，转到6</p></li><li><p>求解线搜索问题</p>$\begin{cases}\min &f(x^{(k)}+\lambda d_k)\\\rm s.t.&0\le \lambda\le \lambda_{max}\end{cases}$<p>的最优解$\lambda_k$，其中</p>$\lambda_{max}=\max\{\lambda|x^{(k)}+\lambda d_k\in S\}$，令$x^{(k+1)}=x^{(k)},k=k+1$，回到2</li></ul></li></ul><h2 id="梯度投影法"><a href="#梯度投影法" class="headerlink" title="梯度投影法"></a>梯度投影法</h2><p>线性约束的优化问题</p>$\begin{cases}\min &f(x)\\\rm s.t.&Ax\le b\\&Ex=e\\\end{cases}$<p>其中$A_{m\times n},E_{l\times n},b\in R^m,e\in R^l,x\in R^n, f:R^n\to R,f\in C^1$，可行域为$\Omega$</p><p><strong>基本思想</strong></p><p>当迭代点$x^{(k)}$在可行域$\Omega$的内部时，取$d=-\nabla f(x^{(k)})$为迭代方向，当$x^{(k)}$在$\Omega$的边界上时，取$-\nabla f(x^{(k)})$在这些边界面的交集上的投影为迭代的方向</p><p><strong>定义5.1</strong> 称$n\times n$矩阵$P$为投影矩阵，如果$P=P^T$，且$PP=P$</p><p><strong>引理 1</strong> 设$P$为$n\times n$矩阵</p><ul><li><p>若$P$为投影矩阵，则$P$是半正定的</p></li><li><p>$P$是投影矩阵，当且仅当$I-P$是投影矩阵，其中$I$为$n$阶单位阵</p></li><li><p>设$P$是投影矩阵，令$Q=I-P$，则</p>$L=\{Px|x\in R^n\}$与$L^{\perp}=\{Qx|x\in R^n\}$为互相正交的线性子空间，并且任一点$x\in R^n$可唯一表示为<p>$x=p+q,p\in L,q\in L^{\perp}$</p></li></ul><p><strong>引理 2</strong> 设$x$为上面优化问题的一个可行解，且使<br>$A_1x=b_1,A_2x&lt;b_2,A^T=(A_1^T,A_2^T),b^T=(b_1^T,b_2^T)$，设$f(x)$在$x$点可微，$M^T=(A_1^T,E^T)$满秩，则</p><ul><li>$P=I-M^T(MM^T)^{-1}M$为投影矩阵</li><li>若$P\nabla f(x)\not=0$，则$d=-P\nabla f(x)$是$x$点的一个改进的可行方向</li></ul><p><strong>定理5.1</strong> 设$x$为上面优化问题的一个可行解，且使<br>$A_1x=b_1,A_2x&lt;b_2,A^T=(A_1^T,A_2^T),b^T=(b_1^T,b_2^T)$，$M^T=(A_1^T,E^T)$满秩，令</p><p>$P=I-M^T(MM^T)^{-1}M,w=-(MM^T)^{-1}M\nabla f(x),w^T=(u^T,v^T)$，设<br>$P\nabla f(x)=0$</p><ul><li><p>若$u\ge 0$，则$x$是一个K-T点</p></li><li><p>若$u\not\ge 0$，令$u_j$是$u$的一个负分量，$\hat M^T=(\hat A_1^T,E^T)$，其中$\hat A_1$是由$\hat A_1$中去掉第$j$行后得到的矩阵，令</p><p>$\hat P=\hat M^T(\hat M\hat M^T)^{-1}\hat M,d=-\hat P\nabla f(x)$</p><p>则$d$是一个改进的可行方向</p></li></ul><p><strong>计算方法</strong></p><ul><li><p>选取$x^{(1)}$为一个可行解，给定计算精度$\epsilon&gt;0$</p></li><li><p>计算$\nabla f(x^{(k)}),J_k=\{j|a_j^T x^{k}=B_j\}$（这里以及记录的是紧约束，与上面不同的是，将等式约束也算在内），若$\Vert \nabla f(x^{(k)}\Vert&lt;\epsilon$，则$x^{(k)}$是K-T点。计算结束，否则</p><ul><li>若$J_k=\emptyset$，令$P=I$</li><li>若$J_k\not=\emptyset$，令$P=I-M_k^T(M_kM_k^T)^{-1}M_k$</li></ul></li><li><p>若$P\nabla f(x^{(k)})\not=0$，令$d_k=-P\nabla f(x^{(k)})$</p><p>若$P\nabla f(x^{(k)})=0$，令$w=-(MM^T)^{-1}M\nabla f(x)=\begin{bmatrix}u\\v\end{bmatrix}$</p><ul><li><p>若$u\ge 0$，则$x^{(k)}$为K-T点，计算结束</p></li><li><p>若$u$有某个分量$u_j&lt;0$，令$\hat M_k$是在$M_k$中去掉与$u_j$对应的第$j$行而得到的矩阵</p><p>令$\hat P=I-\hat M_k^T(\hat M_k\hat M_k^T)^{-1}\hat M_k,d=-\hat P\nabla f(x^{(k)})$</p></li></ul></li><li><p>计算</p>$\lambda_M=\begin{cases}\min \left\{ \dfrac{B_i-a_i^Tx^{(k)}}{a_i^Td_k}|i\not\in J_k,a_i^Td_k>0 \right\}\\+\infty,if \forall i,a_i^Td_k\le 0\end{cases}$<p>设$\lambda$是线搜索问题</p>$\begin{cases}\min &f(x^{(k)}+\lambda d_k)\\\rm s.t.&0\le\lambda\le\lambda_M\end{cases}$<p>的解，令$x^{(k+1)}=x^{(x)}+\lambda d_k,k=k+1$</p></li></ul><h2 id="既约梯度法"><a href="#既约梯度法" class="headerlink" title="既约梯度法"></a>既约梯度法</h2><p>略</p><h2 id="乘子法"><a href="#乘子法" class="headerlink" title="乘子法"></a>乘子法</h2><h3 id="Hestenes乘子法"><a href="#Hestenes乘子法" class="headerlink" title="Hestenes乘子法"></a>Hestenes乘子法</h3><p>解决了惩罚函数法惩罚因子$M$越来越大时，惩罚目标函数$F(x,M)$的$Hesse$z阵越来越病态的问题</p><p><strong>定理7.1</strong> 设$x^{(k)}$是无约束优化问题</p><p>$\min \varphi(x,\mu^{(k)})=f(x)+\sum\limits_{j=1}^p\mu_j^{(k)}h_j(x)+\dfrac{c}{2}\sum\limits_{j=1}^p[h_j(x)]^2$</p><p>的最优解，则$x^{(k)}$是问题</p>$\begin{cases}\min &f(x)\\\rm s.t.&h_i(x)=0,i=1,2,\cdots,p\end{cases}\qquad\qquad(7-1)$<p>的最优解，$\mu_1^{(k)},\mu_2^{(k)},\cdots,\mu_p^{(k)}$为其相应的$Lagrange$乘子的充要条件是</p><p>$h_j(x^{(k)})=0(j=1,2,\cdots,p)$</p><p><strong>迭代步骤</strong></p><ul><li><p>给定初始点$x^{(0)}$，初始乘子向量$\mu^{(1)}$（无其他信息，取0），计算精度$\epsilon&gt;0$，取$c&gt;0,0&lt;r&lt;1,\alpha&gt;0,k=1$</p></li><li><p>以$x^{(k-1)}$为初始点，求解$\min \varphi(x,\mu^{(k)})$，得解$x^{(k)}$，其中$\varphi(x,\mu)$由定理7.1问题确定</p></li><li><p>若$\Vert h(x^{(k)})\Vert&lt;\epsilon$，计算结束，取$x^{(k)}$为（7-1）最优解，否则计算$\beta=\dfrac{\Vert h(x^{(k)})\Vert}{\Vert h(x^{(k-1)})\Vert}$，若$\beta\le r$，继续，否则令$c=\alpha c$，继续</p></li><li><p>计算$\mu_j^{(k+1)}=\mu_j^{(k)}+ch_j(x^{(k)})(j=1,2,\cdots,p),k=k+1$</p></li></ul><h2 id="二次逼近法"><a href="#二次逼近法" class="headerlink" title="二次逼近法"></a>二次逼近法</h2><p>二次规划（QP）</p><p>二次规划指在变量$x_1,x_2,\cdots,x_n$的线性等式和线性不等式约束下，求二次函数$Q(x)$的极小值问题</p>$$\begin{cases}\min &Q(x)=\dfrac{1}{2}x^TGx+g^Tx\\\rm s.t.&a_i^Tx=b_i,i=1,2,\cdots,m\\&a_i^Tx\le b_i,i=m+1,\cdots,p\end{cases}\qquad\qquad(8-1)$$<p>其中$G$为$n$阶对称矩阵，$g,a_1,a_2,\cdots,a_p$均为$n$维列向量，假设$a_1,\cdots,a_m$线性无关。而$x=(x_1,x_2,\cdots,x_n)^T,b_1,b_2,\cdots,b_p$为已知常数，$m\le n,p\ge m$</p><p><strong>定义</strong> 设$\overline x$是问题（8-1）的可行解，若某个$i\in{1,2,\cdots,p}$，使得$a_i^T\overline x=b_i$成立，则称它为$\overline x$点出的有效约束，称在$\overline x$点处所有有效约束的指标组成的集合$J=J(\overline x)=\{i|a_i^T\overline x=b_i\}$为$\overline x$点处的有效指标集，简称为$\overline x$处的有效集</p><p><strong>有效集与上面紧约束集合定义类似，但是同时包含不等式约束与等式约束</strong></p><h3 id="二次规划"><a href="#二次规划" class="headerlink" title="二次规划"></a>二次规划</h3><h4 id="正定二次规划"><a href="#正定二次规划" class="headerlink" title="正定二次规划"></a>正定二次规划</h4><p><strong>定理8.1</strong> 点$x^*$是正定二次规划问题（8-1）的严格整体解的充要条件是$x^*$是K-T点，即有乘子向量$\lambda^*=(\lambda_1^*,\cdots,\lambda_m^*,\cdots,\lambda_p^*)$，使得</p>$\begin{cases}Gx^*+g+\sum\limits_{i\in E}\lambda^*a_i+\sum\limits_{i\in J}\lambda_i^*a_i=0\\a_i^Tx-b_i=0,i\in E\\a_i^Tx-b_i\le0,i\in I\\\lambda_i^*\ge 0,i\in I\\\lambda_i^*=0,i\in I\backslash J^*(从I中去除J^*)\end{cases}$<p>K-T点$x^*$与其对应的乘子向量$\lambda^*$，称为问题（8-1）的K-T对</p><p><strong>定理8.2</strong> 若正定QP问题（8-1）有可行解，则它必有最优解，且最优解唯一</p><p><strong>定理8.3</strong> 设$x^*$是正定QP问题（8-1）的最优解，且在$x^*$点处的有效集为$J^*$，则$x^*$是如下等式约束问题的唯一解</p>$\begin{cases}\min &Q(x)=\dfrac{1}{2}x^TGx+g^Tx\\\rm s.t.&a_i^Tx=b_i,i\in J^*\\\end{cases}$<h4 id="仅含等式约束的正定二次规划"><a href="#仅含等式约束的正定二次规划" class="headerlink" title="仅含等式约束的正定二次规划"></a>仅含等式约束的正定二次规划</h4>$\begin{cases}\min &Q(x)=\dfrac{1}{2}x^TGx+g^Tx\\\rm s.t.&a_i^Tx=b_i,i\in E=\{1,2,\cdots,m\}\\\end{cases}$<p>设$a_1,a_2,\cdots,a_m$线性无关，$G$为$n$阶对称正定矩阵，$m\le n，A=(a_1,\cdots,a_m),B=(b_1,\cdots,b_m)^T$</p><p><strong>定理8.4</strong> 在上述假设下，问题的K-T对$(x^*,\lambda^*)$是存在且唯一的，且$(x^*,\lambda^*)$为问题的K-T对的充要条件为他们满足</p>$\begin{bmatrix}G&&A\\A^T&&0\end{bmatrix}\begin{bmatrix}x\\\lambda\end{bmatrix}=\begin{bmatrix}-g\\b\end{bmatrix}$<h4 id="一般正定二次规划的有效集法"><a href="#一般正定二次规划的有效集法" class="headerlink" title="一般正定二次规划的有效集法"></a>一般正定二次规划的有效集法</h4><p><strong>计算步骤</strong></p><ul><li><p>选取问题（8-1）的初始可行点$x^{(1)}$，确定$x^{(1)}$点处的有效集$J_1$，使$a_i(i\in J_1)$线性无关，令$k=1$</p></li><li><p>求解仅含等式约束的正定二次规划问题，设其解为$d^{(k)}$</p></li><li><p>若$d^{(k)}=0$，则计算相应的乘子$\lambda_i^{(k)}(i\in J_k)$，到4，否则到5</p></li><li><p>若$\forall i\in J_k\cap I$，都有$\lambda^{(k)}\ge 0$，则$x^{(k)}$为问题（8-1）的最优解，计算结束</p><p>否则求出$\lambda_q^{(k)}=\min\{\lambda_i^{(k)}|i\in J_k\cap I\}$，令$x^{(k+1)}=x^{(k)},J_{k+1}=J_k\backslash{q},k=k+1$，返回2</p></li><li><p>若$\overline x^{(k)}=x^{(k)}+d^{(k)}$满足$a_i^T x\le b_i,i\in I\backslash J_k$，则令$x^{(k+1)}=\overline x^{(k)}$，并求出$x^{(k+1)}$点处的有效集$J_{k+1}$，令$k=k+1$，返回2</p><p>否则到6</p></li><li><p>计算步长$a_k=\min\left\{-\dfrac{a_i^Tx^{(k)}-b_i}{a_i^T d^{(k)}}|i\in I\backslash J_k,a_i^Td^{(k)}>0\right\}$</p><p>令$x^{(k+1)}=x^{(k)}+a_kd^{(k)}$，并求$x^{(k+1)}$处的有效集$J_{k+1}，k=k+1$，返回2</p></li></ul><h4 id="二次逼近法-1"><a href="#二次逼近法-1" class="headerlink" title="二次逼近法"></a>二次逼近法</h4>$\begin{cases}\min &f(x)\\\rm s.t.&c_i(x)=0,i\in E=\{1,2,\cdots,m\}\\&c_i(x)=0,i\in I=\{m+1,\cdots,p\}\end{cases}\qquad\qquad(8-14)$<p><strong>基本思想</strong></p><p>将问题（8-14）转化为求解一些列二次规划子问题，因此也称为序列二次规划法，简写为SQP法</p><p>略</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;最优化方法知识点归纳&lt;/br&gt;无约束优化方法与约束优化方法&lt;/center&gt;
    
    </summary>
    
    
      <category term="Course" scheme="http://yoursite.com/categories/Course/"/>
    
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Course" scheme="http://yoursite.com/tags/Course/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE - Thread</title>
    <link href="http://yoursite.com/2020/09/15/JavaSEThread/"/>
    <id>http://yoursite.com/2020/09/15/JavaSEThread/</id>
    <published>2020-09-15T04:00:46.000Z</published>
    <updated>2020-10-23T10:12:08.221Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Java-SE基础"><a href="#Java-SE基础" class="headerlink" title="Java SE基础"></a>Java SE基础</h1><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="进程三特性："><a href="#进程三特性：" class="headerlink" title="进程三特性："></a>进程三特性：</h3><ul><li>独立性：进程是系统中独立存在的实体，可以拥有自己独立的资源，每个进程有自己的私有地址空间。</li><li>动态性：进程与程序的区别在于，程序只是一个静态的指令集合，而进程是一个正在系统中活动的指令集合。进程中加入了时间的概念，具有自己的生命周期与各种不同的状态。</li><li>并发性：多个进程可以在单个处理器上并发执行，多个进程之间不会相互影响。</li></ul><p>并发性（concurrency）与并行性（parallel）是两个概念，并行指在同一时刻，有多条指令在多个处理器上同时执行，并发指同一时刻只能有一条指令执行，但是多个进程指令被快速轮换执行，使得宏观上具有多个进程同时执行的效果。</p><p>Runable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体，实际线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。</p><p>通过Runable接口的方式创建的多个线程可以共享线程类的实例变量。</p><p>Callable接口与Future接口组合使用，Callable的call()相比于run()方法可以具有返回值且可以抛出异常</p><h3 id="创建线程的三种方式对比"><a href="#创建线程的三种方式对比" class="headerlink" title="创建线程的三种方式对比"></a>创建线程的三种方式对比</h3><p>Runnable与Callable相比不具有返回值无法声明抛出异常，实现方式类似，与Thread不同</p><p>实现Runnable与Callable接口创建多线程的优缺点：</p><ul><li>线程类只是实现了Runnable接口或Callable接口，还可以继承其他类</li><li>多线程共享同一个target对象，适合多个相同线程处理同一份资源，可以将CPU，代码和数据分开，形成清晰的模型，较好体现面向对象思想</li><li>劣势是编程稍复杂，如需访问当前线程，需使用Thread.currentThread()方法</li></ul><p>Thread类创建多线程优缺点：</p><ul><li>编写简单，无须使用Thread.currentThread()方法，直接使用this即可获取当前线程</li><li>劣势是线程类继承了Thread类，无法继承其他父类</li></ul><p>线程启动使用start()方法，永远不要调用线程对象的run()方法。调用start()方法启动线程，系统会把该run()方法作为线程执行体处理，而直接调用线程对象的run()方法，则run()方法立即执行，且返回前其他线程无法并发执行，即线程对象被系统当做普通对象，run()方法当成普通方法，而不是线程执行体。</p><p>如果希望调用子线程的start()方法后立即执行，使用Thread.sleep(1)让当前运行的线程（主线程）睡眠1毫秒</p><h3 id="线程阻塞情况"><a href="#线程阻塞情况" class="headerlink" title="线程阻塞情况"></a>线程阻塞情况</h3><ul><li>线程调用sleep()方法主动放弃所占用的处理器资源</li><li>线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞</li><li>线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有</li><li>线程在等待某个通知(notify)</li><li>程序调用了线程的suspend()方法将该线程挂起（该方法容易导致死锁，避免使用）</li></ul><h3 id="线程状态转换图"><a href="#线程状态转换图" class="headerlink" title="线程状态转换图"></a>线程状态转换图</h3><p><img src="/images/ThreadState.png" alt="ThreadState"></p><p>join()方法</p><p>一个线程调用另一个线程的join()方法，等其执行结束后才会继续向下执行</p><ul><li>join()：等待被join的线程执行完成</li><li>join(long millis)：等待被join的线程时间最长为millis毫秒，过时无论被join线程是否执行完毕，继续向下执行</li></ul><p>后台线程</p><p>所有前台线程都死亡，后台线程自动死亡，JVM的垃圾回收机制是典型的后台线程</p><p>thread.setDaemon(true)方法设置为后台线程，需要在线程start()前执行</p><p>线程优先级设置</p><p>不同操作系统优先级等级不定相同，保证有良好移植性应使用MAX_PRIORITY, MIN_PRIORITY以及NORM_PRIORITY设置优先级</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>本质是加锁-&gt;修改-&gt;释放锁</p><p>同步代码块</p><p>synchronized(obj){          }</p><p>obj是同步监视器，线程开始执行前，先获取同步监视器的锁</p><p>同步方法</p><p>public void synchronized test(){      }</p><p>同步方法的同步监视器是this</p><p>synchronized是隐式定义同步锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stageOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do your work here</span></span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    list1.add(random.nextInt(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">stageTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do your work here</span></span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    list2.add(random.nextInt(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处线程使用的是通一个锁，故stageOne运行时无法访问stageTwo<br>解决方法是使用两把不同锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stageOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">//do your work here</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        list1.add(random.nextInt(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stageTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">//do your work here</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        list2.add(random.nextInt(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DDD(Domain Driven Design) 领域驱动设计，每个类都应该是完备的领域对象</p><h3 id="线程释放同步监视器锁定："><a href="#线程释放同步监视器锁定：" class="headerlink" title="线程释放同步监视器锁定："></a>线程释放同步监视器锁定：</h3><ul><li>当前线程的同步方法，同步代码块执行结束</li><li>当前线程在同步代码块，同步方法中遇到break，return终止了该代码块，方法的继续执行</li><li>当前线程在同步代码块，同步方法中出现了未处理的Error或Exception，导致该代码块，方法异常结束</li><li>当前线程执行同步代码块或同步方法时，程序执行了同步监视器对象的wait()方法，则当前线程暂停，并释放同步监视器</li></ul><p>线程不释放同步监视器锁定：</p><ul><li>线程执行同步代码块或同步方法时，程序调用Thread.sleep()，Thread.yield()方法来暂停当前线程的执行</li><li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起（避免使用suspend()和resume()方法）</li></ul><h3 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h3><p>Lock具有比synchronized方法和synchronized代码块更广泛的锁定操作，且支持多个相关Condition对象，具有显示同步监视器</p><p>常用ReentrantLock 可重入锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>synchronized使用隐式同步监视器，使用wait(), notify(), notifyAll()方法进行线程通信<br>wait(), notify()作用在同步监视器上，例如synchronized(lock)，lock.wait()，lock,notify()</p><p>Lock使用显式同步监视器，使用Condition类保持协调</p><p>Condition类提供了三种类似wait(), notify(), notifyAll()方法</p><ul><li>await(): 类似隐式同步监视器上的wait()方法，导致当前线程等待</li><li>signal(): 类似notify()方法，唤醒在此Lock对象上等待的单个线程（多个等待线程任意唤醒一个），只有当前线程放弃对该Lock对象的锁定后（使用await()方法），才可以执行被唤醒的线程</li><li>signalAll(): 类似notifyAll()方法，唤醒在此Lock对象上的所有线程，只有当前线程放弃对该Lock对象的锁定后（使用await()方法），才可以执行被唤醒的线程</li></ul><p>阻塞式队列控制线程通信</p><p>BlockingQueue，其特征为生产者试图向其中放入元素时，若队列已满，则该线程阻塞；消费者试图从中取出元素时，若队列为空，则该线程阻塞</p><table><thead><tr><th></th><th>抛出异常</th><th>不同返回值</th><th>阻塞线程</th><th>指定超时时长</th></tr></thead><tbody><tr><td>队尾插入元素</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>队头插入元素</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>获取，不删除元素</td><td>element()</td><td>peek()</td><td>无</td><td>无</td></tr></tbody></table><p>其中time是long类型，unit是TimeUnit类型，表示时间的粒度(如时，分，秒，毫秒)</p><p>BlockingQueue与其实现类之间的类图</p><p><img src="/images/BlockingQueue.png" alt="BlockingQueue"></p><h3 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h3><p>使用ThreadGroup表示线程组，可以对一批线程进行分类管理，程序可以直接对线程组进行控制。如果没有显式指定线程组，则属于默认线程组。默认情况下，子线程和创建它的父线程在一个线程组内。</p><p>Thread没有提供set方法改变线程所属线程组，只能在构造器中指定</p><ul><li>Thread(ThreadGroup group, Runnable target)</li><li>Thread(ThreadGroup group, Runnable target, String name)</li><li>Thread(ThreadGroup group, String name)</li></ul><p>ThreadGroup提供两个简单构造器创建实例</p><ul><li>ThreadGroup(String name)</li><li>ThreadGroup(ThreadGroup parent, String name)</li></ul><p>常用方法:</p><ul><li>int activeCount(): 返回线程组中活动线程书目</li><li>interrupt(): 中断线程组中所有线程</li><li>isDaemon(): 判断是否为后台线程组</li><li>setDaemon(boolen daemon): 设置为后台线程组</li><li>setMaxPriority(int pri): 设置线程组最高优先级</li></ul><p>线程执行过程中抛出了一个未处理异常，JVM在结束该线程之前会自动查找是否有对应的Thread,UncaughtExceptionHandler对象，如果找到该处理器对象，会调用该对象的uncaughtException(Thread t, Throwable e)处理异常。</p><p>Thread类提供了两个方法设置异常处理器</p><ul><li>static setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh): 为该线程类的所有线程实例设置默认的异常处理器。</li><li>setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh): 为指定的线程实例设置异常处理器。</li></ul><p>ThreadGroup类实现了Thread.UncaughtExceptionHandler接口，所以每个线程所属的线程组将会作为默认的异常处理器。ThreadGroup中定义了一个void uncaughtException(Thread t, Throwable e)方法，方法可以处理线程组内任意线程抛出的未处理异常。</p><p>线程执行过程中抛出了一个未处理异常，JVM会首先查找该异常对应的异常处理器（set方法设置的），如果找到，则调用该异常处理器处理异常。否则，JVM将会调用该线程所属的线程组对象的uncaughtException()方法来处理异常。</p><ul><li>如果该线程组有父线程组，则调用父线程组的uncaughtException()方法处理该异常</li><li>如果该线程实例所属的线程类有默认的异常处理器（set方法设置的），调用该异常处理器处理异常</li><li>若异常时ThreadDeath的对象，不做处理，否则，打印异常跟踪栈，结束线程</li></ul><p>异常处理器类似Throws，向上传播给上一级调用者，与catch捕获不同</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul><li><p>ExceutorService newCacheThreadPool(): 创建一个具有缓存功能的线程池</p></li><li><p>ExceutorService newFixedThreadPool(int nThreads): 创建一个可重用的，具有固定线程数的线程池</p></li><li><p>ExceutorService newSingleThreadExecutor(): 创建单线程的线程池，等于newFixedThreadPool(1)</p></li><li><p>ScheduledExceutorService newScheduledThreadPool(int corePoolSize): 创建具有指定线程数的线程池，他可以在指定延迟后执行线程任务。线程空闲也会被保存在线程池中</p></li><li><p>ScheduledExceutorService newSingleThreadScheduledExecutor(): 创建单线程线程池，等于newScheduledThreadPool(1)</p></li><li><p>ExceutorService newWorkStealingPool(int parallelism): 创建持有足够线程的线程池来支持给定的并行级别，该方法还会使用多个队列来减少竞争</p></li><li><p>ExceutorService newWorkStealingPool(): 上一个方法的简化版本，根据CPU数设置并行级别</p></li></ul><p>ExceutorService对象代表一个线程池，ScheduledExceutorService是ExceutorService子类，可以在指定延迟后执行线程任务</p><p>ExceutorService 代表尽快执行线程的线程池，提供三种submit()方法</p><ul><li><p>Future&lt;?&gt; submit(Runnable task) : 将一个Runnable对象提交给指定的线程池，线程池将在有空闲线程时执行Runnable对象代表的任务。Future对象代表Runnable任务的返回值，但是run()方法没有返回值，所以Future对象将在run()方法执行结束后返回null。但可以使用Future的isDone(), isCancelled()方法获取Runnable对象的执行状态</p></li><li><p>&lt;T&gt;  Future&lt;T&gt; submit(Runnable task, T result) : 将一个Runnable对象提交给指定的线程池，线程池将在有空闲线程时执行Runnable对象代表的任务。其中result显式指定线程执行结束后的返回值，所以Future对象将在run()方法执行结束后返回result</p></li><li><p>&lt;T&gt;  Future&lt;T&gt; submit(Callanle&lt;T&gt; task) : 将一个Callable对象提交给指定线程池，线程池将在有空闲线程时执行Callable对象代表的任务。其中Future代表Callable对象里Call()方法的返回值</p></li></ul><p>ScheduledExceutorService 代表可在指定延迟后或周期性地执行线程的线程池，提供四种schedule()方法</p><ul><li>ScheduleFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit): 指定callable任务将在delay延迟后执行</li><li>ScheduleFuture&lt;？&gt; schedule(Runnable&lt;V&gt; command, long delay, TimeUnit unit): 指定command任务将在delay延迟后执行</li><li>ScheduleFuture&lt;？&gt; scheduleAtFixedRate(Runnable&lt;V&gt; command, long initialDelay, long period, TimeUnit unit): 指定command任务将在delay延迟后执行，且以设定频率重复执行，即initialDelay后开始执行，依次在initialDelay + period, initialDelay + 2 * period….处重复执行</li><li>ScheduleFuture&lt;？&gt; scheduleWithFixedRate(Runnable&lt;V&gt; command, long initialDelay, long period, TimeUnit unit): 创建并执行一个在给定初始延迟后首次启用的定期操作，随后在每一次执行终止和下一次执行开始之间都存在给定的延迟。如果认为在任一次执行时遇到异常，就会取消后续执行。否则，只能通过程序来显式取消或终止该任务</li></ul><p>线程池执行线程任务的步骤</p><ul><li>调用Executors类的静态工厂方法创建一个ExecutorService对象，该对象代表一个线程池</li><li>创建Runnable或Callable实现类实例，作为线程执行任务</li><li>调用ExecutorService对象的submit()方法提交Runnable或Callable实例</li><li>调用ExecutorServicedioxide的shutdown()方法关闭线程池</li></ul><p>ForkJoinPool 支持将一个任务拆分成多个小任务并行计算，并将多个小任务结果合并成总的计算结果</p><p>常用构造器</p><ul><li>ForkJoinPool(int parallelism): 创建一个包含parallelism个并行线程的ForkJoinPool</li><li>ForkJoinPool(): 以Runtime.availableProcessors()方法的返回值作为parallelism参数来创建ForkJoinPool</li></ul><p>ForkJoinPool通用池</p><ul><li>ForkJoinPool commonPool(): 返回一个通用池，通用池运行状态不受shutdown()或shutdownNow()方法影响</li><li>int getCommonPoolParallelism(): 该方法返回通用池的并行级别</li></ul><p>ForkJoinPool，ForkJoinTask等类的类图</p><p><img src="/images/ForkJoinPool.png" alt="ForkJoinPool"></p><p>ThreadLocal</p><p>ThreadLocal从另一个角度解决多线程的并发访问，将需要并发访问的资源复制多份，每个线程拥有一份资源，故可以将不安全的变量封装进ThreadLocal</p><h3 id="包装线程不安全的集合"><a href="#包装线程不安全的集合" class="headerlink" title="包装线程不安全的集合"></a>包装线程不安全的集合</h3><p>ArrayList, LinkedList, HashSet, TreeSet, HashMap, TreeMap等都是线程不安全的</p><p>Collections提供了类方法将这些集合包装成线程安全的集合</p><ul><li><p>&lt;T&gt;Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c): 返回指定collection对应的线程安全的collection</p></li><li><p>static&lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list): 返回指定List对象对应的线程安全的List对象</p></li><li><p>static&lt;K, V&gt; Map&lt;K, V&gt; synchronizedMap(Map&lt;K, V&gt; m): 返回指定Map对象对应的线程安全的Map对象</p></li><li><p>static&lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s): 返回指定Set对象对应的线程安全的Set对象</p></li><li><p>static&lt;K, V&gt; SortedMap&lt;K, V&gt; synchronizedSortedMap(SortedMap&lt;K, V&gt; m): 返回指定SortedMap对象对应的线程安全的SortedMap对象</p></li><li><p>static&lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(Set&lt;T&gt; s): 返回指定SortedSet对象对应的线程安全的SortedSet对象</p></li></ul><p>线程安全集合类</p><p><img src="/images/SecuritySet.png" alt="SecuritySet"></p><p>线程安全集合分为两类</p><ul><li>以Concurrent开头的集合类，代表了支持并发访问的集合，可以支持多个线程并发写入访问，在并发写入有较好性能，读取时无需加锁</li><li>以CopyOnWrite开头的集合类，采用复制底层Set, List, Map等的方式实现写操作。写入操作需要频繁复制，性能较差，读取也无需加锁，读操作很快，很安全，故适用于例如缓存之类读取操作远大于写入操作的场景</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>最简单情况一个线程具有lock1，请求lock2，另一个线程具有lock2，请求lock1<br>避免死锁，构造方法，使用tryLock()函数，当所有锁都可以获取的时候继续执行，否则释放部分可获取锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">acquireLocks</span><span class="params">(Lock firstLock, Lock secondLock)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// Acquire locks</span></span><br><span class="line">            <span class="keyword">boolean</span> gotFirstLock = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> gotSecondLock = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * tryLock() which will only acquire a lock if it’s available</span></span><br><span class="line"><span class="comment">                 * and not already acquired by another thread and tryLock(long</span></span><br><span class="line"><span class="comment">                 * time,TimeUnit unit), which will try to acquire a lock and, if</span></span><br><span class="line"><span class="comment">                 * it's unavailable wait for the specified timer to expire</span></span><br><span class="line"><span class="comment">                 * before giving up</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                gotFirstLock = firstLock.tryLock();</span><br><span class="line">                gotSecondLock = secondLock.tryLock();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (gotFirstLock &amp;&amp; gotSecondLock) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (gotFirstLock) firstLock.unlock();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (gotSecondLock) secondLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Locks not acquired</span></span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;Java SE 多线程基础整理&lt;/center&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Deepin 20.0 配置Hyperledger Fabric SDK Java环境</title>
    <link href="http://yoursite.com/2020/08/05/HyperledgerFabricSDK/"/>
    <id>http://yoursite.com/2020/08/05/HyperledgerFabricSDK/</id>
    <published>2020-08-05T08:30:23.000Z</published>
    <updated>2020-08-05T11:30:43.211Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Hyperledger-Fabric-SDK-Java"><a href="#Hyperledger-Fabric-SDK-Java" class="headerlink" title="Hyperledger Fabric SDK Java"></a>Hyperledger Fabric SDK Java</h1><p><a href="https://github.com/IBM/blockchain-application-using-fabric-java-sdk" target="_blank" rel="noopener">Hyperledger Fabric SDK Java Github库</a><br>配置Hyperledger Fabric分布式账本解决方案平台，需要安装以下4个组件</p><ul><li><a href="https://www.docker.com/get-started" target="_blank" rel="noopener">Docker</a></li><li><a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">Docker Compose</a></li><li><a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html" target="_blank" rel="noopener">Java</a></li><li><a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">Maven</a></li></ul><h1 id="Deepin-安装Docker"><a href="#Deepin-安装Docker" class="headerlink" title="Deepin 安装Docker"></a>Deepin 安装Docker</h1><p>由于Deepin是基于debian的unstable版本开发，而docker官方源并没有支持debian的unstable版本，故使用docker官方教程安装不成功<br>参考<a href="https://wiki.deepin.org/wiki/Docker" target="_blank" rel="noopener">Deepin社区</a> Docker教程进行安装</p><ol><li><p>旧版本卸载（首次安装跳过）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker.io docker-engine</span><br></pre></td></tr></table></figure></li><li><p>安装密钥管理与下载相关的工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 密钥管理（add-apt-repository ca-certificates 等）与下载（curl 等）相关的工具</span><br><span class="line">sudo apt-get install apt-transport-https ca-certificates curl python-software-properties software-properties-common</span><br></pre></td></tr></table></figure></li><li><p>下载并安装密钥<br>使用国内源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -</span><br><span class="line">// 官方源，能否成功可能需要看运气。</span><br><span class="line">// curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li><li><p>查看密钥是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-key fingerprint 0EBFCD88</span><br></pre></td></tr></table></figure><p> 安装成功后显示</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pub   rsa4096 2017-02-22 [SCEA]</span><br><span class="line">  9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid           [ 未知 ] Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   rsa4096 2017-02-22 [S]</span><br></pre></td></tr></table></figure></li><li><p>在source.list中添加docker-ce软件源（deepin 20.0添加下面这个即可）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/debian stretch stable&quot;</span><br></pre></td></tr></table></figure></li><li><p>更新仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>安装docker-ce</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure></li><li><p>查看版本验证安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure></li></ol><h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><p>这里用pip3安装docker compose，绝对不要用pip，会报错</p><ol><li><p>因为deepin默认版本为Python 2.7，所以先将默认Python版本更换为Python3（deepin 20.0自带python 3）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br></pre></td></tr></table></figure><p> 在bashrc中添加如下语句</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias python=&apos;python3&apos;</span><br></pre></td></tr></table></figure></li><li><p>默认版本切换成功后，安装pip3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python3-pip</span><br></pre></td></tr></table></figure></li><li><p>利用pip3安装docker compose</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install docker-compose</span><br></pre></td></tr></table></figure></li></ol><p><strong>使用pip安装docker-compose的错误</strong></p><ul><li><p>ImportError: No module named ssl_match_hostname<br>  网上博客提供的解决方法是<br>  将python2.7 下backports包整个复制到docker下transport文件夹中</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 路径仅供参考</span><br><span class="line">cp -r /usr/local/lib/python2.7/dist-packages/backports /usr/local/lib/python2.7/dist-packages/docker/transport</span><br></pre></td></tr></table></figure><p>  <strong>注：在deepin 20.0上尝试无效，仍然报错，用pip3安装解决</strong></p></li><li><p>启动时报错：Couldn’t connect to Docker daemon at http+docker://localhost - is it running?<br>  在设置区块链网络时，使用如下指令时报错</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./build.sh</span><br></pre></td></tr></table></figure><p>  权限问题，使用sudo ./build.sh执行</p></li></ul><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p><strong>使用jdk 1.8</strong><br>否则在创建并初始化频道，部署并实例化链代码时，会报非法反射</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: An illegal reflective access operation has occurred</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>这里使用openjdk1.8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openjdk-8-jdk</span><br></pre></td></tr></table></figure><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>可以参考<a href="https://wiki.deepin.org/wiki/Deepin%E4%B8%8Bjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2#MAVEN.E5.AE.89.E8.A3.85" target="_blank" rel="noopener">Deepin社区</a> 进行安装配置<br>下面介绍使用IDEA自带openjdk14.0.2以及maven3进行配置</p><ol><li><p>修改profile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 路径仅供参考</span><br><span class="line"># Maven config</span><br><span class="line">export JAVA_HOME=/home/nozomi/.jdks/openjdk-14.0.2</span><br><span class="line">export MAVEN_HOME=/home/nozomi/idea-IU-202.6397.94/plugins/maven/lib/maven3</span><br><span class="line">export PATH=$&#123;PATH&#125;:$&#123;JAVA_HOME&#125;/bin:$&#123;MAVEN_HOME&#125;/bin</span><br></pre></td></tr></table></figure><p> 保存退出后更新配置</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>配置命令连接符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 路径仅供参考</span><br><span class="line">sudo update-alternatives --install /usr/bin/mvn mvn /home/nozomi/idea-IU-202.6397.94/plugins/maven/lib/maven3/bin/mvn 1000</span><br></pre></td></tr></table></figure></li></ol><p><strong>安装配置Maven的错误</strong><br>提示mvn无权限，使用sudo后提示mvn未找到命令<br>给所有用户添加权限解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 路径仅供参考</span><br><span class="line">chmod a+x /home/nozomi/idea-IU-202.6397.94/plugins/maven/lib/maven3/bin/mvn</span><br></pre></td></tr></table></figure><h1 id="配置执行Hyperledger-Fabric-SDK遇到的错误"><a href="#配置执行Hyperledger-Fabric-SDK遇到的错误" class="headerlink" title="配置执行Hyperledger Fabric SDK遇到的错误"></a>配置执行Hyperledger Fabric SDK遇到的错误</h1><ul><li><p>./build.sh<br>  在docker-compose错误中解决，使用sudo ./build.sh</p></li><li><p>部署实例化代码时</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apr 23, 2018 10:25:22 AM org.example.client.ChannelClient instantiateChainCode</span><br><span class="line">  INFO: Instantiating Chaincode ID fabcar on channel mychannel</span><br></pre></td></tr></table></figure><p>  执行到此处卡住不动，结束执行，重新执行解决，原因未知</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;Deepin配置Hyperledger Fabric SDK Java&lt;/center&gt;&lt;center&gt;Deepin配置Docker, Docker Compose, Maven&lt;center&gt;踩坑&lt;/center&gt;
    
    </summary>
    
    
      <category term="Blockchain" scheme="http://yoursite.com/categories/Blockchain/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Blockchain" scheme="http://yoursite.com/tags/Blockchain/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://yoursite.com/2020/04/16/ComputerNetworking/"/>
    <id>http://yoursite.com/2020/04/16/ComputerNetworking/</id>
    <published>2020-04-16T08:02:31.000Z</published>
    <updated>2020-04-16T08:32:17.222Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="高级计算机网络"><a href="#高级计算机网络" class="headerlink" title="高级计算机网络"></a>高级计算机网络</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h3><p><strong>电路交换（Circuit Switching）</strong></p><p>在通信双方建立一条独占物理通路，分为频分复用（FDM: Frequency Division Multiplexing）以及时分复用（TDM: Time Division Multiplexing），均为预先分配带宽后使用的过程，FDM将带宽按照频率进行划分，TDM将带宽按照时隙进行划分</p><p>优点：</p><ol><li>由于通信线路为通信双方用户专用，数据直达，所以传输数据的时延非常小</li><li>通信双方之间的物理通路一旦建立，双方可以随时通信，实时性强</li><li>双方通信时按发送顺序传送数据，不存在失序问题</li><li>电路交换既适用于传输模拟信号，也适用于传输数字信号</li><li>电路交换的交换设备及控制均较简单</li></ol><p>缺点：</p><ol><li>电路交换的平均连接建立时间对计算机通信来说嫌长</li><li>电路交换建立连接后，物理通路被通信双方独占，即使通信线路空闲，也不能供其他用户使用，因而信道利用率低</li><li>电路交换时，数据直达，不同类型，不同规格，不同速率的终端很难相互进行通信，也难以在通信过程中进行差错控制</li></ol><p><strong>分组交换（Packet Switching）</strong></p><p>通信过程中，通信双方以分组为单位，使用储存-转发机制实现数据交互，将一个长报文分割为多个较短的分组后逐个发送</p><p>路由器接收到分组后，在链路空闲时将其发送，接收到的分组存储在等待队列中，等待队列满了之后，后续分组将会丢弃</p><p>优点：</p><ol><li>分组交换不需要为通信双方预先建立一条专用的通信线路，不存在连接建立时延，用户可随时发送分组</li><li>由于采用存储转发方式，加之交换结点具有路径选择，当某条传输线路故障时可选择其他传输线路，提高了传输的可靠性</li><li>通信双方不是固定的占有一条通信线路，而是在不同的时间一段一段地部分占有这条物理通路，因而大大提高了通信线路的利用率</li><li>加速了数据在网络中的传输。因为分组是逐个传输，可以使后一个分组的存储操作与前一个分组的转发操作并行，这种流水线式传输方式减少了传输时间</li><li>分组长度固定，相应的缓冲区的大小也固定，所以简化了交换结点中存储器的管理</li><li>分组较短，出错几率减少，每次重发的数据量也减少，不仅提高了可靠性，也减少了时延</li></ol><p>缺点：</p><ol><li>由于数据进入交换结点后要历经存储转发这一过程，从而引起转发时延（包括接受分组，检验正确性，排队，发送时间等），而且网络的通信量越大造成的时延就越大，实时性较差</li><li>分组交换只适用于数字信号</li><li>分组交换可能出现失序，丢失或重复分组，分组到达目的结点时要对分组按编号进行排序等工作，增加了麻烦</li></ol><h3 id="网络性能指标"><a href="#网络性能指标" class="headerlink" title="网络性能指标"></a>网络性能指标</h3><ul><li><p>时延</p><p>节点时延=处理时延+排队时延+传输时延+传播时延</p><ul><li><p>处理时延</p><p>包括：分析分组的首部、从分组中提取数据部分、进行差错或查找适当的路由</p></li><li><p>排队时延</p><p>分组在所排队列中等待被发送到出链路的时间</p><p>可用流量强度衡量</p></li><li><p>传输时延</p><p>路由器收到数据包后向下一跳发送数据包，数据包完整发出去的时延（即数据包从路由器到链路上的时延），与数据包的长度（比特）与带宽有关</p><p>传输时延=数据包长度/带宽</p><p>容易与传播时延混淆</p></li><li><p>传播时延</p><p>数据包从一个路由器到另一个路由器，走过物理距离需要的时间，与物理距离以及数据在链路上传播速度有关</p></li></ul></li><li><p>丢包</p><p>路由器缓存满了之后，会丢弃部分数据，产生丢包</p><p>丢包率=丢弃数据包的数量/总数据包的量</p></li><li><p>吞吐量</p><p>考察数据接收端的传输数据能力的量</p><p>平均吞吐量=T时间内收到的数据量/T时间</p><p>瞬时吞吐量=$\lim\limits_{T\rightarrow 0} \dfrac{T时间内收到的数据量}{T时间}$</p><p>一段链路的平均吞吐量由小带宽部分主要决定</p></li></ul><p>注$kb/s = 10^3b/s\quad Mb/s=10^6b/s$</p><p>$KB=2^{10}B\quad MB=2^{20}B$</p><p><strong>宽带和窄带</strong></p><ul><li>不是由传输速率区分，传输速率恒定</li><li>由数据包传输间隔区分，宽带传输间隔很小，窄带传输间隔很大</li></ul><p>数据传输都是串行比特流，没有并行传输</p><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><p>计算机网络的体系结构是计算机网络的各层及其协议的集合</p><p>体系结构就是这个计算机网络及其部件所应完成的功能的精确定义</p><p>实现是遵循这种体系结构的前提下用何种硬件或软件完成这些功能的问题</p><p><strong>协议栈</strong></p><ul><li><p>应用层（第五层）：提供网络应用之间的接口（报文）</p><p>FTP, SMTP, HTTP, DNS, TELNET…</p><p>为用户提供接口</p></li><li><p>传输层（第四层）：进程与进程间的通信（报文段）</p><p>TCP, UDP</p><p>拥塞控制，流量控制，差错控制</p></li><li><p>网络层（第三层）：主机与主机之间通信，依赖于相邻节点间数据链路层提供的服务（数据包）</p><p>IP, 路由协议…</p><p>路由转发</p></li><li><p>数据链路层（第二层）：相邻节点间的数据传输，依赖于物理层提供比特流服务（帧）</p><p>ARPANET, SATNET, LAN, Packet radio</p><p>误差检测，控制</p></li><li><p>物理层（第一层）：传输比特流（比特）</p></li></ul><p><strong>ISO/OSI七层模型</strong></p><p>应用层→表示层→会话层→传输层→网络层→数据链路层→物理层</p><p>TCP/IP模型不包含表示层与会话层，对于五层架构更简单</p><p>应用层→传输层→因特网层→端到网络层</p><p>计算机之间的通信实质是进程间的通信</p><p>应用把数据发到应用层，应用层在数据前加上首部形成报文并将其打包传给传输层</p><p>传输层在报文的前加上首部形成报文段并将其打包传给网络层</p><p>网络层在报文段前加上首部形成数据报并将其打包传给数据链路层</p><p>数据链路层在数据报前加上首部并在其后加上尾部形成帧之后打包传给物理层</p><p>物理层将帧通过比特流传到接收端，接收端反向拆包获取数据</p><p>交换机两层设备（物理层，数据链路层）</p><p>路由器三层设备（物理层，数据链路层，网络层）</p><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>体系架构：</p><ul><li><p>客户端-服务器端（Client-Server）</p><p>服务器端：永远在线，恒定不变（IP地址），集群，数据中心</p><p>客户端：一般只与服务器端通信，间歇性连接，IP地址可能动态改变</p></li><li><p>节点-节点（P2P）</p><p>节点既可以是客户端也可以是服务器端，可扩展性好，节点可随时加入随时离开</p></li></ul><p>进程通信</p><p>同主机进程通信由操作系统决定</p><p>发起为客户端进程，接收为服务器端进程，P2P也适用</p><p>套接字：进程到下一层之间的协议，是一个接口</p><p>进程寻址：主机IP地址+端口号唯一表示网络上的进程</p><p>传输层为应用层提供的协议服务：可靠的TCP，不可靠的UDP</p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP：基于TCP，无状态</p><p>连接方式分为：持续性和非持续性</p><p>非持续性HTTP：每次传输一个对象，用响应时间衡量</p><p>往返时间RTT：客户端到服务器端，一去一回的时间</p><p>响应时间：发起通信到页面完整下载所用的时间</p><p>HTTP报文格式，分为请求，响应两个类型</p><p>请求格式为：</p><ul><li><p>首部</p><p>HTTP版本，主机名称，浏览器，接收语言，连接类型</p></li><li><p>数据</p></li></ul><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><p>Cookie缓存保存历史信息</p><p>HTTP报文设定缓存ID，服务器把ID和历史信息保存</p><p>用途：</p><ul><li>认证</li><li>购物车功能</li><li>推荐</li><li>用户历史状态信息</li></ul><p>web缓存（代理服务器）</p><p>客户端发送请求，若代理服务器有缓存，直接返回给客户端，没有再向目标服务器发送请求</p><p>优点：减少响应时间</p><p>代理服务器：有条件的GET</p><p>代理服务器向原始服务器发送GET请求，有更新就发送更新后的页面，无更新返回304表示无更新</p><p>客户端向代理服务器发送页面请求，代理服务器向原始服务器发送简单请求（查询是否页面版本一致）</p><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p>文件传输协议</p><p>CS结构，基于TCP</p><p>需要建立两条TCP连接</p><ul><li><p>FTP客户端登录FTP服务器，端口号21，传输控制的命令信息（账号，密码，浏览目录等）</p></li><li><p>文件上传下载，端口号20，传输文件数据</p><p>每次传一个，传完之后关闭，非持续</p></li></ul><p>这种传输方式成为带外传输</p><h3 id="E-mail"><a href="#E-mail" class="headerlink" title="E-mail"></a>E-mail</h3><p>mail servers</p><ul><li>mailbox 接收邮件队列</li><li>message queue 发送邮件队列</li><li>SMTP协议</li></ul><p>SMTP</p><p>使用TCP的CS架构，使用25号端口</p><p>HTTP是拉的方式，SMTP是推的方式</p><p>MIME扩展SMTP</p><p>发送用户SMTP-&gt;邮件发送服务器SMTP-&gt;邮件接收服务器POP,IMAP-&gt;接收用户</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>主机名到IP地址的转换</p><p>根域名服务器（13个）-&gt;顶级域名服务器-&gt;权威域名服务器-&gt;本地域名服务器</p><p>用户-&gt;本地域名服务器-&gt;根域名服务器-&gt;本地域名服务器-&gt;顶级域名服务器-&gt;本地域名服务器-&gt;权威域名服务器-&gt;本地域名服务器-&gt;用户</p><p>resource records （RR（name, value, type, ttl））</p><h3 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h3><p>资源共享，节点之间直接通信，没有中心控制</p><p>CS架构数据源是服务器，P2P中没有集中式数据源，数据服务由不同节点提供</p><p>资源高效使用，可扩展性，可靠性，易于管理，匿名，动态性</p><p>使用位置：文件共享，多人游戏，合作应用（QQ），分布式计算，自主网络</p><p>问题：分散化管理复杂，扩展规模，匿名，公平性，版权问题</p><h3 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h3><p>通过解析torrent获取tracker的IP地址和数据</p><p>torrent包含源数据和tracker信息</p><p>Chunk选择</p><ul><li>优先级策略</li><li>稀缺优先，好处，使文件在网络中拷贝数量增加</li><li>随机优先片</li></ul><p>tit-for-tat</p><p>每十秒做一个排行，选择前四个节点传输数据</p><p>避免自私节点</p><p>choking</p><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>应用程序数据到下层传输层的接口</p><p>TCP或UDP</p><p>同一个welcomeSocket创建的端口号相同</p><p>TCP创建的字节流</p><p>UDP不需要服务器创建新的socket，发数据发送IP地址和端口号</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>端到端进程间通信</p><h3 id="多路复用、多路分解"><a href="#多路复用、多路分解" class="headerlink" title="多路复用、多路分解"></a>多路复用、多路分解</h3><p>多路复用：源主机中从不同socket获取数据块，每一个数据块封装上首部信息，生成报文段传递到网络层</p><p>多路分解：传输层的报文段包含多个字段，接收端传输层检查字段，标识出接收的socket，然后将报文段交付到对应socket</p><p>UDP多路分解</p><p>多个报文段源IP地址和端口号不同，只要目的端IP地址端口号相同，便交付到同一个socket进程</p><p>TCP多路分解</p><p>根据源IP和端口号以及目的端IP地址和端口号定向到不同进程</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>user datagram protocol</p><p>无连接（无建立连接延迟），不需要保存连接状态信息（空间，计算资源小），首部开销小，没有流量，拥塞控制（发包速率高）</p><p>UDP 报文段首部</p><p>源端口号（16bit），目的端口号（16bit），报文段长度（16bit），校验和（16bit）</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>rdt：reliable data translate</p><p><strong>rdt1.0</strong> 传输功能就是 发送方发送数据，接收方接受数据。</p><p><strong>rdt2.0</strong> 1.错误检验 2.接收者反馈接受信息（ACK,NAK）3.重传机制</p><p><strong>rdt2.1</strong> 在rdt2.0的基础之上，发送方在打包数据包时添加了0或者1编号，同样ACK,NAK字段上也添加了0，1字段，表示0.1号字段的确认或者否定</p><p><strong>rdt2.2</strong> 在rdt2.1上的基础之上做了小小的改善，摒弃了NAK，只需采用ACK</p><p><strong>rdt3.0</strong> 在rdt2.2的基础之上处理了数据包丢失的情况，增加了计时器的机制，如果在RTT时间段内，发送方没有接收到反馈信息，那么发送方默认数据包已经丢失了，会自动重传。</p><p><strong>流水线协议</strong></p><p>回退N：累计确认，一个计时器</p><p>乱序会直接丢弃</p><p><img src="/images/ComputerNetworking/image-20200316210332125.png" alt="image-20200316210332125"></p><p>选择重传：单独确认，每个数据包都有一个计时器</p><p>乱序会缓存</p><p><img src="/images/ComputerNetworking/image-20200316211921044.png" alt="image-20200316211921044"></p><p><strong>TCP特点</strong></p><p>1） 点到点，一对一，一对多用UDP</p><p>2） 数据传输格式是按序的字节流，可靠</p><p>3） 流水线协议，数据传输能力跟滑动窗口大小有关</p><p>4） 发送端与接收端都有缓存</p><p>5） 协议是全双工，均能收发数据</p><p>6） 3次握手协议</p><p>7） 流量控制</p><p><img src="/images/ComputerNetworking/image-20200323090422936.png" alt="image-20200323090422936"></p><p><img src="/images/ComputerNetworking/image-20200323125211293.png" alt="image-20200323125211293"></p><p>TCP 序列号Seq和确认号ACK</p><p>A -&gt; B   Seq = m，ACK = n，data = “”(dataLength = k)</p><p>B -&gt; A   Seq = n，ACK = m+k，data = “”(dataLength = k)</p><p>A -&gt; B   Seq = m+k，ACK = n+k</p><p>TCP计时器超时</p><p><img src="/images/ComputerNetworking/image-20200323131315061.png" alt="image-20200323131315061"></p><p>快速重传避免计时器等待时间过长</p><p><img src="/images/ComputerNetworking/image-20200323142519991.png" alt="image-20200323142519991"></p><p><strong>流量控制</strong></p><p>调整发送端发包速率来避免接收端缓存溢出</p><p>TCP报文中，Receive window存储rwnd，来调节发送端窗口大小不大于rwnd，接收端在ACK报文中包含此数据</p><p><img src="/images/ComputerNetworking/image-20200328100215311.png" alt="image-20200328100215311"></p><p>第三次握手可以携带数据，前两次不可，且第三次不带序列号</p><p><img src="/images/ComputerNetworking/image-20200328100505068.png" alt="image-20200328100505068"></p><p>四次挥手关闭连接</p><p>半关闭为一方发起关闭请求，一方还未发起，只能单向发送数据</p><p><strong>拥塞控制</strong></p><p>与流量控制不同的是控制中间路由器不会缓存溢出</p><p>通过拥塞控制与流量控制，TCP发包速率取两个限制下的滑动窗口最小值</p><p>发包速率$\approx \dfrac{cwnd}{RTT}  \quad bytes/sec$</p><ul><li><p>加性增乘性减</p><p>线性增加，减小/2,</p></li><li><p>TCP慢启动</p><p>每收到一次ACK增加一个MSS</p></li></ul><p>​        在经过一次丢包或者定时器超时后，阈值为这个速率一般，从零开始进行指数增长，到达阈值后进行线性增长（拥塞避免）  </p><p>​       3次冗余ACK进行快速重传，窗口减半后继续线性增长（快速恢复）</p><p>​       3次定时器超时，从新慢启动</p><p>​    <img src="/images/ComputerNetworking/image-20200328164510777.png" alt="image-20200328164510777"></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>实现主机与主机间通信，核心是转发与路由，目的是获取路径</p><p><img src="/images/ComputerNetworking/image-20200330172613364.png" alt="image-20200330172613364"></p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>交换单元</p><ul><li>共享内存方式</li><li>总线型</li></ul><p>输出端口队列，会产生延迟</p><h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><p>点分十进制，a,b,c,d/x</p><p>主机地址全0表示网段，全1表示广播段</p><ul><li><p>A类IP</p><p>0.0.0.0/8~127.255.255.255/8</p></li><li><p>B类IP</p><p>128.0.0.0/16~191.255.255.255/16</p></li><li><p>C类IP</p><p>192.0.0.0/24~223.255.255.255/24</p></li><li><p>D类IP</p><p>224.0.0.0~239.255.255.255</p></li></ul><ul><li><p>E类IP</p><p>240.0.0.0~255.255.255.255</p></li></ul><p>其中A,B,C三类可以分配给主机使用</p><p>D类用来广播，E类用来预留</p><p>子网划分</p><p><img src="/images/ComputerNetworking/image-20200416141910012.png" alt="image-20200416141910012"></p><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>新进主机IP地址分配步骤</p><ul><li>主机广播DHCP discover信息</li><li>DHCP服务器返回DHCP offer信息</li><li>主机向DHCP服务器请求DHCP request信息</li><li>DHCP服务器返回DHCP ack信息</li></ul><p><img src="/images/ComputerNetworking/image-20200416145609521.png" alt="image-20200416145609521"></p><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>解决IPv4地址不足的问题</p><p>在路由器将内网IP替换成路由器面向外网IP以及端口，NAT转发表存储内外网IP端口号的映射关系</p><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><ul><li>把IP地址长度增加到16字节</li><li>简化IP分组首部格式</li><li>增强了进一步扩展支持</li><li>增强了对QoS的支持</li><li>增强了对安全的支持</li><li>增强了对Anycast通信方式的支持</li></ul><p><img src="/images/ComputerNetworking/image-20200416152331339.png" alt="image-20200416152331339"></p><ul><li><p>版本：总是6</p></li><li><p>流量类别：区分不同IPv6数据报的类别或优先级</p></li><li><p>流标号：“流”是互联网上从特定源点到特定终点的一系列数据报，所有属于同一个流的数据报都具有同样的流标号</p></li><li><p>有效载荷长度：指明IPv6数据报除基本首部以外的字节数（所有扩展首部都算在有效载荷之内），最大值为64KB</p></li><li><p>下一个首部：相当于IPv4的协议字段或可选字段。即TCP/UDP首部</p></li><li><p>条数限制：源站在数据报发出时设定跳数。路由器转发一次字段-1。当条数限制为0时，将此数据报丢弃</p></li></ul><p>扩展首部</p><p>IPv6把原IPv4首部中选项功能都放在扩展首部中，并将扩展首部留给路径两端的源站和目的站主机处理</p><p>除了逐跳选项扩展首部外，数据报途中经过的路由器都不处理这些扩展首部，这样大大提高了路由器的处理效率</p><ul><li>逐跳选项</li><li>路由选择</li><li>分片</li><li>鉴别</li><li>封装安全有效载荷</li><li>目的站选项</li></ul><p><img src="/images/ComputerNetworking/image-20200416154020193.png" alt="image-20200416154020193"></p><p>IPv6地址空间</p><p>IPv6数据报的目的地址可以是：单播，组播，任播</p><p>任播：目的站是一组计算机，但数据报在交付时只交付其中一个，通常是距离最近的一个</p><p>IPv4向IPv6转变方法</p><ul><li>Dual IP Layer（又称Dual Stack，双栈协议）：在主机和路由器上同时实现IPv4和IPv6协议</li><li>Tunneling（隧道技术）：把IPv6分组封装在IPv4分组中传送</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;计算机网络相关知识点&lt;/center&gt;
    
    </summary>
    
    
      <category term="Course" scheme="http://yoursite.com/categories/Course/"/>
    
    
      <category term="Course" scheme="http://yoursite.com/tags/Course/"/>
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Java正则表达式</title>
    <link href="http://yoursite.com/2020/04/12/RegularExpression/"/>
    <id>http://yoursite.com/2020/04/12/RegularExpression/</id>
    <published>2020-04-12T10:42:33.000Z</published>
    <updated>2020-08-05T11:37:57.534Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><style>    th{text-align: center}</style><h1 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h1><p>Java正则表达式的典型使用为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern p = Pattern.compile(<span class="string">"a*b"</span>);</span><br><span class="line">Matcher m = p.matcher(<span class="string">"aaaaab"</span>);</span><br><span class="line"><span class="keyword">boolean</span> b = m.matches();</span><br></pre></td></tr></table></figure><p><strong>Pattern</strong>类是不可变类，可供多个并发线程使用<br>常用方法有：</p><table><thead><tr><th align="center">修饰符或类型</th><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">static Pattern</td><td align="center">compile​(String regex)</td><td align="center">将正则表达式字符串编译为Pattern对象</td></tr><tr><td align="center">Matcher</td><td align="center">matcher​(CharSequence input)</td><td align="center">创建一个匹配器根据编译好的Pattern对象来匹配给定的输入（<strong>注1</strong>）</td></tr><tr><td align="center">static boolean</td><td align="center">matches​(String regex, CharSequence input)</td><td align="center">编译给定的正则表达式，并将其与输入的字符序列匹配</td></tr></tbody></table><p><strong>注1：</strong>CharSequence是一个接口，代表一个字符序列，其中CharBuffer，String，StringBuffer，StringBuilder都是其实现类</p><p><strong>Matcher</strong>类利用Pattern来对字符序列进行匹配操作<br>常用方法有：</p><table><thead><tr><th align="center">修饰符或类型</th><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">boolean</td><td align="center">find()</td><td align="center">尝试查找与Pattern匹配的输入序列的下一个子序列</td></tr><tr><td align="center">boolean</td><td align="center">lookingAt()</td><td align="center">返回目标字符串前面部分与Pattern是否匹配</td></tr><tr><td align="center">boolean</td><td align="center">matches()</td><td align="center">返回整个目标字符串与Pattern是否匹配</td></tr><tr><td align="center">String</td><td align="center">group()</td><td align="center">返回上一个与Pattern匹配的子串</td></tr><tr><td align="center">int</td><td align="center">start()</td><td align="center">返回上一个与Pattern匹配的子串在目标字符串中的开始位置</td></tr><tr><td align="center">int</td><td align="center">end()</td><td align="center">返回上一个与Pattern匹配的子串在目标字符串中的结束位置</td></tr><tr><td align="center">Matcher</td><td align="center">reset()</td><td align="center">重置匹配器</td></tr></tbody></table><h1 id="字符规则"><a href="#字符规则" class="headerlink" title="字符规则"></a>字符规则</h1><h2 id="合法字符"><a href="#合法字符" class="headerlink" title="合法字符"></a>合法字符</h2><table><thead><tr><th align="center">合法字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">字符x（任何合法字符）</td></tr><tr><td align="center">\0mnn</td><td align="center">八进制数0mnn所表示的字符</td></tr><tr><td align="center">\xhh</td><td align="center">十六进制值0xhh所表示的字符</td></tr><tr><td align="center">\uhh</td><td align="center">十六进制值0xhh所表示的Unicode字符</td></tr><tr><td align="center">\N{name}</td><td align="center">Unicode字符名称为”name”的字符</td></tr><tr><td align="center">\t</td><td align="center">制表符(‘\u0009’)</td></tr><tr><td align="center">\n</td><td align="center">换行符(‘\u000A’)</td></tr><tr><td align="center">\r</td><td align="center">回车符(‘\u000D’)</td></tr><tr><td align="center">\f</td><td align="center">换页字符(‘\u000C’)</td></tr><tr><td align="center">\a</td><td align="center">警报（bell）字符(‘\u0007’)</td></tr><tr><td align="center">\e</td><td align="center">Escape字符(‘\u001B’)</td></tr><tr><td align="center">\cx</td><td align="center">x对应的控制符，x必须为A~Z或者a~z（\cV匹配Ctrl+V）</td></tr></tbody></table><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><table><thead><tr><th align="center">特殊字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">$</td><td align="center">匹配一行结尾（<strong>注2</strong>）</td></tr><tr><td align="center">^</td><td align="center">匹配一行开头</td></tr><tr><td align="center">()</td><td align="center">标记子表达式开始和结束位置</td></tr><tr><td align="center">[]</td><td align="center">用于确定中括号表达式的出现频度</td></tr><tr><td align="center">{}</td><td align="center">用于标记前面子表达式的出现频度</td></tr><tr><td align="center">*</td><td align="center">指定前面子表达式可以出现零次或多次</td></tr><tr><td align="center">+</td><td align="center">指定前面子表达式可以出现一次或多次</td></tr><tr><td align="center">?</td><td align="center">指定前面子表达式可以出现零次或一次</td></tr><tr><td align="center">.</td><td align="center">匹配<strong>除了换行符\n</strong>以外的任何单字符</td></tr><tr><td align="center">\</td><td align="center">转义下一个字符，或指定八进制，十六进制字符</td></tr><tr><td align="center">|</td><td align="center">指定两项之间任选一项</td></tr></tbody></table><p><strong>注2：</strong>若要匹配字符本身，使用转义字符\，例如<code>\*</code>匹配<code>*</code>，而在Java字符串中，反斜杠本身需要编译，所以实际编程中需要<code>\\*</code>来匹配<code>*</code></p><h2 id="预定义字符"><a href="#预定义字符" class="headerlink" title="预定义字符"></a>预定义字符</h2><table><thead><tr><th align="center">预定义字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">.</td><td align="center">可以匹配任何字符</td></tr><tr><td align="center">\d</td><td align="center">匹配0~9的所有数字</td></tr><tr><td align="center">\D</td><td align="center">匹配非数字</td></tr><tr><td align="center">\s</td><td align="center">匹配所有的空白字符，包括空格、制表符、回车符、换页符、换行符等</td></tr><tr><td align="center">\S</td><td align="center">匹配所有的非空白字符</td></tr><tr><td align="center">\w</td><td align="center">匹配所有的单词字符，包括0~9所有数字，26个英文字母和下划线(_)</td></tr><tr><td align="center">\W</td><td align="center">匹配所有的非单词字符</td></tr></tbody></table><h2 id="方括号表达式"><a href="#方括号表达式" class="headerlink" title="方括号表达式"></a>方括号表达式</h2><table><thead><tr><th align="center">方括号表达式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">表示枚举</td><td align="center">[abc]表示a,b,c中任意一个字符</td></tr><tr><td align="center">表示范围</td><td align="center">[a-z]表示a~z范围内任意字符（<strong>注3</strong>）</td></tr><tr><td align="center">表示求否</td><td align="center">[^abc]表示非a,b,c的任意字符</td></tr><tr><td align="center">表示与运算</td><td align="center">[b-z&amp;&amp;[abc]]表示b~z与a，b，c的交集，即为b,c</td></tr><tr><td align="center">表示并运算</td><td align="center">与枚举类似[abc[bcd]]=[abcd]</td></tr></tbody></table><p><strong>注3：</strong>范围可以与枚举结合使用，如[a-ce-f]=[abcef]，同时可以利用此表达式匹配Unicode的中文字符</p><h2 id="边界匹配符"><a href="#边界匹配符" class="headerlink" title="边界匹配符"></a>边界匹配符</h2><table><thead><tr><th align="center">边界匹配符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">$</td><td align="center">行的结尾</td></tr><tr><td align="center">^</td><td align="center">行的开头</td></tr><tr><td align="center">\b</td><td align="center">单词的边界</td></tr><tr><td align="center">\B</td><td align="center">非单词的结尾</td></tr><tr><td align="center">\A</td><td align="center">输入的开头</td></tr><tr><td align="center">\G</td><td align="center">前一个匹配的结尾</td></tr><tr><td align="center">\Z</td><td align="center">输入的结尾，仅用于最后的结束符</td></tr><tr><td align="center">\z</td><td align="center">输入的结尾</td></tr></tbody></table><h2 id="数量表示符"><a href="#数量表示符" class="headerlink" title="数量表示符"></a>数量表示符</h2><p><strong>数量表示符模式</strong></p><ul><li>贪婪模式（Greedy）：数量标识符默认采用贪婪模式。贪婪模式会一直匹配下去，直到无法匹配为止。</li><li>勉强模式（Reluctant）：用<code>?</code>后缀表示，只会匹配最少的字符。也称为最小匹配模式</li><li>占有模式（Possessive）：用<code>+</code>后缀表示</li></ul><table><thead><tr><th align="center">贪婪模式</th><th align="center">勉强模式</th><th align="center">占用模式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">X?</td><td align="center">X??</td><td align="center">X?+</td><td align="center">X表达式出现零次或一次</td></tr><tr><td align="center">X*</td><td align="center">X*?</td><td align="center">X*+</td><td align="center">X表达式出现零次或多次</td></tr><tr><td align="center">X+?</td><td align="center">X+?</td><td align="center">X++</td><td align="center">X表达式出现一次或多次</td></tr><tr><td align="center">X{n}</td><td align="center">X{n}?</td><td align="center">X{n}+</td><td align="center">X表达式出现n次</td></tr><tr><td align="center">X{n,}</td><td align="center">X{n,}?</td><td align="center">X{n,}+</td><td align="center">X表达式至少出现n次</td></tr><tr><td align="center">X{n,m}</td><td align="center">X{n,m}?</td><td align="center">X{n,m}+</td><td align="center">X表达式至少出现n次，最多出现m次</td></tr></tbody></table><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配4~16单词字符@2~12单词字符.以com、org、cn、net其中一个结尾的邮箱账号</span></span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"\\w&#123;4,16&#125;@\\w&#123;2,12&#125;\\.(com|org|cn|net)"</span>);</span><br><span class="line">Matcher m = p.matcher(<span class="string">"814161593@qq.com"</span>);</span><br><span class="line"><span class="keyword">boolean</span> b = m.matches(); <span class="comment">//return true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;正则表达式字符作用相关整理&lt;/center&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://yoursite.com/2020/01/08/Git/"/>
    <id>http://yoursite.com/2020/01/08/Git/</id>
    <published>2020-01-08T12:38:21.000Z</published>
    <updated>2020-01-08T13:24:03.712Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>集中式版本控制系统：CVS, VSS, SVN, ClearCase<br>分布式版本控制系统：Mercurial，Bazaar，BitKeeper，Git</p><p>Git是一款开源的分布式版本控制系统(Distributed Version ControlSystem) ， 诞生于2002年， 由Linux之父Linus Torvalds带领Linux开源社区开发完成。 初衷是用其管理Linux内核的庞大的开源代码</p><p>Git的设计理念包括以下几点：</p><ul><li>速度快</li><li>设计简单</li><li>强力支持非线性开发， 允许上千分支并行开发</li><li>完全的分布式</li><li>有能力高效管理类似Linux内核一样的超大规模项目（速度和数据量）</li></ul><p>Git对比SVN的优势</p><ul><li>版本库安全性高<ul><li>Git<ul><li>分布式系统，每个用户相当于一个备份</li><li>通过SHA1哈希保证数据的完整性， 防止恶意篡改</li></ul></li><li>SVN<ul><li>集中式存在单点故障的风险</li><li>服务器端历史数据被篡改时， 客户端难以发现</li></ul></li></ul></li><li>分支功能强大<ul><li>Git<ul><li>便于查询和追溯分支间的提交历史</li><li>支持双向合并</li></ul></li><li>SVN<ul><li>分支不支持提交隔离</li><li>一次提交可同时更改主线和分支的内容， 无法查询和追溯分支间的提交历史</li></ul></li></ul></li><li>更灵活的发布控制<ul><li>Git<ul><li>设置只有发布管理员才有权限推送的版本库或者分支， 用于稳定发布版本的维护</li><li>设置只有项目经理、 模块管理员才有权推送的版本库或者分支， 用于整合测试        </li></ul></li></ul></li><li>隔离开发、 提交审核<ul><li>Git<ul><li>支持团队成员自建分支和版本库</li><li>通过合并请求或从成员个人版本库、 分支获取提交， 从提交说明、代码规范等方面对提交逐一审核        </li></ul></li></ul></li><li>对合并更好的支持： 更少的冲突和更好的解决冲突<ul><li>Git<ul><li>基于DAG（有向非环图） 的设计比SVN的线性提交提供更好的合并追踪， 避免不必要的冲突， 提高工作效率</li><li>基于对内容的追踪而非对文件名追踪， 所以遇到一方或双方对文件名更改时， Git能够很好进行自动合并或提供工具辅助合并。 而SVN遇到同样问题时会产生树冲突， 解决起来很麻烦       </li></ul></li></ul></li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>工作拷贝（工作目录） ： 用于存放产品开发数据本地工作目录。</li><li>索引（Index） ： 用于存放待提交数据的缓存区。</li><li>本地库： 远端库的一个完整的拷贝， 包括所有文件的修改记录， 分支等。</li><li>远端库： 本地库clone来源。</li><li>中心库： 远端库的一种， 公司级存放某个项目所有产品数据的仓库。</li><li>快照（snapshot） ： 版本库某个时间点所有文件集合。</li><li>全球版本号（commitID） ： Git库的版本号是通过SHA-1算法根据库中的所有内容计算出一个40位的哈希值， 这个哈希值是全球唯一的， 基本只要前六位就可以唯一标识了。</li></ul><p><strong>文件状态：</strong></p><ul><li>Untracked files： 未被跟踪的文件， 一般指新添加的文件</li><li>Change not staged for commit： 已修改的文件， 包括modified和deleted状态</li><li>Change to be commit： 已缓冲的文件， 即已add的文件， 包括modified、 deleted和new file状态</li><li>Noting to commit： 已提交的文件， 即已commit的文件</li></ul><p><strong>操作模式：</strong><br><img src="/images/GitOperation.png" alt="GitOperation"></p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><ul><li>本质上是个指向commit对象的可变指针</li><li>分支的默认名字为master（主分支）</li><li>每次提交的时候都会自动向前移动</li><li>作用： 从某个提交对象往回看的历史</li></ul><p>Git分支实质是一个包含所指对象校验和（40 个字符长度 SHA-1 字串）的文件<br>新建一个分支就是向一个文件写入 41 个字节（外加一个换行符）</p><p><strong>Git分支的特点</strong></p><ul><li>操作简单</li><li>操作速度快</li><li>合并分支容易</li><li>创建和销毁分支廉价</li></ul><p><strong>分支合并</strong></p><ul><li>快进式合并(fastforward)<br>  顺着一个分支走下去可以到达另一个分支的合并过程</li><li>非快进式合并(non-fastforward)<br>  使用两个分支的末端以及它们的共同祖先进行一次简单的三方合并计算的合并过程</li><li>分支衍合<br>  和三方合并结果一致， 但能产生更简洁的提交历史</li></ul><p><strong>合并冲突</strong></p><ul><li>修改了同一文件的同一行<br>  人工确认正确的修改，命令行解决</li><li>文件重名<br>  人工确认正确的名字，删除错误的，命令行解决</li></ul><p><strong>分支管理：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//新建一个名为test的分支</span><br><span class="line"> $ git branch test</span><br><span class="line"> </span><br><span class="line">//利用HEAD指针识别当前指针</span><br><span class="line">//每次提交后HEAD随着分支向前移动</span><br><span class="line"></span><br><span class="line">//切换到test分支</span><br><span class="line"> $ git checkout test</span><br><span class="line"> </span><br><span class="line">//查看所有分支</span><br><span class="line"> $ git branch</span><br><span class="line"> </span><br><span class="line">//查看已合并分支</span><br><span class="line"> $ git branch --merged</span><br><span class="line"> </span><br><span class="line">//查看未合并分支</span><br><span class="line"> $ git branch --no-merged</span><br><span class="line"> </span><br><span class="line">//删除名为test的分支</span><br><span class="line"> $ git branch -d test</span><br></pre></td></tr></table></figure><p><strong>分支策略</strong></p><ul><li>长期分支<ul><li>master：稳定分支（主分支）</li><li>develop：测试分支</li><li>topic：开发分支</li></ul></li><li>短期分支<br>  用来实现单一特性或与其相关工作的分支</li></ul><h2 id="Git使用的协议"><a href="#Git使用的协议" class="headerlink" title="Git使用的协议"></a>Git使用的协议</h2><ul><li>HTTP<ul><li>版本控制工具普遍采用的协议， 优点： 安全（HTTPS） 、 方便（跨越防火墙） 。</li><li>哑协议<ul><li>Git服务器和客户端的会话过程中只使用了相关协议提供的基本传输功能，而未针对Git的传输特点进行相关优化设计。</li><li>优点： 配置简单。</li><li>缺点： Git客户端和服务器间的通讯缺乏效率， 用户使用时最直观的体验之一就是在操作过程没有进度提示， 应用会一直停在那里直到整个通讯过程处理完毕。</li></ul></li><li>智能协议<ul><li>优点： 打破了以前哑传输协议给HTTP协议带来的恶劣印象， 让HTTP协议成为Git服务的一个重要选项。</li><li>不足： 授权管理能力弱。<ul><li>创建版本库只能在服务器端进行， 不能通过远程客户端进行。</li><li>配置认证和授权， 也只能在服务器端进行， 不能在客户端远程配置。</li><li>版本库的写操作授权只能进行非零即壹的授权， 不能针对分支甚至路径进行授权。</li></ul></li></ul></li></ul></li><li>SSH<ul><li>唯一一个同时支持读写操作的网络协议</li><li>是一个验证授权的网络协议</li><li>优点<ul><li>拥有对网络仓库的写权限</li><li>架设相对简单</li><li>安全： 传输过程加密和授权</li><li>高效： 压缩数据传输</li></ul></li><li>缺点<ul><li>无法匿名访问仓库</li><li>不利于开源项目</li></ul></li></ul></li><li>Git<ul><li>一个包含在 Git 软件包中的特殊守护进程</li><li>监听一个提供类似于SSH服务的特定端口（9418） ， 而无需任何授权</li><li>优点<ul><li>现存最快的传输协议</li><li>使用与 SSH 协议相同的数据传输机制， 但省去了加密和授权的开销</li></ul></li><li>缺点<ul><li>缺少授权机制</li><li>最难架设的协议： 要求有单独的守护进程， 需要定制</li><li>要求防火墙开放 9418 端口， 而企业级防火墙一般不允许对这个非标准端口的访问</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;Git相关内容（粗略版）&lt;/center&gt;
    
    </summary>
    
    
      <category term="SE" scheme="http://yoursite.com/categories/SE/"/>
    
    
      <category term="SE" scheme="http://yoursite.com/tags/SE/"/>
    
  </entry>
  
  <entry>
    <title>敏捷开发与DevOps</title>
    <link href="http://yoursite.com/2020/01/08/AgileSoftwareDevelopment/"/>
    <id>http://yoursite.com/2020/01/08/AgileSoftwareDevelopment/</id>
    <published>2020-01-08T11:12:34.000Z</published>
    <updated>2020-01-09T00:48:31.406Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><style>    th{text-align: center}    td{text-align: center}</style><h1 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h1><h2 id="敏捷宣言"><a href="#敏捷宣言" class="headerlink" title="敏捷宣言"></a>敏捷宣言</h2><ul><li><strong>个体和交互</strong>胜过过程和工具</li><li><strong>可以工作的软件</strong>胜过面面俱到的文档</li><li><strong>客户合作</strong>胜过合同谈判</li><li><strong>响应变化</strong>胜过遵循计划</li></ul><h2 id="敏捷开发原则"><a href="#敏捷开发原则" class="headerlink" title="敏捷开发原则"></a>敏捷开发原则</h2><ul><li>客户满意</li><li>拥抱变化</li><li>短迭代交付</li><li>业务参与</li><li>以人为本</li><li>面对面沟通</li><li>结果导向</li><li>保持节奏</li><li>追求卓越</li><li>简单务实</li><li>团队自组织</li><li>持续改进</li></ul><h2 id="软件开发中的浪费"><a href="#软件开发中的浪费" class="headerlink" title="软件开发中的浪费"></a>软件开发中的浪费</h2><style>table th:nth-of-type(1){width: 15%;}table th:nth-of-type(2){width: 15%;}table th:nth-of-type(3){width: 40%;}table th:nth-of-type(4){width: 30%;}</style><table><thead><tr><th align="center"></th><th align="center"><center>浪费类别</center></th><th align="left"><center>浪费举例</center></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">部分完成的工作<br>(库存)</td><td align="left">部分完成但没有最终落地的工作(没有转化成代码的设计文档；未及时合入的代码导致引发后续更多同步工作量)</td></tr><tr><td align="center">2</td><td align="center">未应用特性<br>(过度生成)</td><td align="left">开发完成但没有被客户应用的特性</td></tr><tr><td align="center">3</td><td align="center">过度作业</td><td align="left">在多个环节移交时，接收信息者也需要重新学习；拥有某领域的专家，但在开发过程中需要此领域经验时，他却没参与，而是团队重新摸索</td></tr><tr><td align="center">4</td><td align="center">传递</td><td align="left">知识信息的传递总是伴随信息丢失，隐形知识尤其困难，分工过细往往导致过多不必要的移交（如详细设计和实现分离，造成大量设计信息丢失）和重新学习的成本</td></tr><tr><td align="center">5</td><td align="center">任务切换<br>(移动)</td><td align="left">研究表明多任务工作会导致效率下降20%~40%（员工多头工作或杂事繁多）</td></tr><tr><td align="center">6</td><td align="center">等待</td><td align="left">因任务或资源相互依赖而导致工作停滞（集成时被关键模块阻塞，等待测试环境就绪）</td></tr><tr><td align="center">7</td><td align="center">缺陷</td><td align="left">解决缺陷活动本身就是浪费，而且缺陷越遗留到后端浪费越大</td></tr></tbody></table><h2 id="敏捷开发下的团队"><a href="#敏捷开发下的团队" class="headerlink" title="敏捷开发下的团队"></a>敏捷开发下的团队</h2><ul><li><strong>管理者</strong>努力“激发”团队<ul><li>通过目标来牵引团队自主工作</li><li>帮助团队提供资源，排除障碍</li><li>营造团队自我管理的工作氛围</li><li>作为教练辅导团队进步</li><li>基于简单原则的管理，原则简单但必须被遵守</li></ul></li><li><strong>团队成员</strong>是“全方位的积极参与者”<ul><li>共同参与计划制定和任务安排</li><li>团队协作贯穿工作始终</li><li>面对面交流是主要沟通方式</li><li>关注团队目标，共担责任</li><li>能力要求更广，主动学习适应岗位要求</li></ul></li></ul><h2 id="敏捷开发适应变化"><a href="#敏捷开发适应变化" class="headerlink" title="敏捷开发适应变化"></a>敏捷开发适应变化</h2><ul><li>认清“客户是逐步发现真正需求”</li><li>小批量是快速交付的关键</li><li>通过迭代计划不断调整以适应需求变化</li><li>应持续保持良好的软件架构</li><li>利用多层反馈不断调整以逼近目标</li></ul><h2 id="敏捷团队的角色职责"><a href="#敏捷团队的角色职责" class="headerlink" title="敏捷团队的角色职责"></a>敏捷团队的角色职责</h2><p>敏捷团队包含三个核心角色：PO（Product Owner），Scrum Master（Scrum教练）和Team（开发产品） </p><table><thead><tr><th align="center">角色名称</th><th align="center">角色定义</th><th>角色职责</th><th><center>  注意事项   </center></th></tr></thead><tbody><tr><td align="center">Product Owner<br>产品负责人</td><td align="center">确保Team做正确的事</td><td>代表利益相关人（如用户、 Marketing、 用服、 管理者等），对产品投资回报负责；确定产品发布计划；定义产品需求并确定优先级；验收迭代结果，并根据验收结果和需求变化刷新需求清单和优先级</td><td>除了客户需求之外， 内部任务如重构、 持续集成环境搭建等也由PO纳入产品Backlog统一管理</td></tr><tr><td align="center">Scrum Master （Scrum教练）</td><td align="center">确保Team正 确地做事</td><td>辅导团队正确应用敏捷实践；引导团队建立并遵守规则；保护团队不受打扰；推动解决团队遇到的障碍；激励团队</td><td>不命令和控制Team</td></tr><tr><td align="center">Team （开发团队）</td><td align="center">负责产品需 求实现</td><td>负责估计工作量并根据自身能力找出最佳方案去完成任务且保证交付质量；向PO和利益相关人演示工作成果（可运行的软件）；团队自我管理、 持续改进</td><td>一般由5-9名跨功能领域人员组成；坐在一起工作；有共同的目标，共担责任；团队成员严格遵守团队规则</td></tr></tbody></table><h2 id="迭代开发"><a href="#迭代开发" class="headerlink" title="迭代开发"></a>迭代开发</h2><p>迭代开发将整个软件生命周期分成多个小的迭代（一般2-4周） ， 每一次迭代都由需求分析、 设计、 实现和测试在内的多个活动组成， 每一次迭代都可以生成一个稳定和被验证过的软件版本。  </p><p><strong>迭代开发好处</strong></p><ul><li>通过将高技术风险的需求在早期迭代里实现， 有助于尽早暴露问题和及时消除风险。</li><li>通过提供功能渐增的产品， 持续从客户获得反馈， 根据反馈及时调整， 使最终产品更加符合客户的需要。</li><li>通过小批量减少排队， 提供更灵活、 快速的交付能力。</li><li>平滑人力资源的使用， 避免出现瓶颈。  </li></ul><p><strong>迭代开发的关键要点</strong></p><ul><li>每一次迭代都建立在稳定的质量基础上， 并做为下一轮迭代的基线， 整个系统的功能随着迭代稳定地<br>增长和不断完善。</li><li>每次迭代要邀请用户代表（外部或内部） 验收， 提供需求是否满足的反馈。</li><li>迭代推荐采用固定的周期（2-4周） ， 迭代内工作不能完成， 应当缩减交付范围而不是延长周期。  </li></ul><h2 id="产品Backlog"><a href="#产品Backlog" class="headerlink" title="产品Backlog"></a>产品Backlog</h2><p>经过优先级排序的动态刷新的产品需求清单， 用来制定发布计划和迭代计划<br><strong>产品Backlog好处</strong></p><ul><li>通过需求的动态管理应对变化， 避免浪费</li><li>易于优先交付对用户价值高的需求</li></ul><p><strong>产品Backlog关键点</strong></p><ul><li>清楚表述列表中每个需求任务对用户带来的价值，做为优先级排序的重要参考。</li><li>动态的需求管理而非“冻结” 方式， PO持续地管理和及时刷新需求清单， 在每轮迭代前， 都要重新筛选出高优先级需求进入本轮迭代。</li><li>迭代的需求分析过程， 而非一次性分析清楚所有需求（只对近期迭代要做的需求进行详细分析， 其它需求停留在粗粒度）。</li></ul><h2 id="迭代Backlog"><a href="#迭代Backlog" class="headerlink" title="迭代Backlog"></a>迭代Backlog</h2><p>迭代Backlog是团队在一轮迭代中的“任务” （Task） 清单， 是团队的详细迭代开发计划<br>当团队接收从产品Backlog挑选出要在本轮迭代实现的需求时， 召开团队迭代计划会议， 将需求转化为具体的“任务”<br>每项任务信息包括当前剩余工作量和责任人  </p><p><strong>迭代Backlog好处</strong></p><ul><li>将需求分解成更细小的任务， 利于对迭代内进度进行精确控制。</li><li>剩余工作量可用来实时跟踪团队当前进展。  </li></ul><p><strong>迭代Backlog关键点</strong></p><ul><li>“任务” 由团队成员自己分解和定义，而不是上级指派， 支撑需求完成的所有工作都可以列为任务。</li><li>任务要落实到具体的责任人。</li><li>任务粒度要小， 工作量大于两天的任务要进一步分解。</li><li>用小时做为任务剩余工作量的估计单位， 并每日重估计和刷新。  </li></ul><h2 id="迭代计划会议"><a href="#迭代计划会议" class="headerlink" title="迭代计划会议"></a>迭代计划会议</h2><p>每轮迭代启动前， 团队共同讨论本轮迭代详细开发计划的过程， 输入是产品Backlog， 输出是团队迭代Backlog  </p><ul><li>多团队迭代计划会议要分层召开<ul><li>版本迭代计划会议： 将产品Backlog（需求） 分配给团队。</li><li>团队迭代计划会议： 将选取的产品Backlog需求转换成迭代Backlog（任务） ， 分配给团队成员。</li></ul></li><li>迭代计划会议内容：<ul><li>澄清需求、 对“完成标准” 达成一致。</li><li>工作量估计、 根据团队能力确定本轮迭代交付内容。</li><li>细化、 分配迭代任务和初始工作计划。  </li></ul></li></ul><p><strong>迭代计划会议的好处</strong></p><ul><li>通过充分讨论， 使团队成员对任务和完成标准理解一致。</li><li>团队共同参与， 促进团队成员更认真对待自己的承偌。  </li></ul><p><strong>迭代计划会议的关键要点</strong></p><ul><li><strong>充分参与</strong>： Scrum Master确保PO和Team充分参与讨论， 达成理解一致。</li><li><strong>相互承诺</strong>： Team承诺完成迭代Backlog中的需求并达到” 完成标准“， PO承诺在短迭代周期不增加需求（2-4周） 。</li><li><strong>确定内部任务</strong>： Team和PO协商把一些内部任务放入迭代中（例如重构、 持续集成环境搭建等） ，由PO考虑并与其他外部需求一起排序 。  </li></ul><h2 id="每日站立会议"><a href="#每日站立会议" class="headerlink" title="每日站立会议"></a>每日站立会议</h2><p>每日工作前， 团队成员的例行沟通机制， 由Scrum Master组织， Team成员全体站立参加<br>聚焦在下面的三个主题：</p><ul><li>我昨天为本项目做了什么？</li><li>我计划今天为本项 目做什么？</li><li>我需要什么帮助以更高效的工作？  </li></ul><p><strong>每日站立会议的好处</strong></p><ul><li>增加团队凝聚力， 产生积极的工作氛围</li><li>及时暴露风险和问题；</li><li>促进团队内成员的沟通和协调。</li></ul><p><strong>每日站立会议的关键要点</strong></p><ul><li><strong>准时开始</strong>： 按计划会议制定的时间地点开会， 形成团队成员的自然习惯。</li><li><strong>高效会议</strong>： 会议限时15分钟， 每个人都保持站立，依次发言， 不讨论与会议三个主题无关的事情（如技术解决方案等） 。</li><li><strong>问题跟踪</strong>： Scrum Master应该记录下所有的问题并跟踪解决。</li></ul><h2 id="迭代回顾会议"><a href="#迭代回顾会议" class="headerlink" title="迭代回顾会议"></a>迭代回顾会议</h2><p>在每轮迭代结束后举行的会议， 目的是分享好的经验和发现改进点， 促进团队不断进步。  </p><p>围绕如下三个问题：</p><ul><li>本次迭代有哪些做得好</li><li>本次迭代我们在哪些方面还能做得更好</li><li>我们在下次迭代准备在哪些方面改进？  </li></ul><p><strong>迭代回顾会议的好处</strong></p><ul><li>激励团队成员；</li><li>帮助团队挖掘优秀经验并继承；</li><li>避免团队犯重复的错误；</li><li>营造团队自主改进的氛围。  </li></ul><p><strong>迭代回顾会议的关键要点</strong></p><ul><li><strong>会议气氛</strong>： Team全员参加， 气氛宽松自由，畅所欲言， 头脑风暴发现问题， 共同分析根因。</li><li>关注重点： Team共同讨论优先级， 将精力放在最需要的地方（关注几个改进就够了） 。</li><li>会议结论要跟踪闭环： 可以放入迭代Backlog中。  </li></ul><h2 id="用户故事"><a href="#用户故事" class="headerlink" title="用户故事"></a>用户故事</h2><p>用户故事是站在用户角度描述需求的一种方式。  </p><p><strong>用户故事的好处</strong></p><ul><li>用户故事站在用户视角便于和客户交流， 准确描述客户需求；</li><li>用户故事可独立交付单元、 规模小， 适于迭代开发， 以获得用户快速反馈；</li><li>用户故事强调编写验收测试用例作为验收标准， 能促使需求分析人员准确把握需求， 牵引开发人员避免过度设计。  </li></ul><p><strong>用户故事的关键要点</strong></p><ul><li>I – Independent， 可独立交付给客户</li><li>N – Negotiable， 便于与客户交流</li><li>V - Valuable ， 对客户有价值</li><li>E - Estimable ， 能估计出工作量</li><li>S - Small ， 分解到最底层的用户故事粒度尽量小， 至少在一个迭代中能完成</li><li>T - Testable， 可测试  </li></ul><h2 id="结对编程"><a href="#结对编程" class="headerlink" title="结对编程"></a>结对编程</h2><p>两位程序员在一台电脑前工作， 一个负责敲入代码，而另外一个实时检视每一行敲入的代码。</p><p>操作键盘和鼠标的程序员被称为“驾驶员” ， 负责实时评审和协助的程序员被称为“领航员”。</p><p>领航员检视的同时还必须负责考虑下一步的工作方向 ，比如可能出现的问题以及改进等。  </p><p><strong>结对编程的好处</strong></p><ul><li>有助于提升代码设计质量。</li><li>研究表明结对生产率比两个单人总和低 15%， 但缺陷数少 15%， 考虑修改缺陷工作量和时间都比初始编程大几倍， 所以结对编程总体效率更高（source: The Economist） 。</li><li>结对编程能够大幅促进团队能力提升和知识传播。  </li></ul><p><strong>结对编程的关键要点</strong></p><ul><li>程序员应经常性地在“驾驶员” 和“领航员”间切换， 保持成员间平等协商和相互理解， 避免出现一个角色支配另一个角色的现象。</li><li>开始一个新Story开发的时候即可变换搭档， 以增进知识传播。</li><li>培养团队成员积极、 主动、 开放、 协作的心态能够增进结对编程效果。</li><li>实施初期需要精心辅导， 帮助团队成员克服个性冲突和习惯差异。  </li></ul><h2 id="测试驱动开发（TDD）"><a href="#测试驱动开发（TDD）" class="headerlink" title="测试驱动开发（TDD）"></a>测试驱动开发（TDD）</h2><p>TDD以测试作为编程的中心， 它要求在编写任何代码之前， 首先编写定义代码功能的测试用例，编写的代码要通过用例， 并不断进行重构优化  </p><p>TDD要求测试可以完全自动化运行  </p><p><strong>测试驱动开发的好处</strong></p><ul><li>和代码同步增长的自动化测试用例， 能为代码构筑安全网， 保证代码重构的质量。</li><li>TDD有助于开发人员优化代码设计， 提高代码可测试性。  </li></ul><p><strong>测试驱动开发的关键要点</strong></p><ul><li>测试代码和源代码一样都需要简洁， 可读性好。</li><li>测试用例的设计要保证完备， 覆盖被测单元的所有功能。</li><li>每个测试用例尽量保持独立， 减少依赖， 提高用例的可维护性。</li><li>当功能单元较大时， 为降低难度， 可分解为多个更小的功能单元， 并逐一用 TDD 实现  </li></ul><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>持续集成（CI） 是一项软件开发实践， 其中团队的成员经常集成他们的工作， 通常每人每天至少集成一次， 每次集成通过自动化构建完成。  </p><p><strong>持续集成的好处</strong></p><ul><li>大幅缩短反馈周期， 实时反映产品真实质量状态。</li><li>缺陷在引入的当天就被发现并解决,降低缺陷修改成本。</li><li>将集成工作分散在平时， 通过每天生成可部署的软件，避免产品最终集成时爆发大量问题。  </li></ul><p><strong>持续集成的关键要点</strong></p><ul><li>持续集成强调 “快速” 和“反馈” ， 要求完成一次系统集成的时间尽量短， 并提供完备且有效的反馈信息。</li><li>自动化测试用例的完备性和有效性是持续集成质量保障。</li><li>修复失败的构建是团队最高优先级的任务。</li><li>开发人员须先在本地构建成功， 才可提交代码到配置库 。</li><li>持续集成的状态必须实时可视化显示给所有人。</li><li>大系统持续集成需分层分级， 建立各层次统一的测试策略。  </li></ul><h2 id="Anatomy系统解剖"><a href="#Anatomy系统解剖" class="headerlink" title="Anatomy系统解剖"></a>Anatomy系统解剖</h2><p>Anatomy（解剖） 来源于电信行业， 从用户视角全面展示复杂产品系统的功能依赖关系， 让整个系统的功能按自底向上逐步有序地开发和集成  </p><p><strong>Anatomy的好处</strong></p><ul><li>Anatomy是迭代计划制定的重要依据， 保证系统按照类似生物自然生长的顺序自底向上有序地开发和集成（Organic integration） 。</li><li>Anatomy也可作为可视化工具， 通过标识图中每一个功能的状态， 使项目整体进展一目了然， 并能极大增强团队的信心。</li><li>有助于团队从增量交付向交付全系统的思维转变。</li><li>是很好的培训教材， 帮助工程师了解全系统。  </li></ul><p><strong>Anatomy的关键要点</strong></p><ul><li>Anatomy不是系统架构视图， 图中的Block是表示系统提供给用户使用的一个功能（capability） ， 是站在纯用户视角， 不包含设计信息。</li><li>Anatomy中的依赖关系是用户使用系统功能的依赖关系， 而不是设计或架构上的依赖关系。</li><li>Anatomy是系统全视图， 由最了解系统的工程师绘制出基线， 在增量开发时需不断刷新。  </li></ul><h2 id="精益软件开发七项原则"><a href="#精益软件开发七项原则" class="headerlink" title="精益软件开发七项原则"></a>精益软件开发七项原则</h2><ul><li>消除浪费<ul><li>缺陷</li><li>过度生产（未应用特性）</li><li>运输（传递）</li><li>等待</li><li>库存（部分完成的工作）</li><li>移动（任务切换）</li><li>过度作业</li></ul></li><li>内建质量</li><li>创建知识</li><li>推迟决策</li><li>快速交付</li><li>对人尊重</li><li>整体优化  </li></ul><h2 id="敏捷与精益的区别"><a href="#敏捷与精益的区别" class="headerlink" title="敏捷与精益的区别"></a>敏捷与精益的区别</h2><ul><li>基本观点与哲学上不同<ul><li>敏捷： 尽快交付可用的产品， 并与客户密切协作、 及时获得客户反馈</li><li>精益： 开发最小的可用产品， 并基于看板梳理价值流， 消除价值流中的浪费  </li></ul></li><li>角度不同  <ul><li>敏捷的关注重点稍窄些    <ul><li>主要关心的是围绕软件开发的具体开发实践和项目管理</li><li>一般不太关心在其中进行软件开发的商业上下文环境</li></ul></li><li>精益采用比较宽泛的视角， 偏好一体看待软件开发和它的整个业务环境  </li></ul></li></ul><h1 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h1><p>DevOps是一套实践方法， 在保证高质量的前提下缩短系统变更从提交到部署至生产环境的时间</p><ul><li>部署对系统的变更时， 质量很重要： 保证方法有：上生产环境前跑通自动化测试用例、先让一小部分用户对生产环境的变更进行测试、 对新部署的代码密切监控。</li><li>交付机制是高质量的： 交付机制应具备高度的可靠性和可重复性。</li><li>两个时间很重要： 一是开发人员提交新开发的代码的时间； 另一个是代码部署到生产环境的时间。</li><li>目标导向： 不拘泥于实践的形式或者是否使用工具， 目标是减少从提交代码到部署到生产环境之间的时间。</li><li>不局限于用户测试和部署实践： 在需求阶段就包含运维人员的视角， 是非常重要的。</li></ul><h2 id="DevOps五个要素"><a href="#DevOps五个要素" class="headerlink" title="DevOps五个要素"></a>DevOps五个要素</h2><ul><li>文化<br>  建立一体化的全功能团队， 打破开发(Dev)与技术运营(Ops)隔阂</li><li>自动化<br>  自动化一切可以自动化的</li><li>精益<br>  以精益的方式小步快跑， 持续改善</li><li>度量<br>  建立有效的监控与度量手段快速获得反馈， 推动产品和团队的持续改进</li><li>分享<br>  不同职能、 不同产品之间分享经验</li></ul><h2 id="DevOps生命周期过程"><a href="#DevOps生命周期过程" class="headerlink" title="DevOps生命周期过程"></a>DevOps生命周期过程</h2><p><img src="/images/DevOpsLifeCycle.png" alt="DevOpsLifeCycle"></p><h2 id="DevOps与敏捷"><a href="#DevOps与敏捷" class="headerlink" title="DevOps与敏捷"></a>DevOps与敏捷</h2><p>DevOps是敏捷理念从开发领域向运维领域的延伸</p><ul><li>计划阶段：<br>  运维人员为开发人员提供需求， 并制定发布计划</li><li>编码/构建/验证阶段：<br>  Scrum、 极限编程和精益生产， 持续集成、 自动化测试等</li><li>部署阶段：<br>  开发团队负责部署、 监控部署过程， 以及部署后的运行</li></ul><h2 id="DevOps和ITIL的关系"><a href="#DevOps和ITIL的关系" class="headerlink" title="DevOps和ITIL的关系"></a>DevOps和ITIL的关系</h2><p>DevOps对各种ITIL服务提供持续交付， 而不要求把这些服务打包主要发布版本（Major Release）<br><img src="/images/DevOps_ITIL.png" alt="DevOps_ITIL"></p><p><strong>DevOps与ITIL的比较</strong></p><table><thead><tr><th>DevOps</th><th>ITIL</th></tr></thead><tbody><tr><td>技术导向</td><td>流程导向</td></tr><tr><td>强调对外的价值输出</td><td>强调对内服务的输出</td></tr><tr><td>强调敏捷</td><td>强调规范</td></tr><tr><td>是一种文化</td><td>不关注文化</td></tr><tr><td>把Dev当作合作的对象</td><td>把Dev当作服务的对象</td></tr><tr><td>以软件为核心</td><td>以服务为核心</td></tr><tr><td>强调实现</td><td>强调实践</td></tr></tbody></table><h2 id="DevOps理念"><a href="#DevOps理念" class="headerlink" title="DevOps理念"></a>DevOps理念</h2><p><img src="/images/DevOps.png" alt="DevOps"><br><img src="/images/DevOpsEnd-to-End.png" alt="DevOpsETE"></p><p><strong>DevOps与传统敏捷模式的区别</strong></p><ul><li>传统敏捷模式强调持续构建CI（持续构建、 测试）</li><li>融合了DevOps的新型敏捷模式强调<strong>持续交付CD</strong>（包含持续构建、测试、 以及<strong>持续部署、 发布、 反馈</strong>） 。 加速了产品推向真实用户，并及时获得海量反馈的决策数据源， 比仅仅依靠PD或者少数粉丝用户反馈的决策准确率大为提升。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;敏捷开发与DevOps的相关内容&lt;/center&gt;
    
    </summary>
    
    
      <category term="SE" scheme="http://yoursite.com/categories/SE/"/>
    
    
      <category term="SE" scheme="http://yoursite.com/tags/SE/"/>
    
  </entry>
  
  <entry>
    <title>计算方法上机代码</title>
    <link href="http://yoursite.com/2019/12/28/ComputationlMethodsCode/"/>
    <id>http://yoursite.com/2019/12/28/ComputationlMethodsCode/</id>
    <published>2019-12-28T04:11:30.000Z</published>
    <updated>2020-08-05T11:37:57.579Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-4-向量范数计算"><a href="#1-4-向量范数计算" class="headerlink" title="1.4 向量范数计算"></a>1.4 向量范数计算</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.abs;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.sqrt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorNorm</span> </span>&#123;</span><br><span class="line">    <span class="comment">//向量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] vector;</span><br><span class="line">    <span class="comment">//向量长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向量构造函数1</span></span><br><span class="line"><span class="comment">     * 构造成1,1/2,...,1/n的向量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 向量长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateVector1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        vector = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            vector[i - <span class="number">1</span>] = <span class="number">1</span>/(<span class="keyword">double</span>)i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向量构造函数2</span></span><br><span class="line"><span class="comment">     * 构造成1,2,...,n的向量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 向量长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateVector2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        vector = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            vector[i - <span class="number">1</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，调用向量构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 向量长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VectorNorm</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        N = n;</span><br><span class="line">        <span class="comment">//generateVector1(n);</span></span><br><span class="line">        generateVector2(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向量1-范数计算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 向量元素和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">norm1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">            result = result + vector[i];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向量2-范数计算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 向量元素平方和开方</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">norm2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">            result = result + vector[i] * vector[i];</span><br><span class="line">        <span class="keyword">return</span> sqrt(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向量无穷范数计算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 向量最大元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">normInfty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> max = vector[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i ++)</span><br><span class="line">            <span class="keyword">if</span>(vector[i] &gt; max)</span><br><span class="line">                max = vector[i];</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] getVector() &#123;</span><br><span class="line">        <span class="keyword">return</span> vector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><table><thead><tr><th align="center">$n$</th><th align="center">$\Vert (1,\dfrac{1}{2},\cdots,\dfrac{1}{n})^T\Vert_1$</th><th align="center">$\Vert (1,\dfrac{1}{2},\cdots,\dfrac{1}{n})^T\Vert_2$</th><th align="center">$\Vert (1,\dfrac{1}{2},\cdots,\dfrac{1}{n})^T\Vert_\infty$</th></tr></thead><tbody><tr><td align="center">$10 $</td><td align="center">$2.928968$</td><td align="center">$1.244897$</td><td align="center">$1.000000$</td></tr><tr><td align="center">$100 $</td><td align="center">$5.187378$</td><td align="center">$1.278665$</td><td align="center">$1.000000$</td></tr><tr><td align="center">$1000 $</td><td align="center">$7.485471$</td><td align="center">$1.282160$</td><td align="center">$1.000000$</td></tr></tbody></table><table><thead><tr><th align="center">$n$</th><th align="center">$\Vert (1,2,\cdots,n)^T\Vert_1$</th><th align="center">$\Vert(1,2,\cdots,n)^T\Vert_2$</th><th align="center">$\Vert(1,2,\cdots,n)^T\Vert_\infty$</th></tr></thead><tbody><tr><td align="center">$ 10 $</td><td align="center">$55$</td><td align="center">$19.621417$</td><td align="center">$10$</td></tr><tr><td align="center">$ 100 $</td><td align="center">$5050$</td><td align="center">$581.678605$</td><td align="center">$100$</td></tr><tr><td align="center">$ 1000 $</td><td align="center">$500500$</td><td align="center">$18271.111077$</td><td align="center">$1000$</td></tr></tbody></table><h2 id="2-1-高斯列主元"><a href="#2-1-高斯列主元" class="headerlink" title="2.1 高斯列主元"></a>2.1 高斯列主元</h2><p>$PA=LU$存在部分问题，$L$阵求法有问题<br>$Doolittle$分解，求行列式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.abs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EMCP</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义行列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> Row = <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> Column = <span class="number">9</span>;</span><br><span class="line">    <span class="comment">//定义两个解向量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] result_x = <span class="keyword">new</span> <span class="keyword">double</span>[Column];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] result_y = <span class="keyword">new</span> <span class="keyword">double</span>[Column];</span><br><span class="line">    <span class="comment">//列主元LU分解，置换矩阵P</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[][] P;</span><br><span class="line">    <span class="comment">//系数矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[][] Matrix = &#123;</span><br><span class="line">            &#123;<span class="number">31</span>,-<span class="number">13</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,-<span class="number">10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;-<span class="number">13</span>,<span class="number">35</span>,-<span class="number">9</span>,<span class="number">0</span>,-<span class="number">11</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,-<span class="number">9</span>,<span class="number">31</span>,-<span class="number">10</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">0</span>,-<span class="number">10</span>,<span class="number">79</span>,-<span class="number">30</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,-<span class="number">9</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,-<span class="number">30</span>,<span class="number">57</span>,-<span class="number">7</span>,<span class="number">0</span>,-<span class="number">5</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,-<span class="number">7</span>,<span class="number">47</span>,-<span class="number">30</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,-<span class="number">30</span>,<span class="number">41</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,-<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">27</span>,-<span class="number">2</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,-<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,-<span class="number">2</span>,<span class="number">29</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//解向量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] b = &#123;-<span class="number">15</span>,<span class="number">27</span>,-<span class="number">23</span>,<span class="number">0</span>,-<span class="number">20</span>,<span class="number">12</span>,-<span class="number">7</span>,<span class="number">7</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LU矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[][] L_Matrix = <span class="keyword">new</span> <span class="keyword">double</span>[Row][Column];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[][] U_Matrix = <span class="keyword">new</span> <span class="keyword">double</span>[Row][Column];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逆矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[][] inverseMatrix = <span class="keyword">new</span> <span class="keyword">double</span>[Row][Column];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EMCP</span><span class="params">()</span></span>&#123;</span><br><span class="line">        P = <span class="keyword">new</span> <span class="keyword">double</span>[Row][Column];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Row; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Column; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j)</span><br><span class="line">                    P[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    P[i][j] = <span class="number">0</span>;</span><br><span class="line">                inverseMatrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对矩阵进行列主元LU分解</span></span><br><span class="line"><span class="comment">     * 更新LU矩阵，更新初始矩阵将其化为上三角矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LU_cpFactorization</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化L矩阵对角元</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Row; i ++)</span><br><span class="line">            L_Matrix[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> Max;</span><br><span class="line">        <span class="comment">//按行进行消元</span></span><br><span class="line">        <span class="keyword">for</span>(; i &lt; Row - <span class="number">1</span>; i++, j++)&#123;</span><br><span class="line">            Max = Matrix[i][i];</span><br><span class="line">            <span class="keyword">int</span> target = i;</span><br><span class="line">            <span class="comment">//找出最大列主元所在行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; Column; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(abs(Max) &lt; abs(Matrix[k][i])) &#123;</span><br><span class="line">                    Max = Matrix[k][i];</span><br><span class="line">                    target = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若初始行不是最大列主元所在行，进行行变换</span></span><br><span class="line">            <span class="keyword">if</span>(i != target)</span><br><span class="line">                swap(i, target);</span><br><span class="line">            <span class="comment">//更新U矩阵第i行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; Column; k ++)</span><br><span class="line">                U_Matrix[i][k] = Matrix[i][k];</span><br><span class="line">            <span class="comment">//更新L矩阵第i列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; Row; k ++)&#123;</span><br><span class="line">                <span class="comment">//获取行间商</span></span><br><span class="line">                <span class="keyword">double</span> Quotient = Matrix[k][i] / Matrix[i][i];</span><br><span class="line">                <span class="keyword">if</span>(Quotient == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//首位置0</span></span><br><span class="line">                Matrix[k][i] = <span class="number">0</span>;</span><br><span class="line">                L_Matrix[k][i] = Quotient;</span><br><span class="line">                <span class="comment">//更新行</span></span><br><span class="line">                <span class="keyword">if</span>(Quotient != <span class="number">0</span>)</span><br><span class="line">                    updateRaw(Quotient, k, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        U_Matrix[Row - <span class="number">1</span>][Column - <span class="number">1</span>] = Matrix[Row - <span class="number">1</span>][Column - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对矩阵进行LU分解</span></span><br><span class="line"><span class="comment">     * 更新LU矩阵，更新初始矩阵将其化为上三角矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LU_Factorization</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化L矩阵对角元</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Row; i ++)</span><br><span class="line">            L_Matrix[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> Max;</span><br><span class="line">        <span class="comment">//按行进行消元</span></span><br><span class="line">        <span class="keyword">for</span>(; i &lt; Row - <span class="number">1</span>; i++, j++)&#123;</span><br><span class="line">            <span class="comment">//更新U矩阵第i行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; Column; k ++)</span><br><span class="line">                U_Matrix[i][k] = Matrix[i][k];</span><br><span class="line">            <span class="comment">//更新L矩阵第i列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; Row; k ++)&#123;</span><br><span class="line">                <span class="comment">//获取行间商</span></span><br><span class="line">                <span class="keyword">double</span> Quotient = Matrix[k][i] / Matrix[i][i];</span><br><span class="line">                <span class="keyword">if</span>(Quotient == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//首位置0</span></span><br><span class="line">                Matrix[k][i] = <span class="number">0</span>;</span><br><span class="line">                L_Matrix[k][i] = Quotient;</span><br><span class="line">                <span class="comment">//更新行</span></span><br><span class="line">                <span class="keyword">if</span>(Quotient != <span class="number">0</span>)</span><br><span class="line">                    updateRaw(Quotient, k, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        U_Matrix[Row - <span class="number">1</span>][Column - <span class="number">1</span>] = Matrix[Row - <span class="number">1</span>][Column - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 寻找列主元后进行行变换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 待交换行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 目标交换行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; Column; k++)&#123;</span><br><span class="line">            temp = Matrix[i][k];</span><br><span class="line">            Matrix[i][k] = Matrix[j][k];</span><br><span class="line">            Matrix[j][k] = temp;</span><br><span class="line"></span><br><span class="line">            temp = P[i][k];</span><br><span class="line">            P[i][k] = P[j][k];</span><br><span class="line">            P[j][k] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LU分解，更新矩阵的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> quotient 两行之间比例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row 当前待更新的行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> column 待更新的行的第一个元素所在列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateRaw</span><span class="params">(<span class="keyword">double</span> quotient, <span class="keyword">int</span> row, <span class="keyword">int</span> column)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(; column &lt; Column; column ++)</span><br><span class="line">            Matrix[row][column] = Matrix[row][column] - quotient * Matrix[row - <span class="number">1</span>][column];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算解向量</span></span><br><span class="line"><span class="comment">     * 先根据Ly=b，计算y，正序遍历，利用部分和化为1元1次方程组求y</span></span><br><span class="line"><span class="comment">     * 再根据Ux=y，计算x，逆序遍历，同理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//解向量初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Column; i ++) &#123;</span><br><span class="line">            result_y[i] = <span class="number">0</span>;</span><br><span class="line">            result_x[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> partSum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//利用Ly = b求解y</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Column; i ++) &#123;</span><br><span class="line">            partSum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//已知解计算的部分和，全部转化为一元一次方程求解</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                partSum = partSum + result_y[j] * L_Matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            result_y[i] = (b[i] - partSum) / L_Matrix[i][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//利用Ux = y求解x</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = Column - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            partSum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//已知解计算的部分和，全部转化为一元一次方程求解</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = Column - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                partSum = partSum + result_x[j] * U_Matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            result_x[i] = (result_y[i] - partSum) / U_Matrix[i][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算原矩阵的逆</span></span><br><span class="line"><span class="comment">     * 利用Ly = ei Uai = y</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInverseMatrix</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> partSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; Row; k ++) &#123;</span><br><span class="line">            <span class="comment">//利用Ly = b求解y</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Row; i ++)</span><br><span class="line">                b[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Column; i ++) &#123;</span><br><span class="line">                result_y[i] = <span class="number">0</span>;</span><br><span class="line">                result_x[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            b[k] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Column; i++) &#123;</span><br><span class="line">                partSum = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//已知解计算的部分和，全部转化为一元一次方程求解</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                    partSum = partSum + result_y[j] * L_Matrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                result_y[i] = (b[i] - partSum) / L_Matrix[i][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//利用Ux = y求解x</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Column - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                partSum = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//已知解计算的部分和，全部转化为一元一次方程求解</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = Column - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                    partSum = partSum + result_x[j] * U_Matrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                result_x[i] = (result_y[i] - partSum) / U_Matrix[i][i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Row; i ++)&#123;</span><br><span class="line">                inverseMatrix[i][k] = result_x[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 因为LU矩阵分别为下，上三角阵，行列式为对角元之积</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 行列式的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getDeterminant</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> u = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Row; i ++)&#123;</span><br><span class="line">            l = l * L_Matrix[i][i];</span><br><span class="line">            u = u * U_Matrix[i][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l * u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">逆矩阵</span><br><span class="line">[0.03894840265471074, 0.01595388325354099, 0.005784075484743884, 0.0035721390745191524, 0.007136051638908616, 0.01736063829564352, 0.012449737091243949, 0.0012279347186102522, 0.001141853652479522]</span><br><span class="line">[0.015857818644608744, 0.0378147983063747, 0.013040699815911189, 0.006392850953587455, 0.011877126791560352, 0.009346156617620205, 0.006418542249593486, 0.002036012705715857, 0.0020349359363873868]</span><br><span class="line">[0.004864298694204125, 0.011599481501563683, 0.03808288550334169, 0.007617411708951941, 0.006659031397314435, 0.0036339476905682807, 0.002434817417794583, 0.0010717289938677985, 0.0023528586727059246]</span><br><span class="line">[8.07289171884918E-4, 0.0019250741791101888, 0.0063203152260391865, 0.017860410439522308, 0.00995358321927043, 0.002853696884903487, 0.0017712459705290697, 0.0014899484458459032, 0.0054624195426397175]</span><br><span class="line">[4.4688452747539305E-4, 0.0010656477193643989, 0.0034986857022859833, 0.009886842729658587, 0.0239090439839064, 0.006247423141656982, 0.0037171854354044946, 0.004150157492119231, 0.003200266566997403]</span><br><span class="line">[1.2488399161191606E-4, 2.978002876899536E-4, 9.777242420214965E-4, 0.0027629248913456804, 0.006681495251588253, 0.041667975113588655, 0.030250080058384705, 0.0011597811102611675, 8.943296053829156E-4]</span><br><span class="line">[9.137853044774343E-5, 2.1790264952923434E-4, 7.154079819669486E-4, 0.0020216523595212297, 0.004888898964576769, 0.0304887622782356, 0.04652444882320832, 8.486203245813421E-4, 6.543875161338406E-4]</span><br><span class="line">[7.591099365329034E-5, 1.81018523327077E-4, 5.943117109949911E-4, 0.001679449633090103, 0.003487508748686805, -0.004236722653555438, -0.010601673941301766, 0.03674841118071818, 0.0024564601603960065]</span><br><span class="line">[1.918135347339413E-4, 4.574015059040139E-4, 0.001501719639455472, 0.004243669526998351, 2.7460453689195425E-4, 1.8665363910924237E-4, 4.516327146350918E-4, -0.0019462319422698404, 0.034666062236839594]</span><br><span class="line"></span><br><span class="line">行列式</span><br><span class="line">6.6824789473911836E13</span><br><span class="line"></span><br><span class="line">解</span><br><span class="line">[-0.28803238143825444, 0.3474791749739942, -0.711271134347599, -0.2176717739541517, -0.42657888255313675, 0.15537669007521887, -0.05704144628642523, 0.22550401651384522, 0.3015564086324566]</span><br></pre></td></tr></table></figure><h2 id="2-6-Hilbert矩阵求解"><a href="#2-6-Hilbert矩阵求解" class="headerlink" title="2.6 Hilbert矩阵求解"></a>2.6 Hilbert矩阵求解</h2><h3 id="利用LU分解计算"><a href="#利用LU分解计算" class="headerlink" title="利用LU分解计算"></a>利用LU分解计算</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用LU分解求解Hilbert矩阵</span></span><br><span class="line"><span class="comment"> * 误差向上积累</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hilbert</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Hilbert矩阵的阶数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="comment">//Hilbert矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[][] HilbertMatrix;</span><br><span class="line">    <span class="comment">//常数向量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] b;</span><br><span class="line">    <span class="comment">//L阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[][] L_Matrix;</span><br><span class="line">    <span class="comment">//U阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[][] U_Matrix;</span><br><span class="line">    <span class="comment">//Ux = y解出的x解向量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] result_x;</span><br><span class="line">    <span class="comment">//Ly = b解出的y解向量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] result_y;</span><br><span class="line">    <span class="keyword">private</span> DecimalFormat df = <span class="keyword">new</span> DecimalFormat( <span class="string">"0.000000 "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * 构造并初始化Hilbert矩阵，解向量，LU矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n Hilbert矩阵的阶数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hilbert</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        N = n;</span><br><span class="line">        HilbertMatrix = <span class="keyword">new</span> <span class="keyword">double</span>[n][n];</span><br><span class="line">        <span class="comment">//Hilbert矩阵构造</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                HilbertMatrix[i][j] = <span class="number">1</span>/(<span class="keyword">double</span>)(i + j + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        b = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">        result_x = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">        result_y = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            b[i] = <span class="number">1</span>;</span><br><span class="line">            result_x[i] = <span class="number">0</span>;</span><br><span class="line">            result_y[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        L_Matrix = <span class="keyword">new</span> <span class="keyword">double</span>[n][n];</span><br><span class="line">        U_Matrix = <span class="keyword">new</span> <span class="keyword">double</span>[n][n];</span><br><span class="line">        <span class="comment">//初始化LU矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)&#123;</span><br><span class="line">                L_Matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                U_Matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对Hilbert矩阵进行LU分解</span></span><br><span class="line"><span class="comment">     * 更新LU矩阵，更新初始Hilbert矩阵将其化为上三角矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LU_Factorization</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化L矩阵对角元</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">            L_Matrix[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//按行进行消元</span></span><br><span class="line">        <span class="keyword">for</span>(; i &lt; N - <span class="number">1</span>; i++, j++)&#123;</span><br><span class="line">            <span class="comment">//Hilbert矩阵不需要进行列主元消元</span></span><br><span class="line">            <span class="comment">//更新U矩阵第i行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; N; k ++)</span><br><span class="line">                U_Matrix[i][k] = HilbertMatrix[i][k];</span><br><span class="line">            <span class="comment">//更新L矩阵第i列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; N; k ++)&#123;</span><br><span class="line">                <span class="comment">//获取行间商</span></span><br><span class="line">                <span class="keyword">double</span> Quotient = HilbertMatrix[k][i] / HilbertMatrix[i][i];</span><br><span class="line">                <span class="keyword">if</span>(Quotient == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//首位置0</span></span><br><span class="line">                HilbertMatrix[k][i] = <span class="number">0</span>;</span><br><span class="line">                L_Matrix[k][i] = Quotient;</span><br><span class="line">                <span class="comment">//更新行</span></span><br><span class="line">                <span class="keyword">if</span>(Quotient != <span class="number">0</span>)</span><br><span class="line">                    updateRaw(Quotient, k, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        U_Matrix[N - <span class="number">1</span>][N - <span class="number">1</span>] = HilbertMatrix[N - <span class="number">1</span>][N - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LU分解，更新Hilbert矩阵的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> quotient 两行之间比例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row 当前待更新的行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> column 待更新的行的第一个元素所在列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateRaw</span><span class="params">(<span class="keyword">double</span> quotient, <span class="keyword">int</span> row, <span class="keyword">int</span> column)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(; column &lt; N; column ++)</span><br><span class="line">            HilbertMatrix[row][column] = HilbertMatrix[row][column] - quotient * HilbertMatrix[row - <span class="number">1</span>][column];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算解向量</span></span><br><span class="line"><span class="comment">     * 先根据Ly=b，计算y，正序遍历，利用部分和化为1元1次方程组求y</span></span><br><span class="line"><span class="comment">     * 再根据Ux=y，计算x，逆序遍历，同理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//解向量初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line">            result_y[i] = <span class="number">0</span>;</span><br><span class="line">            result_x[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> partSum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//利用Ly = b求解y</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line">            partSum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//已知解计算的部分和，全部转化为一元一次方程求解</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                partSum = partSum + result_y[j] * L_Matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            result_y[i] = (b[i] - partSum) / L_Matrix[i][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//利用Ux = y求解x</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            partSum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//已知解计算的部分和，全部转化为一元一次方程求解</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = N - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                partSum = partSum + result_x[j] * U_Matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            result_x[i] = (result_y[i] - partSum) / U_Matrix[i][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出矩阵结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMatrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">            System.out.println(Arrays.toString(HilbertMatrix[i]));</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">            System.out.println(Arrays.toString(L_Matrix[i]));</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">            System.out.println(Arrays.toString(U_Matrix[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出解向量结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">            System.out.println(df.format(result_y[i]));</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">            System.out.println(df.format(result_x[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="利用增广矩阵Gauss消元法实现"><a href="#利用增广矩阵Gauss消元法实现" class="headerlink" title="利用增广矩阵Gauss消元法实现"></a>利用增广矩阵Gauss消元法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  利用增广矩阵Gauss消元法实现</span></span><br><span class="line"><span class="comment"> *  误差向下积累</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hilbert2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Hilbert矩阵阶数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="comment">//Hilbert增广矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[][] HilbertMatrix;</span><br><span class="line">    <span class="comment">//解向量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] result;</span><br><span class="line">    <span class="keyword">private</span> DecimalFormat df = <span class="keyword">new</span> DecimalFormat( <span class="string">"0.000000 "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * 构造并初始化增广Hilbert矩阵，解向量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hilbert2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        N = n;</span><br><span class="line">        HilbertMatrix = <span class="keyword">new</span> <span class="keyword">double</span>[n][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//Hilbert增广矩阵构造</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                HilbertMatrix[i][j] = <span class="number">1</span>/(<span class="keyword">double</span>)(i + j + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        result = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            result[i] = <span class="number">0</span>;</span><br><span class="line">            HilbertMatrix[i][n] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增广矩阵按行进行Gauss消元</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">factorization</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//按行进行消元</span></span><br><span class="line">        <span class="keyword">for</span>(; i &lt; N - <span class="number">1</span>; i++, j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; N; k ++)&#123;</span><br><span class="line">                <span class="comment">//获取行间商</span></span><br><span class="line">                <span class="keyword">double</span> Quotient = HilbertMatrix[k][i] / HilbertMatrix[i][i];</span><br><span class="line">                <span class="keyword">if</span>(Quotient == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//首位置0</span></span><br><span class="line">                HilbertMatrix[k][i] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//更新行</span></span><br><span class="line">                <span class="keyword">if</span>(Quotient != <span class="number">0</span>)</span><br><span class="line">                    updateRaw(Quotient, k, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按行更新增广Hilbert矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> quotient 两行之间比例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row 当前待更新的行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> column 待更新的行的第一个元素所在列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateRaw</span><span class="params">(<span class="keyword">double</span> quotient, <span class="keyword">int</span> row, <span class="keyword">int</span> column)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(; column &lt; N + <span class="number">1</span>; column ++)</span><br><span class="line">            HilbertMatrix[row][column] = HilbertMatrix[row][column] - quotient * HilbertMatrix[row - <span class="number">1</span>][column];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 直接逆序按行遍历增广矩阵，利用部分和化为1元1次方程组求解x</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> partSum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//利用Hx = b求解x</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            partSum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//已知解计算的部分和，全部转化为一元一次方程求解</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = N - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                partSum = partSum + result[j] * HilbertMatrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            result[i] = (HilbertMatrix[i][N] - partSum) / HilbertMatrix[i][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出解向量结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">            System.out.println(df.format(result[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出矩阵结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMatrix</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N + <span class="number">1</span>; j++)</span><br><span class="line">                System.out.print(df.format(HilbertMatrix[i][j]) + <span class="string">" "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">n=2的Hilbert矩阵利用LU分解求解：</span><br><span class="line">-2.000000 6.000000 </span><br><span class="line">利用增广矩阵Gauss消元求解：</span><br><span class="line">-2.000000 6.000000 </span><br><span class="line"></span><br><span class="line">n=5的Hilbert矩阵利用LU分解求解：</span><br><span class="line">0.952791 14.555663 -41.248891 -66.171944 115.309973 </span><br><span class="line">利用增广矩阵Gauss消元求解：</span><br><span class="line">-0.232735 -0.694776 0.300523 -4.744569 13.330457 </span><br><span class="line"></span><br><span class="line">n=10的Hilbert矩阵利用LU分解求解：</span><br><span class="line">-88362050531657580000.000000 -257825283170962300000.000000 105691493935800520000.000000 321443398219438100000.000000 -21707058806388433000.000000 -42134045878669104.000000 -95851220811.950450 -156349522621727060000000.000000 443697662848130800000000.000000 -296500182100434630000000.000000 </span><br><span class="line">利用增广矩阵Gauss消元求解：</span><br><span class="line">-0.200823 -0.609366 0.269812 0.836271 -0.055616 -0.000107 0.000000 7.555673 9.658641 -8.000000</span><br></pre></td></tr></table></figure><h2 id="2-7-Jacobi迭代与GS迭代"><a href="#2-7-Jacobi迭代与GS迭代" class="headerlink" title="2.7 Jacobi迭代与GS迭代"></a>2.7 Jacobi迭代与GS迭代</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.abs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jacobi_GS</span> </span>&#123;</span><br><span class="line">    <span class="comment">//系数矩阵阶数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="comment">//迭代计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> iterationNum;</span><br><span class="line">    <span class="comment">//系数矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[][] Matrix;</span><br><span class="line">    <span class="comment">//常数向量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] b;</span><br><span class="line">    <span class="comment">//解向量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] result;</span><br><span class="line">    <span class="keyword">private</span> DecimalFormat df = <span class="keyword">new</span> DecimalFormat( <span class="string">"0.000000 "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造并初始化严格对角占优矩阵，解向量，常数向量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 严格对角占优矩阵阶数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Jacobi_GS</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        N = n;</span><br><span class="line">        Matrix = <span class="keyword">new</span> <span class="keyword">double</span>[n][n];</span><br><span class="line">        b = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">        result = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">        <span class="comment">//构造并初始化严格对角占优矩阵，解向量，常数向量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                Matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result[i] = <span class="number">0</span>;</span><br><span class="line">            b[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//严格对角占优矩阵，常数向量赋值</span></span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">        b[n - <span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        Matrix[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">        Matrix[<span class="number">0</span>][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        Matrix[n - <span class="number">1</span>][n - <span class="number">2</span>] = -<span class="number">1</span>;</span><br><span class="line">        Matrix[n - <span class="number">1</span>][n - <span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">                Matrix[i][i] = <span class="number">3</span>;</span><br><span class="line">                Matrix[i][i - <span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">                Matrix[i][i + <span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        iterationNum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行Jacobi n次迭代</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Jacobi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (getJacobi())</span><br><span class="line">            iterationNum ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行Jacobi迭代获取解向量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">getJacobi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为Jacobi迭代完成一次迭代后才更新x，利用temp数组暂存更新的x</span></span><br><span class="line">        <span class="keyword">double</span>[] temp = <span class="keyword">new</span> <span class="keyword">double</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)&#123;</span><br><span class="line">            <span class="comment">//计算系数矩阵当前行与解向量乘积的部分和</span></span><br><span class="line">            <span class="keyword">double</span> partSum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j ++)</span><br><span class="line">                partSum = partSum + Matrix[i][j] * result[j];</span><br><span class="line">            <span class="comment">//将对角元素排除</span></span><br><span class="line">            partSum = partSum - Matrix[i][i] * result[i];</span><br><span class="line">            temp[i] = <span class="number">1</span> / Matrix[i][i] * (b[i] - partSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断解向量精度</span></span><br><span class="line">        <span class="keyword">boolean</span> ret = judgeResult(temp);</span><br><span class="line">        <span class="comment">//更新解向量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">            result[i] = temp[i];</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行GS n次迭代</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GS</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (getGS())</span><br><span class="line">            iterationNum ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行GS迭代获取解向量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Boolean <span class="title">getGS</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] temp = <span class="keyword">new</span> <span class="keyword">double</span>[N];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">            temp[i] = result[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)&#123;</span><br><span class="line">            <span class="comment">//计算系数矩阵当前行与解向量乘积的部分和</span></span><br><span class="line">            <span class="keyword">double</span> partSum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j ++)</span><br><span class="line">                partSum = partSum + Matrix[i][j] * result[j];</span><br><span class="line">            <span class="comment">//将对角元素排除</span></span><br><span class="line">            partSum = partSum - Matrix[i][i] * result[i];</span><br><span class="line">            result[i] = <span class="number">1</span> / Matrix[i][i] * (b[i] - partSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断解向量精度</span></span><br><span class="line">        <span class="keyword">boolean</span> ret = judgeResult(temp);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较两次迭代解之间的变化量，当解向量的变化量小于1.0E-6时停止迭代</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp Jacobi迭代的第i次迭代解向量，GS迭代的第i-1次迭代向量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 不满足精度，返回true，迭代继续，满足返回false，结束迭代</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judgeResult</span><span class="params">(<span class="keyword">double</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">            <span class="keyword">if</span>(abs(temp[i] - result[i]) &gt; <span class="number">1.0E-6</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出对角占优矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMatrix</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">                System.out.print(df.format(Matrix[i][j]));</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出解向量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++)</span><br><span class="line">            System.out.print(df.format(result[i]));</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIterationNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterationNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">精度为0.000001</span><br><span class="line"></span><br><span class="line">n = 10时，Jacobi迭代的解为：</span><br><span class="line">1.000000 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 1.000000 </span><br><span class="line">n = 10时，Jacobi迭代的次数：</span><br><span class="line">30</span><br><span class="line"></span><br><span class="line">n = 20时，Jacobi迭代的解为：</span><br><span class="line">1.000000 1.000000 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 1.000000 1.000000 </span><br><span class="line">n = 20时，Jacobi迭代的次数：</span><br><span class="line">32</span><br><span class="line"></span><br><span class="line">n = 30时，Jacobi迭代的解为：</span><br><span class="line">1.000000 1.000000 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 1.000000 1.000000 </span><br><span class="line">n = 30时，Jacobi迭代的次数：</span><br><span class="line">32</span><br><span class="line"></span><br><span class="line">n = 50时，Jacobi迭代的解为：</span><br><span class="line">1.000000 1.000000 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 1.000000 1.000000 </span><br><span class="line">n = 50时，Jacobi迭代的次数：</span><br><span class="line">32</span><br><span class="line"></span><br><span class="line">n = 100时，Jacobi迭代的解为：</span><br><span class="line">1.000000 1.000000 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999998 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 1.000000 1.000000 </span><br><span class="line">n = 100时，Jacobi迭代的次数：</span><br><span class="line">32</span><br><span class="line"></span><br><span class="line">n = 10时，GS迭代的解为：</span><br><span class="line">1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 </span><br><span class="line">n = 10时，GS迭代的次数：</span><br><span class="line">18</span><br><span class="line"></span><br><span class="line">n = 20时，GS迭代的解为：</span><br><span class="line">1.000000 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 </span><br><span class="line">n = 20时，GS迭代的次数：</span><br><span class="line">19</span><br><span class="line"></span><br><span class="line">n = 30时，GS迭代的解为：</span><br><span class="line">1.000000 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 </span><br><span class="line">n = 30时，GS迭代的次数：</span><br><span class="line">19</span><br><span class="line"></span><br><span class="line">n = 30时，GS迭代的解为：</span><br><span class="line">1.000000 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 </span><br><span class="line">n = 30时，GS迭代的次数：</span><br><span class="line">19</span><br><span class="line"></span><br><span class="line">n = 100时，GS迭代的解为：</span><br><span class="line">1.000000 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 0.999999 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 1.000000 </span><br><span class="line">n = 100时，GS迭代的次数：</span><br><span class="line">19</span><br></pre></td></tr></table></figure><h2 id="3-1-Newton迭代法和割线法"><a href="#3-1-Newton迭代法和割线法" class="headerlink" title="3.1 Newton迭代法和割线法"></a>3.1 Newton迭代法和割线法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Newton_Secant</span> </span>&#123;</span><br><span class="line">    <span class="comment">//非线性方程组系数向量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] coefficientArr;</span><br><span class="line">    <span class="comment">//非线性方程组最大幂次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxPower;</span><br><span class="line">    <span class="comment">//迭代计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> iterationNum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mp 多项式最高项系数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Newton_Secant</span><span class="params">(<span class="keyword">int</span> mp)</span></span>&#123;</span><br><span class="line">        maxPower = mp;</span><br><span class="line">        coefficientArr = <span class="keyword">new</span> <span class="keyword">double</span>[mp + <span class="number">1</span>];</span><br><span class="line">        iterationNum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输入系数向量，从低次到高次</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coefficientArr 系数向量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCoefficientArr</span><span class="params">(<span class="keyword">double</span>[] coefficientArr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coefficientArr = coefficientArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非线性方程组获取Newton迭代法的f(x)部分</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 当前x的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> f(x)的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getFx</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxPower; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(coefficientArr[i] != <span class="number">0</span>)</span><br><span class="line">                result = result + pow(x, i) * coefficientArr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非线性方程组获取Newton迭代法的f'(x)部分</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 当前x的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> f‘(x)的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">getdF</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxPower; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(coefficientArr[i] != <span class="number">0</span>)</span><br><span class="line">                result = result + i * pow(x, i - <span class="number">1</span>) * coefficientArr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用Newton法求非线性方程组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 初始x值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Newton法迭代后获取的x值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Newton</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x1 = x - getFx(x) / getdF(x);</span><br><span class="line">        iterationNum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (abs(x1 - x) &gt; <span class="number">1.0E-6</span>)&#123;</span><br><span class="line">            x = x1;</span><br><span class="line">            x1 = x - getFx(x) / getdF(x);</span><br><span class="line">            iterationNum ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用割线法求非线性方程组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x0 初始x0的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x1 初值x1的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 割线法迭代后获取的x值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">secantMethod</span><span class="params">(<span class="keyword">double</span> x0, <span class="keyword">double</span> x1)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x2 = x1 - getFx(x1) / (getFx(x1) - getFx(x0)) * (x1 - x0);</span><br><span class="line">        iterationNum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (abs(x2 - x1) &gt; <span class="number">1.0E-6</span>)&#123;</span><br><span class="line">            x0 = x1;</span><br><span class="line">            x1 = x2;</span><br><span class="line">            x2 = x1 - getFx(x1) / (getFx(x1) - getFx(x0)) * (x1 - x0);</span><br><span class="line">            iterationNum ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * e^xsinx利用Newton法求解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 初始x值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Newton法迭代后获取的x值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">expSin_Newton</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x1 = x - (exp(x) * sin(x)) / (exp(x) * (sin(x) + cos(x)));</span><br><span class="line">        iterationNum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (abs(x1 - x) &gt; <span class="number">1.0E-6</span>)&#123;</span><br><span class="line">            x = x1;</span><br><span class="line">            x1 = x - (exp(x) * sin(x)) / (exp(x) * (sin(x) + cos(x)));</span><br><span class="line">            iterationNum ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * e^xsinx利用割线法求解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x0 初始x0的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x1 初值x1的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 割线法迭代后获取的x值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">expsin_SecantMethod</span><span class="params">(<span class="keyword">double</span> x0, <span class="keyword">double</span> x1)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x2 = x1 - (exp(x1) * sin(x1)) / (exp(x1) * sin(x1) - exp(x0) * sin(x0)) * (x1 - x0);</span><br><span class="line">        iterationNum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (abs(x2 - x1) &gt; <span class="number">1.0E-6</span>)&#123;</span><br><span class="line">            x0 = x1;</span><br><span class="line">            x1 = x2;</span><br><span class="line">            x2 = x1 - (exp(x1) * sin(x1)) / (exp(x1) * sin(x1) - exp(x0) * sin(x0)) * (x1 - x0);</span><br><span class="line">            iterationNum ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIterationNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterationNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">非线性方程组2x^3-5x+1=0 在[1,2]上的根</span><br><span class="line"></span><br><span class="line">Newton迭代法求解：</span><br><span class="line">1.469617  </span><br><span class="line">迭代次数：</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">割线法迭代法求解：</span><br><span class="line">1.469617 </span><br><span class="line">迭代次数：</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">e^xsinx=0 在[-4,-3]上的根</span><br><span class="line"></span><br><span class="line">Newton迭代法求解：</span><br><span class="line">-3.141593 </span><br><span class="line">迭代次数：</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">割线法迭代法求解：</span><br><span class="line">-3.141593 </span><br><span class="line">迭代次数：</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="3-4-Newton迭代法"><a href="#3-4-Newton迭代法" class="headerlink" title="3.4 Newton迭代法"></a>3.4 Newton迭代法</h2><p><strong>在3.1题中加入下述方法即可</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非线性方程，自定义迭代次数Newton迭代法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 初始x值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 迭代次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Newton法迭代后获取的x值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Newton</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">            x = x - getFx(x) / getdF(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h3><table><thead><tr><th align="center">$i$</th><th align="center">$x_i$</th><th align="center">$e_i=|x_i-x^{*}|$</th><th align="center">$\dfrac{e_i}{e_{i-1}^2}$</th></tr></thead><tbody><tr><td align="center">$0$</td><td align="center">$-0.7$</td><td align="center">$1.7$</td><td align="center"></td></tr><tr><td align="center">$1$</td><td align="center">$2.620561$</td><td align="center">$1.620561$</td><td align="center">$0.560748$</td></tr><tr><td align="center">$2$</td><td align="center">$1.708440$</td><td align="center">$0.708440$</td><td align="center">$0.269757$</td></tr><tr><td align="center">$3$</td><td align="center">$1.206379$</td><td align="center">$0.206379$</td><td align="center">$0.411205$</td></tr><tr><td align="center">$4$</td><td align="center">$1.024162$</td><td align="center">$0.024162$</td><td align="center">$0.567280$</td></tr><tr><td align="center">$5$</td><td align="center">$1.000381$</td><td align="center">$0.000381$</td><td align="center">$0.653478$</td></tr><tr><td align="center">$6$</td><td align="center">$1.000000$</td><td align="center">$0.000000$</td><td align="center">$0.666455$</td></tr><tr><td align="center">$7$</td><td align="center">$1.000000$</td><td align="center">$0.000000$</td><td align="center">$0.660875$</td></tr></tbody></table>$\dfrac{f''(x^{*})}{2f'(x^{*})}=\dfrac{1}{3}=0.666667$<p>越来越接近</p><h2 id="4-7-三次样条插值"><a href="#4-7-三次样条插值" class="headerlink" title="4.7 三次样条插值"></a>4.7 三次样条插值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.pow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CubicSplineInterpolation</span> </span>&#123;</span><br><span class="line">    <span class="comment">//三次样条提供的点数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="comment">//三次样条提供的点的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] pointArr;</span><br><span class="line">    <span class="comment">//三次样条提供的点对应的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] sArr;</span><br><span class="line">    <span class="comment">//严格对角占优系数矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[][] Matrix;</span><br><span class="line">    <span class="comment">//L阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[][] L_Matrix;</span><br><span class="line">    <span class="comment">//U阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[][] U_Matrix;</span><br><span class="line">    <span class="comment">//g向量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] g;</span><br><span class="line">    <span class="comment">//Ux = y解出的x解向量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] result_x;</span><br><span class="line">    <span class="comment">//Ly = b解出的y解向量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] result_y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DecimalFormat df = <span class="keyword">new</span> DecimalFormat( <span class="string">"0.000000 "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * 初始化各种矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 三次样条提供的点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CubicSplineInterpolation(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        N = n;</span><br><span class="line">        Matrix = <span class="keyword">new</span> <span class="keyword">double</span>[n][n];</span><br><span class="line">        L_Matrix = <span class="keyword">new</span> <span class="keyword">double</span>[n][n];</span><br><span class="line">        U_Matrix = <span class="keyword">new</span> <span class="keyword">double</span>[n][n];</span><br><span class="line">        result_x = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">        result_y = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">        g = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            g[i] = <span class="number">0</span>;</span><br><span class="line">            result_y[i] = <span class="number">0</span>;</span><br><span class="line">            result_x[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i != j) &#123;</span><br><span class="line">                    Matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                    L_Matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                    U_Matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Matrix[i][j] = <span class="number">2</span>;</span><br><span class="line">                    L_Matrix[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//已知题目为第二边界条件</span></span><br><span class="line">        Matrix[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        Matrix[n - <span class="number">1</span>][n - <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算lambda和mu，生成严格对角占优矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMatrix</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pointArr.length != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">                Matrix[i][i - <span class="number">1</span>] = (pointArr[i + <span class="number">1</span>] - pointArr[i]) / ((pointArr[i + <span class="number">1</span>] - pointArr[i]) + (pointArr[i] - pointArr[i - <span class="number">1</span>]));</span><br><span class="line">                Matrix[i][i + <span class="number">1</span>] = <span class="number">1</span> - Matrix[i][i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对严格对角占优矩阵进行LU分解</span></span><br><span class="line"><span class="comment">     * 更新LU矩阵，更新初始严格对角占优矩阵将其化为上三角矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LU_Factorization</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化L矩阵对角元</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//按行进行消元</span></span><br><span class="line">        <span class="keyword">for</span>(; i &lt; N - <span class="number">1</span>; i++, j++)&#123;</span><br><span class="line">            <span class="comment">//Hilbert矩阵不需要进行列主元消元</span></span><br><span class="line">            <span class="comment">//更新U矩阵第i行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; N; k ++)</span><br><span class="line">                U_Matrix[i][k] = Matrix[i][k];</span><br><span class="line">            <span class="comment">//更新L矩阵第i列</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; N; k ++)&#123;</span><br><span class="line">                <span class="comment">//获取行间商</span></span><br><span class="line">                <span class="keyword">double</span> Quotient = Matrix[k][i] / Matrix[i][i];</span><br><span class="line">                <span class="keyword">if</span>(Quotient == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//首位置0</span></span><br><span class="line">                Matrix[k][i] = <span class="number">0</span>;</span><br><span class="line">                L_Matrix[k][i] = Quotient;</span><br><span class="line">                <span class="comment">//更新行</span></span><br><span class="line">                <span class="keyword">if</span>(Quotient != <span class="number">0</span>)</span><br><span class="line">                    updateRaw(Quotient, k, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        U_Matrix[N - <span class="number">1</span>][N - <span class="number">1</span>] = Matrix[N - <span class="number">1</span>][N - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LU分解，更新严格对角占优矩阵的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> quotient 两行之间比例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row 当前待更新的行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> column 待更新的行的第一个元素所在列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateRaw</span><span class="params">(<span class="keyword">double</span> quotient, <span class="keyword">int</span> row, <span class="keyword">int</span> column)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(; column &lt; N; column ++)</span><br><span class="line">            Matrix[row][column] = Matrix[row][column] - quotient * Matrix[row - <span class="number">1</span>][column];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据边界条件值（此处为第二边界条件），计算常数向量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> f0 第一个点处二阶导函数值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fn 第n个点处二阶导函数值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBoundaryArr</span><span class="params">(<span class="keyword">double</span> f0, <span class="keyword">double</span> fn)</span></span>&#123;</span><br><span class="line">        g[<span class="number">0</span>] = <span class="number">3</span> * (sArr[<span class="number">1</span>] - sArr[<span class="number">0</span>]) / (pointArr[<span class="number">1</span>] - pointArr[<span class="number">0</span>]) - (pointArr[<span class="number">1</span>] - pointArr[<span class="number">0</span>]) / <span class="number">2</span> * f0;</span><br><span class="line">        g[N - <span class="number">1</span>] = <span class="number">3</span> * (sArr[N - <span class="number">1</span>] - sArr[N - <span class="number">2</span>]) / (pointArr[N - <span class="number">1</span>] - pointArr[N - <span class="number">2</span>]) - (pointArr[N - <span class="number">1</span>] - pointArr[N - <span class="number">2</span>]) / <span class="number">2</span> * f0;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N - <span class="number">1</span>; i ++)</span><br><span class="line">            g[i] = <span class="number">3</span> * (Matrix[i][i + <span class="number">1</span>] * (sArr[i + <span class="number">1</span>] - sArr[i]) / (pointArr[i + <span class="number">1</span>] - pointArr[i]) +</span><br><span class="line">                    Matrix[i][i - <span class="number">1</span>] * (sArr[i] - sArr[i - <span class="number">1</span>]) / (pointArr[i] - pointArr[i - <span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算解向量</span></span><br><span class="line"><span class="comment">     * 先根据Ly=b，计算y，正序遍历，利用部分和化为1元1次方程组求y</span></span><br><span class="line"><span class="comment">     * 再根据Ux=y，计算x，逆序遍历，同理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> partSum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//利用Ly = b求解y</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i ++) &#123;</span><br><span class="line">            partSum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//已知解计算的部分和，全部转化为一元一次方程求解</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                partSum = partSum + result_y[j] * L_Matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            result_y[i] = (g[i] - partSum) / L_Matrix[i][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//利用Ux = y求解x</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            partSum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//已知解计算的部分和，全部转化为一元一次方程求解</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = N - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                partSum = partSum + result_x[j] * U_Matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            result_x[i] = (result_y[i] - partSum) / U_Matrix[i][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPointArr</span><span class="params">(<span class="keyword">double</span>[] pointArr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pointArr = pointArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setsArr</span><span class="params">(<span class="keyword">double</span>[] sArr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sArr = sArr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果-5"><a href="#结果-5" class="headerlink" title="结果"></a>结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">区间[0,1]的方程为：1.0 * (x - 1.0)^2 + 4.660714  * (x - 0.0)(x 1.0)^2 + 3.0 * (x - 0.0)^2 - 6.678571  * (x - 1.0)(x 0.0)^2</span><br><span class="line">区间[1,2]的方程为：3.0 * (x - 2.0)^2 + 6.678571  * (x - 1.0)(x 2.0)^2 + 3.0 * (x - 1.0)^2 - 6.625000  * (x - 2.0)(x 1.0)^2</span><br><span class="line">区间[2,3]的方程为：3.0 * (x - 3.0)^2 + 6.625000  * (x - 2.0)(x 3.0)^2 + 4.0 * (x - 2.0)^2 - 7.821429  * (x - 3.0)(x 2.0)^2</span><br><span class="line">区间[3,4]的方程为：4.0 * (x - 4.0)^2 + 7.821429  * (x - 3.0)(x 4.0)^2 + 2.0 * (x - 3.0)^2 - 1.089286  * (x - 4.0)(x 3.0)^2</span><br></pre></td></tr></table></figure><h2 id="5-1-复化梯形与Simpson"><a href="#5-1-复化梯形与Simpson" class="headerlink" title="5.1 复化梯形与Simpson"></a>5.1 复化梯形与Simpson</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trapezoid_Simpson</span> </span>&#123;</span><br><span class="line">    <span class="comment">//区间数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trapezoid_Simpson</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        N = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用复化梯形求解e^3*cos(PI*x)在[a,b]上的积分</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> begin 起始值a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end 终止值b</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 积分解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTrapezoid</span><span class="params">(<span class="keyword">double</span> begin, <span class="keyword">double</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = exp(<span class="number">3</span> * begin) * cos(PI * begin);</span><br><span class="line">        <span class="keyword">double</span> h = (end - begin) / N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">            result = result + <span class="number">2</span> * exp(<span class="number">3</span> * i * h) * cos(PI * i * h);</span><br><span class="line">        &#125;</span><br><span class="line">        result = result + exp(<span class="number">3</span> * end) * cos(PI * end);</span><br><span class="line">        result = result * h / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用Simpson求解e^3*cos(PI*x)在[a,b]上的积分</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> begin 起始值a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end 终止值b</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 积分解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSimpson</span><span class="params">(<span class="keyword">double</span> begin, <span class="keyword">double</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = exp(<span class="number">3</span> * begin) * cos(PI * begin) + exp(<span class="number">3</span> * end) * cos(PI * end);</span><br><span class="line">        <span class="keyword">double</span> h = (end - begin) / N;</span><br><span class="line">        result = result + <span class="number">4</span> * exp(<span class="number">3</span> * begin + h / <span class="number">2</span>) * cos(PI * (begin + h / <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">            result = result + <span class="number">2</span> * exp(<span class="number">3</span> * i * h) * cos(PI * i * h) + <span class="number">4</span> * exp(<span class="number">3</span> * i * h + h / <span class="number">2</span>) * cos(PI * (i * h + h / <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        result = result * h / <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>精确值为：</p><p>$\dfrac{1}{9+\pi^2}(3\cos\pi xe^{3x}|_0^{\frac{\pi}{2}}+\pi\sin \pi xe^{3x}|_0^{\frac{\pi}{2}}) = -14.331840$</p><table><thead><tr><th align="center">区间大小</th><th align="center">复化梯形求解</th><th align="center">复化梯形误差</th><th align="center">Simpson求解</th><th align="center">Simpson误差</th></tr></thead><tbody><tr><td align="center">$50$</td><td align="center">$-14.690719$</td><td align="center">$0.358879$</td><td align="center">$-14.538056$</td><td align="center">$0.206216$</td></tr><tr><td align="center">$100$</td><td align="center">$-14.610622$</td><td align="center">$0.278782$</td><td align="center">$-14.498825$</td><td align="center">$0.166985$</td></tr><tr><td align="center">$200$</td><td align="center">$-14.497480$</td><td align="center">$0.165640$</td><td align="center">$-14.432189$</td><td align="center">$0.100349$</td></tr><tr><td align="center">$500$</td><td align="center">$-14.404580$</td><td align="center">$0.072740$</td><td align="center">$-14.376141$</td><td align="center">$0.044301$</td></tr><tr><td align="center">$1000$</td><td align="center">$-14.369306$</td><td align="center">$0.037466$</td><td align="center">$-14.354694$</td><td align="center">$0.022854$</td></tr></tbody></table><p><strong>由表可知，误差收敛</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;计算方法部分方法代码实现&lt;/br&gt;Java实现&lt;/center&gt;
    
    </summary>
    
    
      <category term="Course" scheme="http://yoursite.com/categories/Course/"/>
    
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Course" scheme="http://yoursite.com/tags/Course/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>计算方法知识点（5-7）</title>
    <link href="http://yoursite.com/2019/12/01/ComputationalMethods1/"/>
    <id>http://yoursite.com/2019/12/01/ComputationalMethods1/</id>
    <published>2019-12-01T13:40:08.000Z</published>
    <updated>2019-12-28T04:22:27.952Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="插值与逼近"><a href="#插值与逼近" class="headerlink" title="插值与逼近"></a>插值与逼近</h1><h2 id="插值问题"><a href="#插值问题" class="headerlink" title="插值问题"></a>插值问题</h2><p><strong>定义5.1</strong> 设 $\varphi_1(x),\varphi_2(x)，\cdots,\varphi_n(x)$是$[a,b]$上的连续函数，并且对$[a,b]$上的任意$n$个互异点$x_1,x_2,\cdots,x_n$，行列式</p>$\begin{equation}\begin{aligned} D[x_1,x_2,\cdots,x_n] =\left |\begin{array}{cccc}\varphi_1(x_1)&\varphi_2(x_1)&\cdots&\varphi_n(x_1)\\\varphi_1(x_2)&\varphi_2(x_2)&\cdots&\varphi_n(x_2)\\\vdots&\vdots&\ddots&\vdots\\\varphi_1(x_n)&\varphi_2(x_n)&\cdots&\varphi_n(x_n)\end{array}\right|\not=0\\\end{aligned}\end{equation}$<p>则称$\varphi_1(x),\varphi_2(x)，\cdots,\varphi_n(x)   $在$[a,b]$上满足$Haar$条件</p><p><strong>注：不是任何线性无关的连续函数都满足$Haar$条件</strong></p><p><strong>定理5.1</strong> 设已知函数$f(x)$在$n$个互异点$x_1,x_2,\cdots,x_n$处的函数值$y_1,y_2,\cdots,y_n$，即$y_i=f(x_i)\quad (i=1,2,\cdots,n)$。又设$S$的基底函数$\varphi_1(x),\varphi_2(x)，\cdots,\varphi_n(x)$在$[a,b]$上满足$Haar$条件，则存在唯一的函数$p(x)=\sum\limits_{k=1}^nc_k\varphi_k(x)\in S$，满足插值条件$p(x_i)=y_i\quad i=1,2,\cdots,n$ </p><p>证明：根据插值条件$p(x)=\sum\limits_{k=1}^nc_k\varphi_k(x)=y_i\quad i=1,2,\cdots,n$可得线性方程组</p>$\begin{equation}\begin{aligned}\begin{bmatrix}\varphi_1(x_1)&\varphi_2(x_1)&\cdots&\varphi_n(x_1)\\\varphi_1(x_2)&\varphi_2(x_2)&\cdots&\varphi_n(x_2)\\\vdots&\vdots&\ddots&\vdots\\\varphi_1(x_n)&\varphi_2(x_n)&\cdots&\varphi_n(x_n)\end{bmatrix}\begin{bmatrix}c_1\\c_2\\\vdots\\c_n\end{bmatrix}=\begin{bmatrix}y_1\\y_2\\\vdots\\y_n\end{bmatrix}\end{aligned}\end{equation}$<p>当其系数矩阵满足$Haar$条件时，解存在且唯一</p><p><strong>推论5.1</strong> 在<strong>定理5.1</strong>的假设下，S中存在唯一的一组线性无关函数<br>$l_k(x)\quad (k=1,2,\cdots,n)$<br>且$\begin{equation}\begin{aligned}l_k(x_i)=\begin{cases}1\quad i=k\\0\quad i\not=k\end{cases}\quad k =1,2,\cdots,n;i=1,2,\cdots,n\end{aligned}\end{equation}$</p><p>所以$[x_1,x_2,\cdots,x_n]$为单位阵，其行列式不为0，即$l_1,l_2,\cdots,l_n$在$[a,b]$上满足$Haar$条件，称其为<strong>插值基函数</strong>，其也是$S$的一组基底函数</p><p><strong>推论5.2</strong> 在<strong>定理5.1</strong>的假设下，函数$p(x)=\sum\limits_{k=1}^ny_kl_k(x)$是$S$中满足插值条件$p(x_i)=y_i\quad i=1,2,\cdots,n$的唯一函数</p><h2 id="Lagrange插值公式"><a href="#Lagrange插值公式" class="headerlink" title="Lagrange插值公式"></a>Lagrange插值公式</h2><p>通常把$x_0&lt;x_1&lt;\cdots&lt;x_{n-1}&lt;x_n$称为<strong>插值节点</strong></p><p>$p_n(x)$称为$f(x)$的<strong>插值多项式（函数）</strong></p><p>$f(x)$称为<strong>被插函数</strong>，$[a,b]$称为<strong>插值区间</strong></p><p>$p_n(x_i)=y_i\quad i=1,2,\cdots,n$称为<strong>插值条件</strong>，求$p_n(x)$的过程称为<strong>插值法</strong></p><p><strong>$Lagrange$插值问题</strong></p><p>给定$f(x)$在区间$[a,b]$上$n+1$个互异点$a&lt;x_0&lt;x_1&lt;\cdots&lt;x_n&lt;b$及函数值$y_1,y_2,\cdots,y_n$，构造次数不超过$n$的实系数代数多项式$p_n(x)$，使之满足插值条件$p_n(x_i)=f(x_i)=y_i\quad i=0,1,2,\cdots,n$，此类插值问题称为<strong>$Lagrange$插值问题</strong>，即不带导数的插值问题</p><p>注意</p><ul><li>插值基函数的个数=插值节点个数</li><li>插值基函数的次数=插值节点的个数-1</li><li>插值基函数决定着插值多项式满足插值条件</li><li>插值基函数与插值节点的次序无关</li></ul><p>设$x_0,x_1,\cdots,x_n$是$[a,b]$上的$n+1$个互异点，取<br>$l_j(x)=\dfrac{(x-x_0)\cdots(x-x_{j-1})(x-x_{j+1})\cdots(x-x_n)}{(x_j-x_0)\cdots(x_j-x_{j-1})(x_j-x_{j+1})\cdots(x_j-x_n)}=\dfrac{\omega_{n+1}(x)}{(x-x_j)\omega’(x_j)}$<br>$j=0,1,\cdots,n$ </p><p>其中$\omega_{n+1}(x)=(x-x_0)(x-x_1)\cdots(x-x_n)$</p><p>有$\begin{equation}\begin{aligned}l_j(x_i)=\begin{cases}1\quad i=j\\0\quad i\not=j\end{cases} \quad i,j=0,1,\cdots,n\end{aligned}\end{equation}$</p><p>$l_j(x_i)(j=0,1,\cdots,n)$称为<strong>$n$次Lagrange插值基函数</strong>。从而$p_n(x)=\sum\limits_{i=0}^ny_i\cdot l_i(x)$就是多项式空间$P_n(x)$中满足插值条件的唯一多项式$p_n(x)$称为<strong>$n$次Lagrange插值多项式</strong></p><h2 id="Newton插值公式"><a href="#Newton插值公式" class="headerlink" title="Newton插值公式"></a>Newton插值公式</h2><p><strong>定义5.2</strong> 设函数$f(x)$在互异的节点$x_0,x_1,\cdots,x_n$上的函数值为$f_0,f_1,\cdots,f_n$，称</p><p>$f[x_0,x_1,\cdots,x_k]=\dfrac{f[x_0,\cdots,x_{i-1},x_{i+1},\cdots,x_k]-f[x_0,\cdots,x_{j-1},x_{j+1},\cdots,x_k]}{x_i-x_j}\quad i\not=j$</p><p>为$f(x)$关于$x_0,x_1,\cdots,x_n$的<strong>$k$阶均差（差商）</strong></p><p><strong>均差的性质</strong></p><ul><li>$f[x_0,x_1,\cdots,x_k]=\sum\limits_{j=0}^k \dfrac{f(x_j)}{\omega'_{k+1}(x_j)}$    <p>  其中$\omega_{k+1}(x)=(x-x_0)(x-x_1)\cdots(x-x_k)$</p></li><li><p>对称性，即在$f[x_0,x_1,\cdots,x_k]$中任意调换$x_0,x_1,\cdots,x_k$的位置时，均差的值不变</p></li><li><p>若$f(x)=x^m$，$m$为自然数，则</p>$\begin{equation}  \begin{aligned}f[x_0,x_1,\cdots,x_k]=\begin{cases}0\quad k>m\\1\quad k=m\\\dfrac{m(m-1)\cdots(m-k+1)x^{m-k}}{k!}\quad k < m\end{cases}\end{aligned}  \end{equation}$</li><li><p>设$f(x)$在包含$x_0,x_1,\cdots,x_n$的区间$(a,b)$内$k$次可微，则</p></li><li><p>$f[x_0,x_1,\cdots,x_n]=\dfrac{f^{(k)}(\xi)}{k!}\quad min(x_0,x_1,\cdots,x_n)&lt;\xi&lt;max(x_0,x_1,\cdots,x_n)$</p></li></ul><p><strong>$Newton$插值公式</strong> </p>$\begin{equation}\begin{aligned}p_n(x)&=f(x_0)+f[x_0,x_1](x-x_0)+f[x_0,x_1,x_2](x-x_0)(x-x_1)\\&+\cdots+f[x_0,x_1,\cdots,x_n](x-x_0)(x-x_1)\cdots(x-x_n)\\&=p_{n-1}(x)+f[x_0,x_1,\cdots,x_n](x-x_0)(x-x_1)\end{aligned}\end{equation}$<p>为便于计算，利用<strong>均差表</strong></p><table><thead><tr><th align="center">$x$</th><th align="center">$f(x)$</th><th align="center">一阶均差</th><th align="center">二阶均差</th><th align="center">三阶均差</th></tr></thead><tbody><tr><td align="center">$x_0$</td><td align="center"><font color="red">$f(x_0)$</font></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">$x_1$</td><td align="center">$f(x_1)$</td><td align="center"><font color="red">$f[x_0,x_1]$</font></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">$x_2$</td><td align="center">$f(x_2)$</td><td align="center">$f[x_1,x_2]$</td><td align="center"><font color="red">$f[x_0,x_1,x_2]$</font></td><td align="center"></td></tr><tr><td align="center">$x_3$</td><td align="center">$f(x_3)$</td><td align="center">$f[x_2,x_3]$</td><td align="center">$f[x_1,x_2,x_3]$</td><td align="center"><font color="red">$f[x_0,x_1,x_2,x_3]$</font></td></tr></tbody></table><h2 id="插值余项"><a href="#插值余项" class="headerlink" title="插值余项"></a>插值余项</h2><p><strong>定理5.2</strong> 若$f(x)$在包含着插值节点$x_0,x_1,\cdots,x_n$的区间$[a,b]$上$n+1$次可微，则对任意$x\in [a,b]$，存在与$x$有关的$\xi(a&lt;\xi&lt;b)$使得<br>$r_n(x)=f(x)-p_n(x)=\dfrac{f^{(n+1)}(\xi)}{(n+1)!}\omega_{n+1}(x)$</p><p>证明：任取$x\in[a,b]$，当$x=x_0,x_1,\cdots,x_n$时显然成立，设$x\not=x_i(i=0,1,\cdots,n)$，视$x$为一个节点，由一阶均差定义有$$\begin{equation}\begin{aligned}f(x)&=f(x_0)+f[x,x_0](x-x_0)\\&f[x,x_0]=f[x_0,x_1]+f[x,x_0,x_1](x-x_1)\\&f[x,x_0,x_1]=f[x_0,x_1,x_2]+f[x,x_0,x_1,x_2](x-x_2)\\&\cdots\end{aligned}\end{equation}$$进一步，当$k=1,2,\cdots,n$时</p>$f[x,x_0,\cdots,x_{k-1}]=f[x_0,x_1,\cdots,x_k]+f[x,x_0,x_1,\cdots,x_k](x-x_k)$<p>递推展开有：$$\begin{equation}\begin{aligned}f(x)&=f(x_0)+f[x,x_0](x-x_0)\\&=f(x_0)+\{f[x_0,x_1]+f[x,x_0,x_1](x-x_1)\}(x-x_0)\\&=f(x_0)+f[x_0,x_1](x-x_0)+f[x,x_0,x_1](x-x_0)(x-x_1)\\&=\cdots\\&=f(x_0)+f[x_0,x_1](x-x_0)+\cdots+f[x_0,\cdots,x_n](x-x_0)\cdots(x-x_{n-1})\\&\qquad + f[x,x_0,\cdots,x_n](x-x_0)\cdots(x-x_n)\\&=p_n(x)+f[x,x_0,\cdots,x_n](x-x_0)\cdots(x-x_n)\\\end{aligned}\end{equation}$$取余项</p>$\begin{equation}\begin{aligned}r_n(x)&=f(x)-p_n(x)\\&=f[x,x_0,\cdots,x_n](x-x_0)\cdots(x-x_n)\\&=f[x,x_0,\cdots,x_n]\omega_{n+1}(x)\\\end{aligned}\end{equation}$<p>根据<strong>均差性质4</strong>有</p><p>$r_n(x)=\dfrac{f^{(n+1)}(\xi)}{(n+1))!}\omega_{n+1}(x)\quad min(x_0,x_1,\cdots,x_n)&lt;\xi&lt;max(x_0,x_1,\cdots,x_n)$</p><p>特别的</p><p>$f[x_0,x_1]=f’(\xi_1),f[x_0,x_1,x_2]=\dfrac{f’’(\xi_2)}{2},\cdots,f[x_0,x_1,x_2,x_n]=\dfrac{f^{(n)}(\xi_n)}{n!}$</p><p>$Newton$插值公式可写为</p>$\begin{equation}\begin{aligned}p_n(x)&=f(x_0)+f'(\xi_1)(x-x_0)+\dfrac{f''(\xi_2)}{2}(x-x_0)(x-x_1)\\&\qquad + \cdots+\dfrac{f^{(n)}(\xi_n)}{n!}(x-x_0)(x-x_1)\cdots(x-x_n)\end{aligned}\end{equation}$<p>其中$min(x_0,x_1,\cdots,x_n)&lt;\xi_i&lt;max(x_0,x_1,\cdots,x_n)\quad i=1,2,\cdots,n$</p><p>若固定$x_0$，令$x_1,x_2,\cdots,x_n$一起趋近于$x_0$，则有</p>$\begin{equation}\begin{aligned}p_n(x)&=f(x_0)+f'(x_0)(x-x_0)+\dfrac{f''(x_0)}{2}(x-x_0)(x-x_1)\\&\qquad + \cdots+\dfrac{f^{(n)}(x_0)}{n!}(x-x_0)(x-x_1)\cdots(x-x_n)\end{aligned}\end{equation}$<p><strong>$Newton$插值公式的极限即为$f(x)$在$x=x_0$点处的$Taylor$级数的前$n+1$项和</strong></p><p>证明：$\sum\limits_{i=0}^nl_i(x)=1 \quad \sum\limits_{i=0}^nl_i(x)x_i^k=x^k\quad 0\le k \le n$</p><p>根据$Lagrange$插值公式$p_n(x)=\sum\limits_{i=0}^nl_i(x)f(x_i)$可知被插值函数应该为$f(x)=1$</p><p>根据插值余项公式<br>$f(x)-p_n(x)=1-\sum\limits_{i=0}^n l_i(x)=\dfrac{f(\xi)^{(n+1)}}{(n+1)!}\omega_{n+1}(x)=0\Rightarrow \sum\limits_{i=0}^nl_i(x)=1 $</p><p>同理，由插值余项公式</p><p>$x^k-\sum\limits_{i=0}^n l_i(x)x_i^k=\dfrac{(\xi^k)^{n+1}}{(n+1)!}\omega_{n+1}(x)=0\Rightarrow \sum\limits_{i=0}^nl_i(x)x_i^k=x^k $</p><p>那么，$\sum\limits_{i=0}^nl_i(0)x_i^k=0$</p><h2 id="Hermite插值"><a href="#Hermite插值" class="headerlink" title="Hermite插值"></a>Hermite插值</h2><p>插值节点处满足一定的<strong>导数条件</strong>，称为<strong>$Hermite$插值问题</strong><br>$Hermite$插值问题的一般提法是：</p><p>设已知函数$f(x)$在$s$个互异点$x_1,x_2,\cdots,x_s$处的函数值和导数值:$$\begin{equation}\begin{aligned}&f(x_1),f'(x_1),\cdots,f^{(\alpha_1-1)(x_1)}\\&f(x_2),f'(x_2),\cdots,f^{(\alpha_2-1)(x_2)}\\&\quad\vdots\qquad\vdots\qquad\qquad\qquad\vdots \\&f(x_s),f'(x_s),\cdots,f^{(\alpha_s-1)(x_s)}\\\end{aligned}\end{equation}$$其中$\alpha_1,\alpha_2,\cdots,\alpha_s$为正整数，记$\alpha_1+\alpha_2+\cdots+\alpha_s=n+1$，构造一个$n$次多项式$p_n(x)$，使其满足插值条件：</p><p>$p_n^{\mu_i}(x_i)=f^{\mu_i}(x_i)=y_i^{\mu_i}\quad i=1,2,\cdots,s\quad \mu_i=0,1,\cdots,\alpha_i-1$</p><p>可以采用类似构造$Lagrange$插值基函数$l_j(x)$的方法来解决$Hermite$插值问题。先构造<strong>一批</strong>$n$次多项式作为插值基函数，即</p><p>$L_{i,k}(x)\quad i=1,2,\cdots,s\quad k=0,1,\cdots,\alpha_i-1$</p><p>将$n$次插值多项式表示为如下形式：</p>$\begin{equation}\begin{aligned}p_n(x)&=\sum\limits_{i=1}^s\sum\limits_{k=0}^{\alpha_i-1}y_i^{(k)}L_{i,k}(x)\\&=\sum\limits_{i=1}^s[y_iL_{i,0}(x)+y'_iL_{i,1}(x)+\cdots+y_i^{(\alpha_i-1)}L_{i,\alpha_i-1}(x)]\end{aligned}\end{equation}$<p>且满足插值条件，这就要求使这批多项式满足如下条件</p>$$\begin{equation}\begin{aligned}&L_{i,k}^{(h)}(x_m)=0\quad m\not=i\quad h=0,1,\cdots,\alpha_m-1\\&L_{i,k}^{(h)}(x_i)=\begin{cases}0\quad h\not=k\\1\quad h=k\\\end{cases}\quad h,k=0,1,\cdots,\alpha_i-1\end{aligned}\end{equation}$$<p>显然对于插值节点$x_m,m=1,\cdots,s$$$\begin{equation}\begin{aligned}p_n(x_m)&=\sum_{i=1}^s[y_iL_{i,0}(x)+y'_iL_{i,1}(x)+\cdots+y_i^{(\alpha_i-1)}L_{i,\alpha_i-1}(x)]\\&=\cdots+[y_mL_{m,0}(x_m)+y'_mL_{m,1}(x_m)+\cdots+y_m^{(\alpha_m-1)}L_{m,\alpha_m-1}(x_m)]+\cdots\\&=y_mL_{m,0}(x_m)=y_m\\p'_n(x_m)&=\sum_{i=1}^s[y_iL'_{i,0}(x)+y'_iL'_{i,1}(x)+\cdots+y_i^{(\alpha_i-1)}L'_{i,\alpha_i-1}(x)]\\&=\cdots+[y_mL'_{m,0}(x_m)+y'_mL'_{m,1}(x_m)+\cdots+y_m^{(\alpha_m-1)}L'_{m,\alpha_m-1}(x_m)]+\cdots\\&=y'_mL'_{m,1}(x_m)=y'_m\end{aligned}\end{equation}$$</p><p>以下构造$L_{i,k}(x)$，令$A(x) = \prod\limits_{i=1}^s(x - x_i)^{\alpha_i} $且令$l_{i,k}(x)=\dfrac{1}{k!}\left\{ \dfrac{(x-x_i)^{\alpha_i}}{A(x)}\right\}_{(x_i)}^{\alpha_i-k-1}$</p><p>其中$\left \{\dfrac{(x-x_i)^{\alpha_i}}{A(x)}\right \}_{(x_i)}^{\alpha_i-k-1}$代表$\dfrac{(x-x_i)^{\alpha_i}}{A(x)}$在点$x_i$附近的$Taylor$级数中幂次不超过$\alpha_i-k-1$的项之和，即</p>$\left[ \dfrac{(x-x_i)^{\alpha_i}}{A(x)} \right]_{x_i}+\left[ \dfrac{(x-x_i)^{\alpha_i}}{A(x)} \right]'_{x_i}(x-x_i)+\dfrac{1}{2!}\left[ \dfrac{(x-x_i)^{\alpha_i}}{A(x)} \right]''_{x_i}(x-x_i)^2$<p><strong>注：</strong>$l_{i,k}(x)=\dfrac{1}{k!}[a_0+a_1(x-x_i)+\cdots+a_{\alpha_i-k-1}(x-x_i)^{\alpha_i-k-1}]\in P_{\alpha_i-k-1}$</p><p>取$\begin{equation}\begin{aligned}L_{i,k}(x)&=(x-x_1)^{\alpha_1}\cdots(x-x_{i-1})^{\alpha_{i-1}}(x-x_i)^{\alpha_k}(x-x_{i+1})^{\alpha_{i+1}}\cdots(x-x_s)^{\alpha_s}l_{i,k}(x)\\&=\dfrac{A(x)}{(x-x_i)^{\alpha_i}}\cdot\dfrac{(x-x_i)^k}{k!}\cdot\left \{\dfrac{(x-x_i)^{\alpha_i}}{A(x)}\right \}_{(x_i)}^{\alpha_i-k-1}\end{aligned}\end{equation}$</p><p>即为所求的一批<strong>插值基函数多项式</strong></p><p>$L_{i,k}(x)$的阶数为：</p><p>$\alpha_1+\cdots+\alpha_{i-1}+k+\alpha_{i+1}+\alpha_{s}+\alpha_{i}-k-1=\alpha_1+\cdots+\alpha_s-1=n$</p><p><strong>两点三次$Hermite$插值多项式</strong>$$\begin{equation}\begin{aligned}H_3(x)&=f(x_1)\left( 1-2\dfrac{x-x_1}{x_1-x_2} \right)\left( \dfrac{x-x_2}{x_1-x_2} \right)^2+f'(x_1)(x-x_1)\left( \dfrac{x-x_2}{x_1-x_2} \right)^2\\&\quad + f(x_2)\left( 1-2\dfrac{x-x_2}{x_2-x_1} \right)\left( \dfrac{x-x_1}{x_2-x_1} \right)^2+f'(x_2)(x-x_2)\left( \dfrac{x-x_1}{x_2-x_1} \right)^2\end{aligned}\end{equation}$$插值条件为：</p><p>$H_3(x_k)=f(x_k)\quad H_3’(x_k)=f’(x_k)\quad (k=1,2)$</p><p><strong>定理5.3</strong> 设$f(x)\in C^3[a,b]$，（$C^3$为三阶导函数连续）在$(a,b)$内4阶可导，又设$a\le x_1&lt;x_2 \le b$则两点三次$Hermite$插值多项式$p_3(x)$有如下误差估计式：</p><p>$f(x)-p_3(x)=\dfrac{f^{(4)(\xi)}}{4!}(x-x_1)^2(x-x_2)^2\quad x\in [a,b]$</p><p>其中$min(x_1,x_2)&lt;\xi&lt;max(x_,x_2)$</p><h2 id="分段低次插值"><a href="#分段低次插值" class="headerlink" title="分段低次插值"></a>分段低次插值</h2><p>对于等距节点的高次$Lagrange$ 多项式插值误差随着次数增长，可知<strong>$Runge$现象对等距节点的高次插值多项式是典型的</strong></p><ul><li><p><strong>分段线性$Lagrange$插值</strong></p><p>设插值节点$x_0,x_1,\cdots,x_n$满足$0\le x_0&lt;x_1\cdots&lt;x_n\le b$，在每一个区间$[x_k,x_{k+1}](k=0,1,\cdots,n-1)$上做线性插值多项式</p><p>$L_h^{(k)}(x)=y_k\dfrac{x-x_{k+1}}{x_k-x_{(k+1)}}+y_{k+1}\dfrac{x-x_{k}}{x_{(k+1)}-x_k}\quad x\in[x_k,x_{k+1}]$</p><p>令  $$  \begin{equation}  \begin{aligned}  L_h(x)=  \begin{cases}  L_h^{(0)}(x)\quad x\in[x_0,x_1]\\  L_h^{(1)}(x)\quad x\in[x_1,x_2]\\  \quad \vdots\qquad \qquad \vdots\\  L_h^{(n-1)}(x)\quad x\in[x_{n-1},x_n]\\  \end{cases}  \end{aligned}  \end{equation}  $$  显然$L_h(x_i)=y_i(i=0,1,\cdots,n)$，$L_h(x)$称为$f(x)$在$[a,b]$上的分段线性插值多项式。</p><p>根据<strong>插值余项定理</strong>，当$f(x)$在$[a,b]$上二次可微时，对任意$x\in [x_k,x_{k+1}]$，其余项为</p><p>$R_1(x)=f(x)-L_h^{(k)}(x)=\dfrac{f’’(\xi)}{2}(x-x_k)(x-x_{k+1})$</p><p>从而有$\max\limits_{a\le x\le b}|R(x)|\le \dfrac{M_2}{2}|(x-x_k)(x-x_{k+1})|\le \dfrac{M_2}{8}h^2$</p><p>其中$M_2=\max\limits_{a\le x\le b}|f’’(x)|\quad h=\max\limits_{0\le k\le n-1}h_k\quad h_k=x_{k+1}-x_k$</p><p>易证，当$f(x)\in [a,b]$时，$\lim\limits_{h\rightarrow0}L_h(x)=f(x)$在$[a,b]$上一致成立</p><p>对$x\in[a,b]$，若$x\in[x_k,x_{k+1}]$，则以$L_h^{(k)}(x)$作为$f(x)$的近似值；若$x\le x_0$，则以$L_h^{(0)}(x)$；若$x\ge x_n$，则以$L_h^{(n-1)}(x)$</p></li><li><p><strong>分段二次插值</strong></p><p>当给定的函数表中节点个数远多于3的时候，为提高计算精度，或根据实际问题需要，有时采取分段二次插值法</p><p>对于$x\in [a,b]$，应选择靠近$x$的三个节点做二次插值多项式</p><ul><li>当$x\in [x_k,x_{k+1}]$，且$x$偏向$x_k$时，选择$x_{k-1},x_k,x_{k+1}$作为插值节点</li><li>当$x\in [x_k,x_{k+1}]$，且$x$偏向$x_{k+1}$时，选择$x_k,x_{k+1},x_{k+2}$作为插值节点</li><li>当$x\in [x_0,x_{1})$，且$x&lt;x_0$时，选择$x_{0},x_1,x_{2}$作为插值节点</li><li>当$x\in (x_{n-1},x_{n}]$，且$x&gt;x_n$时，选择$x_{n-2},x_{n-1},x_{n}$作为插值节点</li></ul></li><li><p>分段三次$Hermite$插值</p><p>设插值节点$x_0,x_1,\cdots,x_n$满足$0\le x_0&lt;x_1\cdots&lt;x_n\le b$，在每一个区间$[x_k,x_{k+1}](k=0,1,\cdots,n-1)$上做两点三次$Hermite$插值</p>$H_3^{(k)}(x)=y_k\alpha_0^{(k)}(x)+y_{k+1}\alpha_1^{(k)}(x)+y'_k\beta_0^{(k)}(x)+y'_{k+1}\beta_1^{(k)}(x)$<p>其中$\alpha_0^{(k)}(x),\alpha_1^{(k)}(x),\beta_0^{(k)}(x),\beta_1^{(k)}(x)$为$Hermite$插值基函数</p></li></ul><h2 id="三次样条插值"><a href="#三次样条插值" class="headerlink" title="三次样条插值"></a>三次样条插值</h2><p><strong>样条函数是指满足一定光滑性的分段多项式</strong></p><p><strong>插值性质</strong></p><ul><li><p>多项式$Lagrange$插值</p><p>整体性强，光滑性好（无穷阶连续），但不一定收敛</p></li><li><p>分段$Lagrange$多项式插值</p><p>局部性好，光滑性差（$C^0$连续），收敛性保证</p></li><li><p>分段$Hermite$多项式插值</p><p>局部性好，满足一定光滑性，收敛性保证，但需要导数值信息</p></li><li><p>样条插值</p><p>局部性好，满足一定光滑性，收敛性保证，只需要函数值信息</p></li></ul><p><strong>定义5.3</strong> 对区间$(-\infty,+\infty)$的一个分割</p><p>$\Delta:-\infty&lt;x_1&lt;x_2&lt;\cdots&lt;x_n&lt;+\infty$</p><p>若分段函数$s(x)$满足：</p><ul><li>在每个区间$(-\infty,x_1],[x_j,x_{j+1}]\quad (j=1,2,\cdots,n-1),[x_n,+\infty)$上，$s(x)$是一个次数不超过$m$的实系数代数多项式</li><li>$s(x)$在对区间$(-\infty,+\infty)$上具有直至$m-1$阶的连续微商，则称$y=s(x)$为对应于分割$\Delta$的<strong>$m$次样条函数</strong>，$x_1,x_2,\cdots,x_n$称为样条节点，以$x_1,x_2,\cdots,x_n$为节点的$m$次样条函数的全体记为：$S_m(x_1,x_2,\cdots,x_n)$</li></ul><p>当$m=1$时，样条函数是分段线性函数</p><p>当$m=2$时，样条函数是分段1阶连续的二次函数</p><p>判断分段多项式函数是样条函数</p>$\begin{equation}\begin{aligned}s(x)=\begin{cases}p_0(x)\quad x\le x_1\\p_1(x)\quad x_1\le x \le x_2\\\qquad \vdots\\p_j(x)\quad x_j\le x \le x_{j+1}\quad p_j(x)\in P_m(j=0,1,\cdots,n)\\\qquad \vdots\\p_n(x)\quad x_n\le x \quad \end{cases}\end{aligned}\end{equation}$<p>因为$p_{j-1}^{(i)}(x_j)=p_j^{(i)}(x_j)\quad i=0,1,\cdots,m-1$</p><p>令$q_j(x)=p_j(x)-p_{j-1}(x)\in P_m$</p><p>$\Rightarrow q_j^{(i)}(x_j)=p_j^{(i)}(x)-p_{j-1}^{(i)}(x)=0\quad i=0,1,\cdots,m-1$</p><p>$\Rightarrow q_j(x)=c_j(x-x_j)^m$</p><p>$\Rightarrow p_j(x)=p_{j-1}(x)+c_j(x-x_j)^m\quad j=1,2,\cdots,n$其中$c_j(x-x_j)^m$称为光滑因子</p><p>所以$s(x)$是$m$次样条的充要条件是</p>$\begin{equation}\begin{aligned}\begin{cases}p_0(x)=a_0+a_1x+\cdots+a_mx^m\\p_1(x)=p_0(x)+c_1(x-x_1)^m\\p_2(x)=p_1(x)+c_2(x-x_2)^m=p_0(x)+c_1(x-x_1)^m+c_2(x-x_2)^m\\\qquad \vdots\\p_n(x)=p_{n-1}(x)+c_n(x-x_n)^m=p_0(x)+\sum\limits_{j=1}^nc_j(x-x_j)^m \end{cases}\end{aligned}\end{equation}$<p><strong>定理5.4</strong> 任意$s(x)\in S_m(x_1,x_2,\cdots,x_n)$均可唯一表示为</p><p>$s(x)=p_m(x)+\sum\limits_{j=1}^nc_j(x-x_j)^m_+\quad -\infty&lt;x&lt;+\infty$</p><p>其中$p_m(x)\in P_m\quad c_j(j=1,2,\cdots,n)$为实数</p><p><strong>定理5.5</strong> 为使$s(x)\in S_m(x_1,x_2,\cdots,x_n)$必须且只需存在$p_m(x)\in P_m$和$n$个实数$c_1,c_2,\cdots,c_n$,使得</p><p>$s(x)=p_m(x)+\sum\limits_{j=1}^nc_j(x-x_j)^m_+\quad -\infty&lt;x&lt;+\infty$</p>$ \begin{equation}\begin{aligned}S_m(x_1,x_2,\cdots,x_n)=span\{&1,x,\cdots,x^m,(x-x_1)^m_+,(x-x_1)^m_+,(x-x_2)^m_+,\\&\cdots,(x-x_n)^m_+,\}\end{aligned}\end{equation}$<p>$m$次样条空间的维数：$dim S_m(x_1,x_2,\cdots,c_n)=m+n+1\quad$($n$个节点，$m$多项式有$m+1$维数)</p><p>设给定节点$a=x_0&lt;x_1&lt;\cdots&lt;x_n=b$及节点上的函数值$f(x_i)=y_i\quad i=0,1,\cdots,n$</p><p>三次样条插值问题就是构造$s(x)\in S_3(x_1,x_2,\cdots,x_{n-1})$使$f(x_i)=y_i\quad i=0,1,\cdots,n$</p><p>三次样条插值问题实际上是一种特殊类型的分段三次多项式插值问题：</p><ul><li>他只在插值区间端点比$Lagrange$多项式插值问题多两个边界条件，但却在内点处有一阶，二阶连续导函数，从而比$Lagrange$插值更光滑</li><li>分段$Hermite$三次多项式插值问题，只有被插值函数在所有插值节点处的函数值和导数值都已知时才能使用，而且在内点处有二阶导函数一般不连续</li></ul><p>一般来说，构造三次样条插值多项式$S_3(x)$，若用待定系数法，可写成</p><p>$S_3(x)=a_ix^3+b_ix^2+c_ix+d_i\quad x\in[x_i,x_{i+1}]\quad i=0,1,\cdots,n-1$</p><p>其中$a_i,b_i,c_i,d_i$为待定系数，共有$4n$个，按定义$S_3(x)$应满足</p><ul><li><p>插值条件$n+1$个：$S(x_i)=y_i\quad i=0,1,\cdots,n-1$</p><p>​    连续性条件$n-1$个：$S(x_i-0)=S(x_i+0)\quad i=0,1,\cdots,n-1$</p></li><li><p>在内点一阶导数连续性条件$n-1$个</p><p>​    $S’(x_i-0)=S’(x_i+0)\quad i=0,1,\cdots,n-1$</p></li><li><p>在内点二阶导函数连续性条件$n-1$个</p><p>​    $S’’(x_i-0)=S’’(x_i+0)\quad i=0,1,\cdots,n-1$</p></li></ul><p>共计$4n-2$个条件，因此要确定$4n$个系数，还需附加2个条件</p><p>通常有如下三种类型的附加条件，称为边界条件：</p><ul><li><p>固支条件（第一类边界条件）</p><p>​    $S’(x_0)=f’(x_0)\quad S’(x_n)=f’(x_n)$</p></li><li><p>$S’’(x_0)=f’’(x_0)\quad S’’(x_n)=f’’(x_n)$</p><p>​    特别的当$S’’(x_0)=f’’(x_n)=0$时，称为<strong>自然边界条件</strong></p></li><li><p>周期条件</p><p>​    $S(x_0-0)=S(x_n+0)\quad S’(x_0-0)=S’(x_n+0)\quad S’’(x_0-0)=S’’(x_n+0)$</p><p>​    已知$f(x_0)=f(x_n)$确定的周期函数</p></li></ul><h2 id="三次样条插值及其收敛性"><a href="#三次样条插值及其收敛性" class="headerlink" title="三次样条插值及其收敛性"></a>三次样条插值及其收敛性</h2><p>设$s’(x_k)=m_k\quad (k=0,1,\cdots,n)\quad h_k=x_{k+1}-x_k\quad (k=0,1,\cdots,n-1)$</p><p>因为$s(x)$在每一个子区间$[x_k,x_{k+1}]$上都是三次多项式，所以在$[x_0,x_n]$上可以将$s(x)$表示成分段两点三次$Hermite$插值多项式</p><p>当$x\in [x_k,x_{k+1}]$时$$\begin{equation}\begin{aligned}s(x)&=\left( 1-2\dfrac{x-x_k}{-h_k} \right)\left( \dfrac{x-x_{k+1}}{-h_k}  \right)^2y_k+m_k(x-x_k)\left( \dfrac{x-x_{k+1}}{-h_k}  \right)^2\\&\quad + \left( 1-2\dfrac{x-x_{k+1}}{h_k} \right)\left( \dfrac{x-x_{k}}{h_k}  \right)^2y_{k+1}+m_{k+1}(x-x_{k+1})\left( \dfrac{x-x_{k}}{h_k}  \right)^2\\&= \dfrac{h_k+2(x-x_k)}{h_k^3}(x-x_{k+1})^2y_k+\dfrac{h_k-2(x-x_{k+1})}{h_k^3}(x-x_k)^2y_{k+1}\\&\quad + \dfrac{(x-x_k)(x-x_{k+1})^2}{h_k^2}m_k+\dfrac{(x-x_{k+1})(x-x_{k})^2}{h_k^2}m_{k+1}\end{aligned}\end{equation}$$</p><p>所以，求$s(x)$的关键在于确定$n+1$个常数$m_0,m_1,\cdots,m_n$。为此，对$s(x)$求二阶导数得</p>$$\begin{equation}\begin{aligned}s''(x)&=\dfrac{6x-2x_k-4x_{k+1}}{h_k^2}m_k+\dfrac{6x-4x_k-2x_{k+1}}{h_k^2}m_{k+1}\\&\quad +\dfrac{6(x_k+x_{k+1}-2x)}{h_k^3}(y_{k+1}-y_k)\quad x\in[x_k,x_{k+1}]\end{aligned}\end{equation}$$<p>于是，对于$x\in[x_k,x_{k+1}]$</p><p>$\lim\limits_{x\rightarrow x_k^+}s’’(x)=-\dfrac{4}{h_k}m_k-\dfrac{2}{h_k}m_{k+1}+\dfrac{6}{h_k^2}(y_{k+1}-y_k)$</p><p>以$k-1$取代$k$，便得$s(x)$在$[x_{k-1},x_k]$上的表达式</p><p>$\lim\limits_{x\rightarrow x_k^-}s’’(x)=\dfrac{2}{h_{k-1}}m_{k-1}+\dfrac{4}{h_{k-1}}m_{k}-\dfrac{6}{h_{k-1}^2}(y_k-y_{k-1})$</p><p>由$\lim\limits_{x\rightarrow x_k^+}s’’(x)=\lim\limits_{x\rightarrow x_k^-}s’’(x)\quad (k=1,2,\cdots,n-1)$得</p><p>$\dfrac{1}{h_{k-1}}m_{k-1}+2\left(\dfrac{1}{h_{k-1}}+\dfrac{1}{h_{k}}  \right)m_k+\dfrac{1}{h_{k}}m_{k+1}=3\left( \dfrac{y_{k+1}-y_k}{h_k^2} +\dfrac{y_{k}-y_{k-1}}{h_{k-1}^2} \right)$</p><p>用$\dfrac{h_k+h_{k-1}}{h_{k-1}h_k}$，并化简所得方程，得到基本方程组</p><p>$\lambda_k m_{k-1}+2m_k+\mu_km_{k+1}=g_k\quad (k=1,2,\cdots,n-1)$</p><p>其中</p><p>$\lambda_k=\dfrac{h_k}{h_k+h_{k-1}}\quad \mu_k=\dfrac{h_{k-1}}{h_k+h_{k-1}}\quad $</p><p>$g_k=3\left( \mu_k\dfrac{y_{k+1}-y_k}{h_k}+\lambda_k\dfrac{y_{k}-y_{k-1}}{h_{k-1}} \right)\quad k=1,2,\cdots,n-1$</p><p>方程组中含有$n-1$个方程，$n+1$个未知数$m_0,m_1,\cdots,m_n$</p><p>为了解出$m_k$还需两个方程，通过加入边界条件解决</p><ul><li><p>第一类边界条件是$\begin{equation}  \begin{aligned}\begin{cases}s'(x_0)=f'_0\\s'(x_n)=f'_n\end{cases}\end{aligned}  \end{equation}$</p><p>即$m_0=f’_0\quad m_n=f’_n$。故只需求解$n-1$阶线性方程组</p>  $$  \begin{equation}\begin{aligned}&\begin{cases}2m_1+\mu_1m_2=g_1-\lambda_1f'_0\\\lambda_km_{k-1}+2m_k+\mu_km_{k+1}=g_k\quad k=2,3,\cdots,n-2\\\lambda_{n-1}m_{n-2}+2m_{n-1}=g_{n-1}-\mu_{n-1}f'_n\end{cases}\\&\begin{bmatrix}2&\mu_1&&&&\\\lambda_2&2&\mu_2&&&\\&\lambda_3&2&\mu_3&&\\&&\ddots&\ddots&\ddots&\\&&&\lambda_{n-2}&\ddots&\mu_{n-2}\\&&&&\lambda_{n-1}&2\\\end{bmatrix}\begin{bmatrix}m_1\\m_2\\m_3\\\vdots\\m_{n-2}\\m_{n-1}\end{bmatrix}\begin{bmatrix}g_1-\lambda_1f'_0\\g_2\\g_3\\\vdots\\g_{n-2}\\g_{n-1}-\mu_{n-1}f'_n\end{bmatrix}\end{aligned}\end{equation}  $$  <p>  因为$\lambda_k=\dfrac{h_k}{h_k+h_{k-1}}&lt;1\quad \mu_k=\dfrac{h_{k-1}}{h_k+h_{k-1}}&lt;1\quad $<br>  所以系数矩阵三对角矩阵严格对角占优，一定是非奇异矩阵，故存在唯一解$m_1,m_2,\cdots,m_{n-1}$</p></li><li><p>第二类边界条件$\begin{equation}  \begin{aligned}\begin{cases}s''(x_0)=f''_0\\s''(x_n)=f''_n\end{cases}\end{aligned}  \end{equation}$</p>$\lim\limits_{x\rightarrow x_0^+}s''(x)=f''_0=-\dfrac{4}{h_0}m_0-\dfrac{2}{h_0}m_{1}+\dfrac{6}{h_0^2}(y_{1}-y_0)$ $\lim\limits_{x\rightarrow x_n^-}s''(x)=f''_n=\dfrac{2}{h_{n-1}}m_{n-1}+\dfrac{4}{h_{n-1}}m_{n}-\dfrac{6}{h_{n-1}^2}(y_{n}-y_{n-1})$ <p>所以有</p>  $$  \begin{equation}\begin{aligned}&\begin{cases}2m_0+m_1=\dfrac{3(y_1-y_0)}{h_0}-\dfrac{h_0}{2}f''_0\\\lambda_km_{k-1}+2m_k+\mu_km_{k+1}=g_k\quad k=1,2,\cdots,n-1\\m_{n-1}+2m_n=\dfrac{3(y_n-y_{n-1})}{h_{n-1}}-\dfrac{h_{n-1}}{2}f''_n\end{cases}\\&\begin{bmatrix}2&1&&&&\\\lambda_1&2&\mu_1&&&\\&\lambda_2&2&\mu_2&&\\&&\ddots&\ddots&\ddots&\\&&&\lambda_{n-1}&\ddots&\mu_{n-1}\\&&&&1&2\\\end{bmatrix}\begin{bmatrix}m_1\\m_2\\m_3\\\vdots\\m_{n-1}\\m_{n}\end{bmatrix}\begin{bmatrix}g_0\\g_2\\g_3\\\vdots\\g_{n-1}\\g_n\end{bmatrix}\\&\begin{cases}g_0=\dfrac{3(y_1-y_0)}{h_0}-\dfrac{h_0}{2}f''_0\\g_n=\dfrac{3(y_n-y_{n-1})}{h_{n-1}}-\dfrac{h_{n-1}}{2}f''_n\end{cases}\end{aligned}\end{equation}  $$  </li><li><p>第三类边界条件（周期性条件）</p><p>设$f(x)$是以$x_n-x_0$为一个周期的函数，这时$s(x)$也应以$x_n-x_0$为周期，所以在$s(x)$端点处应满足$\lim\limits_{x\rightarrow x_0^+ }s^{(p)}(x)=\lim\limits_{x\rightarrow x_n^- }s^{(p)}(x)\quad p=0,1,2$</p><p>所以有</p><p>$\lim\limits_{x\rightarrow x_0^+}s’’(x)-\dfrac{4}{h_0}m_0-\dfrac{2}{h_0}m_{1}+\dfrac{6}{h_0^2}(y_{1}-y_0)$</p><p>$\lim\limits_{x\rightarrow x_n^-}s’’(x)=\dfrac{2}{h_{n-1}}m_{n-1}+\dfrac{4}{h_{n-1}}m_{n}-\dfrac{6}{h_{n-1}^2}(y_{n}-y_{n-1})$</p><p>再有</p>$ \begin{equation}  \begin{aligned}  \lim\limits_{x\rightarrow x_0^+}s''(x)=f''_0=f_n''=\lim\limits_{x\rightarrow x_n^-}s''(x)\\ \lim\limits_{x\rightarrow x_0^+}s'(x)=f'_0=m_0=m_n=f_n'=\lim\limits_{x\rightarrow x_n^-}s'(x)  \end{aligned}  \end{equation}$<p>所以</p><p>$\dfrac{1}{h_0}m_1+\dfrac{1}{h_{n-1}}m_{n-1}+2\left( \dfrac{1}{h_0}+\dfrac{1}{h_{n-1}} \right)m_m=3\left( \dfrac{y_1-y_0}{h_0^2}+\dfrac{y_n-y_{n-1}}{h_{n-1}^2} \right)$</p><p>简写为$\mu_nm_1+\lambda_nm_{n-1}+2m_n=g_n$</p><p>其中</p><p>$\mu_n=\dfrac{h_{n-1}}{h_0+h_{n-1}}\quad \lambda_n=\dfrac{h_{0}}{h_0+h_{n-1}}\quad g_n=3\left( \mu_n\dfrac{y_1-y_0}{h_0^2}+\lambda_n\dfrac{y_n-y_{n-1}}{h_{n-1}^2} \right)$</p><p>用$m_n$取代$m_0$得$n$阶线性方程组  $$  \begin{equation}\begin{aligned}&\begin{bmatrix}2&\mu_1&&&&\lambda_1\\\lambda_2&2&\mu_2&&&\\&\lambda_3&2&\mu_3&&\\&&\ddots&\ddots&\ddots&\\&&&\lambda_{n-1}&\ddots&\mu_{n-1}\\\mu_n&&&&\lambda_{n}&2\\\end{bmatrix}\begin{bmatrix}m_1\\m_2\\m_3\\\vdots\\m_{n-1}\\m_{n}\end{bmatrix}\begin{bmatrix}g_1\\g_2\\g_3\\\vdots\\g_{n-1}\\g_{n}\end{bmatrix}\end{aligned}\end{equation}  $$  </p></li></ul><p><strong>做题时，先求出$m_1,m_2,\cdots,m_n$，再代入$Hermite$插值多项式得到$S(x)$</strong></p><p><strong>定理5.6</strong> 设$f(x)\in C^2[a,b],S(x)$是以$a=x_0&lt;x_1&lt;\cdots&lt;x_n=b$的节点，满足三种边界条件中的任何一种的三次样条插值函数，记$h=\max\limits_{0\le i\le n-1}(x_{i+1}-x_i)$，则当$h\rightarrow 0$时，$S(x)$和$S’(x)$在$[a,b]$上分别一致收敛于$f(x)$和$f’(x)$</p><h2 id="正交多项式"><a href="#正交多项式" class="headerlink" title="正交多项式"></a>正交多项式</h2><p>已知在$n$维欧式空间中，任意两个向量$x,y$的內积为$(x,y)=\sum\limits_{i=1}^nx_iy_i$</p><p>对于$[a,b]$上的任意两个连续函数$f(x),g(x)$，任取$[a,b]$的分割之$n$个分点处的函数值：</p><p>$f(x_1),f(x_2),\cdots,f(x_n)\quad g(x_1),g(x_2),\cdots,g(x_n)$</p><p>将其对应相乘做和，即</p><p>$(f,g)=\lim\limits_{\Delta x\rightarrow 0}\left( \sum\limits_{i=1}^n f(x_i)g(x_i)\Delta x \right)=\int_a^bf(x)g(x)dx$</p><p>对于$[a,b]$上的连续函数$f(x),g(x)$定义內积</p><p>$(f,g)=\int_a^b\rho(x)f(x)g(x)dx$</p><p>其中可积函数$\rho(x)\ge 0\quad (x\in [a,b])$是权函数</p><p>连续函数$f(x),g(x),h(x)$內积满足：</p><ul><li><p>$(f,f)\ge 0$，当且仅当$f=0$时，$(f,f)=0$</p></li><li><p>$(f,g)=(g,f)$</p></li><li><p>$(\lambda f,g)=\lambda(f,g)$</p></li><li><p>$(f+g,h)=(f,h)+(g,h)$</p></li></ul><p><strong>若$(f,g)=0$，则称$f(x)$和$g(x)$在$[a,b]$上关于权函数$\rho(x)$正交</strong></p><p><strong>定义在$C[a,b]$上的一个实值函数，即为$\Vert f \Vert$，满足：</strong></p><ul><li><p>非负性$\Vert f \Vert \ge 0$，且$\Vert f \Vert = 0$当且仅当$f(x)=0$</p></li><li><p>齐次性$\Vert \alpha f \Vert=|\alpha|\Vert f \Vert$</p></li><li><p>三角不等式$\Vert f+g \Vert=\Vert f \Vert+\Vert g \Vert$</p></li></ul><p>常用的连续函数范数有：</p><ul><li><p>$\Vert f \Vert_1=\int_a^b|f(x)|dx$</p></li><li><p>$\Vert f \Vert_\infty=\max\limits_{a\le x\le b}|f(x)|$</p></li><li><p>$\Vert f \Vert_2 = \sqrt{(f,f)}=\sqrt{\int_a^b\rho(x)f^2(x)dx}$</p></li></ul><p>可以证明，连续函数的$2-$范数与內积之间的关系满足</p><p>$Cauchy-Schwarz$不等式：$|(f,g)|\le \Vert f \Vert_2\Vert g \Vert_2$</p><p>给定线性无关的函数组$\varphi_0(x),\varphi_1(x),\cdots,\varphi_n(x)$，可通过$Schmidt$正交化过程予以正交化，得到一组正规正交函数系</p><p>具体做法为：令$\phi_0(x)=\varphi_0(x)$</p>$\begin{equation}\begin{aligned}\phi_i(x)=\left |\begin{array}{cccc}(\varphi_0,\varphi_0)&\cdots&(\varphi_0,\varphi_{i-1})&\varphi_0(x)\\(\varphi_1,\varphi_0)&\cdots&(\varphi_1,\varphi_{i-1})&\varphi_1(x)\\\vdots&&\vdots&\vdots\\(\varphi_i,\varphi_0)&\cdots&(\varphi_i,\varphi_{i-1})&\varphi_i(x)\\\end{array}\right|\quad i=1,2,\cdots,n\end{aligned}\end{equation}$<p>易证</p>$\begin{equation}\begin{aligned}(\varphi_i,\phi_j)=\begin{cases}0\quad j < i\\\Delta_i \quad i = j\\\end{cases} \quad i,j=0,1,2,\cdots,n\end{aligned}\end{equation}$<p>其中</p>$\begin{equation}\begin{aligned}\Delta_i=\left |\begin{array}{cccc}(\varphi_0,\varphi_0)&\cdots&(\varphi_0,\varphi_{i-1})&(\varphi_0,\varphi_{i})\\(\varphi_1,\varphi_0)&\cdots&(\varphi_1,\varphi_{i-1})&(\varphi_1,\varphi_{i})\\\vdots&&\vdots&\vdots\\(\varphi_i,\varphi_0)&\cdots&(\varphi_i,\varphi_{i-1})&(\varphi_i,\varphi_{i})\\\end{array}\right|\quad i=0,1,2,\cdots,n\end{aligned}\end{equation}$<p><strong>注</strong></p>$\begin{equation}\begin{aligned}\phi_i(x)=\left |\begin{array}{cccc}(\varphi_0,\varphi_0)&\varphi_0(x)\\(\varphi_1,\varphi_0)&\varphi_1(x)\end{array}\right|=\varphi_1(x)(\varphi_0,\varphi_0)-\varphi_0(x)(\varphi_1,\varphi_0)\end{aligned}\end{equation}$<p>$(\phi_1,\varphi_0)=(\varphi_1,\varphi_0)(\varphi_0,\varphi_0)-(\varphi_0,\varphi_0)(\varphi_1,\varphi_0)=0$</p>$\begin{equation}\begin{aligned}(\phi_1,\varphi_1)=(\varphi_1,\varphi_1)(\varphi_0,\varphi_0)-(\varphi_0,\varphi_1)(\varphi_1,\varphi_0)=\left |\begin{array}{cccc}(\varphi_0,\varphi_0)&(\varphi_0,\varphi_1)\\(\varphi_1,\varphi_0)&(\varphi_1,\varphi_1)\end{array}\right| =\Delta_1\end{aligned}\end{equation}$<p>一般的</p>$\begin{equation}\begin{aligned}\phi_i(x)&=\left |\begin{array}{cccc}(\varphi_0,\varphi_0)&\cdots&(\varphi_0,\varphi_{j})&\cdots&\varphi_0(x)\\(\varphi_1,\varphi_0)&\cdots&(\varphi_1,\varphi_{j})&\cdots&\varphi_1(x)\\\vdots&&\vdots&&\vdots\\(\varphi_{i-1},\varphi_0)&\cdots&(\varphi_{i-1},\varphi_{j})&\cdots&\varphi_{i-1}(x)\\(\varphi_i,\varphi_0)&\cdots&(\varphi_i,\varphi_{j})&\cdots&\varphi_i(x)\\\end{array}\right|\quad i=1,2,\cdots,n\\&=\varphi_0(x)A_0+\varphi_1(x)A_1+\cdots+\varphi_j(x)A_j+\cdots+\varphi_i(x)A_i\end{aligned}\end{equation}$<p>其中$A_i$为代数余子式</p><p>从而，对于$j&lt;i$有$$\begin{equation}\begin{aligned}(\phi_i,\varphi_j)&=(\varphi_0(x),\varphi_j(x))A_0+(\varphi_1(x),\varphi_j(x))A_1+\cdots+(\varphi_i(x),\varphi_j(x))A_i\\&=\left |\begin{array}{cccc}(\varphi_0,\varphi_0)&\cdots&(\varphi_0,\varphi_{j})&\cdots&(\varphi_0,\varphi_j)\\(\varphi_1,\varphi_0)&\cdots&(\varphi_1,\varphi_{j})&\cdots&(\varphi_1,\varphi_j)\\\vdots&&\vdots&&\vdots\\(\varphi_{i-1},\varphi_0)&\cdots&(\varphi_{i-1},\varphi_{j})&\cdots&(\varphi_{i-1},\varphi_j)\\(\varphi_i,\varphi_0)&\cdots&(\varphi_i,\varphi_{j})&\cdots&(\varphi_i,\varphi_j)\\\end{array}\right|=0\end{aligned}\end{equation}$$'</p><p>对于$j=i$有$$\begin{equation}\begin{aligned}(\phi_i,\varphi_i)&=(\varphi_0(x),\varphi_i(x))A_0+(\varphi_1(x),\varphi_i(x))A_1+\cdots+(\varphi_i(x),\varphi_i(x))A_i\\&=\left |\begin{array}{cccc}(\varphi_0,\varphi_0)&(\varphi_0,\varphi_1)&\cdots&(\varphi_0,\varphi_i)\\(\varphi_1,\varphi_0)&(\varphi_1,\varphi_1)&\cdots&(\varphi_1,\varphi_i)\\\vdots&\vdots&&\vdots\\(\varphi_i,\varphi_0)&(\varphi_i,\varphi_1)&\cdots&(\varphi_i,\varphi_i)\\\end{array}\right|=\Delta_i\end{aligned}\end{equation}$$'</p><p>由$\varphi_0(x),\varphi_1(x),\cdots,\varphi_n(x)$的线性无关性，可证$\Delta_i&gt;0$</p><p>因为$\phi_i(x)$由$\varphi_0(x),\varphi_1(x),\cdots,\varphi_n(x)$线性表示，不难验证$\varphi_0(x),\varphi_1(x),\cdots,\varphi_n(x)$是正交函数系</p><p><strong>注：</strong>对任意$i&gt;j$</p><p>$(\phi_i,\phi_j)=\left( \phi_i,\sum\limits_{k=0}^jA_k\varphi_k \right)=\sum\limits_{k=0}^jA_k(\phi_i,\varphi_k)=0$</p><p>$(\phi_i,\phi_i)=\left( \phi_i,\sum\limits_{k=0}^iA_k\varphi_k \right)=\sum\limits_{k=0}^iA_k(\phi_i,\varphi_k)=A_i(\phi_i,\varphi_i)=\Delta_{i-1}\Delta_i&gt;0$</p><p>$\therefore \Delta_i&gt;0$ </p><p>进一步令</p>$\begin{equation}\begin{aligned}\begin{cases}\psi_0(x)=\dfrac{\phi_0(x)}{\sqrt{(\phi_0,\phi_0)}}=\dfrac{\phi_0(x)}{\sqrt{\Delta_0}}\\\psi_i(x)=\dfrac{\phi_i(x)}{\sqrt{(\phi_i,\phi_i)}}=\dfrac{\phi_i(x)}{\sqrt{\Delta_{i-1}\Delta_i}}\quad i = 1,2,\cdots,n\\\end{cases}\end{aligned}\end{equation}$<p>那么有</p><p>$(\psi_i,\psi_i)=\dfrac{\phi_i(x)}{\sqrt{\Delta_{i-1}\Delta_i}}\dfrac{\phi_i(x)}{\sqrt{\Delta_{i-1}\Delta_i}}=\dfrac{(\phi_i(x),\phi_i(x))}{\Delta_{i-1}\Delta_i}=1$</p><p>$(\psi_i,\psi_j)=\dfrac{\phi_i(x)}{\sqrt{\Delta_{i-1}\Delta_i}}\dfrac{\phi_j(x)}{\sqrt{\Delta_{j-1}\Delta_j}}=\dfrac{(\phi_i(x),\phi_j(x))}{\sqrt{\Delta_{j-1}\Delta_j}\sqrt{\Delta_{j-1}\Delta_j}}=0$</p><p><strong>则$\psi_0(x),\psi_1(x),\cdots,\psi_n(x)$成为标准正交函数系</strong></p><p>几种常见正交函数系：</p><ul><li><p>三角函数系，于$[-\pi,\pi]$上正交</p><p>$1,cosx,sinx,cos2x,sin2x,\cdots,cosnx,sinnx,\cdots$</p></li><li><p>余弦函数系，于$[0,\pi]$上正交</p><p>$1,cosx,cos2x,\cdots,cosnx,\cdots$</p></li><li><p>正弦函数系，于$[0,\pi]$上正交</p><p>$1,sinx,sin2x,\cdots,sinnx,\cdots$</p></li></ul><p>特别取多项式系$1,x,\cdots,x^m,\cdots$进行正交化即得到正交多项式系</p><p>令$\mu_m=\int_a^b\rho(x)x^mdx\quad m=0,1,\cdots$取$\phi_0(x)=1$</p>$\begin{equation}\begin{aligned}\phi_i(x)&=\left |\begin{array}{cccc}(1,1)&(1,x)&\cdots&(1,x^{i-1})&1\\(x,1)&(x,x)&\cdots&(x,x^{i-1})&x\\\vdots&\vdots&&\vdots&\vdots\\(x^i,1)&(x^i,x)&\cdots&(x^i,x^{i-1})&x^i\\\end{array}\right|\\&=\left |\begin{array}{cccc}\mu_o&\mu_1&\cdots&\mu_{i-1}&1\\\mu_1&\mu_2&\cdots&\mu_{i}&x\\\vdots&\vdots&&\vdots&\vdots\\\mu_i&\mu_{i+1}&\cdots&\mu_{2i-1}&x^i\\\end{array}\right|\quad i=1,2,\cdots,n\end{aligned}\end{equation}$<p>则$\phi_0(x),\phi_i(x)\quad i=1,2,\cdots$构成正交多项式</p>$\begin{equation}\begin{aligned}\Delta_i&=\left |\begin{array}{cccc}(1,1)&(1,x)&\cdots&(1,x^{i})\\(x,1)&(x,x)&\cdots&(x,x^{i})\\\vdots&\vdots&&\vdots\\(x^i,1)&(x^i,x)&\cdots&(x^i,x^{i})\\\end{array}\right|\\&=\left |\begin{array}{cccc}\mu_o&\mu_1&\cdots&\mu_{i}\\\mu_1&\mu_2&\cdots&\mu_{i+1}\\\vdots&\vdots&&\vdots\\\mu_i&\mu_{i+1}&\cdots&\mu_{2i}\\\end{array}\right|\quad i=0,1,\cdots,n\end{aligned}\end{equation}$<p>则$\psi_0(x)=\dfrac{\phi_0(x)}{\sqrt{\Delta_0}}\quad \psi_i(x)=\dfrac{\phi_i(x)}{\sqrt{\Delta_{i-1}\Delta_i}}\quad i=1,2,\cdots$构成标准正交多项式</p><p><strong>正交多项式的一些重要性质</strong></p><ul><li><p>$\psi_n(x)$恰好是$n$次多项式，$\psi_0(x),\psi_1(x),\cdots,\psi_n(x)$是$P_n$的一组基底函数</p></li><li><p>$\psi_n(x)$与次数低于$n$次的所有多项式正交</p></li><li><p>$\psi_n(x)$在$(a,b)$内恰有$n$互异零点</p><p>证明：因为$\phi(x)$为非零常数，$\phi_n(x)$为n次多项式</p><p>$(\phi_0,\phi_n)=\int_a^b\rho(x)\phi_0(x)\phi_n(x)dx=\phi_0(x)\int_a^b\rho(x)\phi_n(x)dx=0$</p><p>$\therefore \int_a^b\rho(x)\phi_n(x)dx=0$</p><p>则被积函数在积分开区间上必然变号</p><p>而权函数在区间$[a,b]$上非负，所以$\phi_n(x)$在区间$(a,b)$上必然变号</p><p>则$\phi_n(x)$在区间$(a,b)$上一定存在奇数<strong>重零点</strong></p><p>设$\phi_n(x)$在区间$(a,b)$上有$r$个奇数重零点$\xi_1,\xi_2,\cdots,\xi_r\in(a,b)$</p><p>令$r$次多项式$q(x)=(x-\xi_1)\cdots(x-\xi_r)$</p><p>如果$r&lt;n$，根据性质2得$(q,\phi_n)=\int_a^b\rho(x)q(x)\phi_n(x)dx=0$</p><p>则被积函数在积分开区间上必然变号</p><p>而$q(x)\phi_n(x)$没有奇数重节点，矛盾</p><p>所以$r=n$，得证</p></li><li><p>设$p_k$为首相系数为1的$k$次正交多项式，则有如下三项递推关系式成立</p><p>$p_{k+1}=(x-\alpha_k)p_k-\beta_{k-1}p_{k-1}$</p><p>其中$\alpha_k=\dfrac{(xp_k,p_k)}{(p_k,p_k)}\quad \beta_k=\dfrac{(p_k,p_k)}{(p_{k-1},p_{k-1})}$</p><p>证明$k+1$次多项式$xp_k$可以表示为$xp_k=c_0p_0+\cdots+c_{k-1}p_{k-1}+c_kp_k+c_{k+1}p_{k+1}$</p><p>由首项系数为1知$c_{k+1}=1$</p><p>当$i&lt;k-1$时</p>$(xp_k,p_k) = (p_k,xp_k) = 0 = c_i(p_i,p_i)\Rightarrow c_i = 0(i < k-1)  $<p>所以$xp_k=\beta_{k-1}p_{k-1}+\alpha_kp_k+p_{k+1}\Leftrightarrow p_{k+1}=(x-\alpha_k)p_k-\beta_{k-1}p_{k-1}$</p><p>由于$(xp_k,p_k)=\alpha_k(p_k,p_k)\Rightarrow \alpha_k=\dfrac{(xp_k,p_k)}{(p_k,p_k)}$</p><p>再由$(xp_k,p_{k+1})=(p_{k+1},p_{k+1})\Rightarrow (xp_{k-1},p_k)=(p_k,p_k)$</p><p>$(xp_k,p_{k-1})=(p_{k},xp_{k-1})\Rightarrow (p_{k},p_k)=\beta_{k-1}(p_{k-1},p_{k-1})$</p><p>$\Rightarrow \beta_k=\dfrac{(p_k,p_k)}{(p_{k-1},p_{k-1})}$</p></li></ul><p><strong>性质2,3是构造$Gauss$型求积公式的重要依据</strong></p><h2 id="函数的最佳平方逼近"><a href="#函数的最佳平方逼近" class="headerlink" title="函数的最佳平方逼近"></a>函数的最佳平方逼近</h2><p>已知$f(x)\in L^2[a,b]$（$[a,b]$上平方可积函数的集合）和</p>$S=span\{\varphi_0(x),\varphi_1(x),\cdots,\varphi_n(x)\}\subset C[a,b]$<p>若存在$s^*(x)=\sum\limits_{k=0}^n a_k^*\varphi_k(x)\in S$使得</p><p>$\Vert f(x)-s^*(x)\Vert_2=\min\limits_{s(x)\in S}\Vert f(x)-s(x)\Vert_2=\min\limits_{s(x)\in S}\sqrt{\int_a^b\rho(x)[f(x)-s(x)]^2dx }$</p><p>则称$s^*(x)$是$f(x)$在$S$中的<strong>最佳平方逼近</strong>函数，$\Vert f(x)-s^*(x)\Vert_2$称为<strong>均方误差</strong></p><p>显然，求$s^*(x)$等价于求多元函数</p><p>$E(a_0,a_1,\cdots,a_n)=\int_a^b\rho(x)[f(x)-s(x)]^2dx=\int_a^b\rho(x)[f(x)-\sum\limits_{k=0}^na_k\varphi_k(x)]^2dx$</p><p>的最小值点$a_0^*,a_1^*,\cdots,a_n^*$。令$\dfrac{\partial E}{\partial a_j}=0\quad j=0,1,\cdots,n$</p><p>得$2\int_a^b\rho(x)[f(x)-\sum\limits_{k=0}^na_k\varphi_k(x)]\varphi_i(x)dx=0$</p><p>$\Leftrightarrow \sum\limits_{k=0}^n(\varphi_k,\varphi_i)a_k=(f,\varphi_i)\quad i=0,1,\cdots,n$<strong>（法方程组）</strong></p><p>由于$\varphi_0,\varphi_1,\cdots,\varphi_n$线性无关，可知法方程组的系数矩阵非奇异，故法方程组有唯一解</p><p><strong>但该系数矩阵经常是满的病态矩阵，导致解失真</strong></p><p>解决方法：</p><ul><li><p>利用局部支集的基函数，如$B$样条方法（准对角矩阵）</p></li><li><p>利用正交的基函数，如正交多项式（对角矩阵）</p><p>设$\phi_0,\phi_1,\cdots,\phi_n$是$S$的正交基函数，则法方程组系数矩阵为非奇异对角阵，且解为</p>$a_k^*=\dfrac{(f,\phi_k)}{(\phi_k,\phi_k)}]\quad k=0,1,\cdots,n$<p>于是$s^*(x)=\sum\limits_{k=0}^n\dfrac{(f,\phi_k)}{(\phi_k,\phi_k)}]\phi_k(x)$</p><p>若$\psi_0(x),\psi_1(x),\cdots,\psi_n(x)$称为标准正交基，则</p>$s^*(x)=\sum\limits_{k=0}^n(f,\psi_k)\psi_k(x)$$\Vert s^*\Vert^2=(s^*,s^*)=(\sum\limits_{k=0}^na^*_k\psi_k,\sum\limits_{j=0}^na^*_j\psi_j=\sum\limits_{k=0}^n\sum\limits_{j=0}^na^*_ka^*_j(\psi_k,\psi_j)=\sum\limits_{k=0}^n(a_k^*)^2$</li></ul><h2 id="数据拟合的最小二乘法"><a href="#数据拟合的最小二乘法" class="headerlink" title="数据拟合的最小二乘法"></a>数据拟合的最小二乘法</h2><p>设$(x_i,y_i)(i=0,1,\cdots,n)$为给定的一组数据，$\omega_i&gt;0(i=0,1,\cdots,m)$为各点的权系数，要求在系数空间</p>$\begin{equation}\begin{aligned}S&=span\{\varphi_0(x),\varphi_1(x),\cdots,\varphi_n(x)\}\\&=\{\varphi(x)|\varphi(x)=\sum\limits_{k=0}^n a_k\varphi_k(x),\forall a_0,\cdots,a_n\in R\}\end{aligned}\end{equation}$<p>中，求一个函数</p>$s^*(x)=\sum\limits_{k=0}^na_k^*\varphi(x)\in S$<p>使其满足$\sum\limits_{i=0}^m \omega_i(s^*(x_i)-y_i)^2=\min\limits_{s(x)\in s}\sum\limits_{i=0}^m\omega_i(s(x_i)-y_i)^2$</p><p>则称$s^*(x)$为离散数据$(x_i,y_i)(i=0,1,\cdots,m)$在子空间$S$中带权的数据拟合的<strong>最小二乘法（离散最小二乘逼近）</strong>，简称最小二乘法，并称$s^*(x)$为<strong>最小二乘解</strong></p><p>显然，求$s^*(x)$等价于求多元函数</p><p>$E(a_0,a_1,\cdots,a_n)=\sum\limits_{i=0}^m\omega_i(s(x_i)-y_i)^2=\sum\limits_{i=0}^m\omega_i\left( \sum\limits_{i=0}^na_k\varphi_i(x_i)-y_i \right)^2$</p><p>的最小值点$a_0^*,a_1^*,\cdots,a_n^*$。令$\dfrac{\partial E}{\partial a_j}=0\quad j=0,1,\cdots,n$</p><p>得$\sum\limits_{i=0}^m\omega_i\left( \sum\limits_{k=0}^na_k\varphi_k(x_i)-y_i \right)\varphi_j(x_i)=0\quad j=0,1,\cdots,n$</p><p>即为$\sum\limits_{k=0}^n\left( \sum\limits_{i=0}^m\omega_i\varphi_k(x_i)\varphi_j(x_i) \right)a_k=\sum\limits_{i=0}^m\omega_iy_i\varphi_j(x_i)\quad j=0,1,\cdots,n\quad (1)$</p><p>定义內积$y=(y_1,y_2,\cdots,y_n)^T,\varphi_j=(\varphi_j(x_1),\varphi_j(x_2),\cdots,\varphi_j(x_n))^T$</p><p>$(\varphi_k,\varphi_j)=\sum\limits_{i=0}^m\omega_i\varphi_k(x_i)\varphi_j(x_i)\quad (y,\varphi_j)=\sum\limits_{i=0}^m\omega_iy_i\varphi_j(x_i)\quad j=0,1,\cdots,n$</p><p>则方程组$(1)$可简记为$\sum\limits_{i=0}^n(\varphi_k,\varphi_j)=(y,\varphi_j)\quad j=0,1,\cdots,n$</p><p>矩阵形式为：</p>$$\begin{equation}\begin{aligned}\begin{bmatrix}(\varphi_0,\varphi_0)&(\varphi_0,\varphi_1)&\cdots&(\varphi_0,\varphi_n)\\(\varphi_1,\varphi_0)&(\varphi_1,\varphi_1)&\cdots&(\varphi_1,\varphi_n)\\\vdots&\vdots&&\vdots\\(\varphi_n,\varphi_0)&(\varphi_n,\varphi_1)&\cdots&(\varphi_n,\varphi_n)\\\end{bmatrix}\begin{bmatrix}a_0\\a_1\\\vdots\\a_n\end{bmatrix}=\begin{bmatrix}(f,\varphi_0)\\(f,\varphi_1)\\\vdots\\(f,\varphi_n)\\\end{bmatrix}\end{aligned}\end{equation}$$<p>此方程组称为法方程组，求解该方程组得到$a_0^*,a_1^*,\cdots,a_n^*$</p><p>由于$\varphi_0,\varphi_1,\cdots,\varphi_n$线性无关，可知法方程组的系数矩阵非奇异，故法方程组有唯一解</p><p>称$(s^*-y,s^*-y)=\sum\limits_{i=0}^m\omega_i(s^*(x_i)-f(x_i))^2$为最小二乘解$s^*(x)$的<strong>平方误差</strong>，$\sqrt{\sum\limits_{i=0}^m\omega_i(s^*(x_i)-f(x_i))^2}$为<strong>均方差</strong></p><h1 id="插值函数应用"><a href="#插值函数应用" class="headerlink" title="插值函数应用"></a>插值函数应用</h1><h2 id="数值求积公式及其代数精度"><a href="#数值求积公式及其代数精度" class="headerlink" title="数值求积公式及其代数精度"></a>数值求积公式及其代数精度</h2><p>利用数值积分公式进行近似计算的场合：</p><ul><li><p>$F(x)$不能用初等函数表示，即$f(x)$找不到原函数；</p><p>$f(x)=\dfrac{1}{\ln x}\quad f(x)=\dfrac{\sin x}{x}\quad f(x)=e^{-x^2}\quad f(x)=\dfrac{1}{1-k^2\sin^2 x}$</p></li><li><p>$f(x)$没有解析表达式，用表格方式给出</p></li><li><p>大多数的无穷积分，除特殊的无穷积分外</p></li><li><p>虽然找到$f(x)$的原函数，但是它比被积函数复杂多</p><p>$\displaystyle\int \dfrac{x^2}{(1-x^4)\sqrt{1+x^4}}dx = \dfrac{1}{4\sqrt{2}}\ln\dfrac{x\sqrt{2}+\sqrt{1+x^4}}{1-x^2}+\dfrac{1}{2\sqrt{2}}\arcsin\dfrac{x\sqrt{2}}{1+x^2}+C$</p></li></ul><p>设$f(x)$是定义在$[a,b]$上的可积函数，考虑带权积分</p><p>$I(f)=\int_a^b\rho(x)f(x)dx$</p><p>其中权函数$\rho(x)$在$[a,b]$上非负可积，且至多有有限个零点</p><p>所谓<strong>数值求积</strong>就是用$I(f)=\sum\limits_{k=0}^n A_kf(x_k)$近似计算$I(f)$的值</p><p>其中，$I(f)=\sum\limits_{k=0}^n A_kf(x_k)$称为<font color="blue"> <strong>数值求积公式</strong> </font>，$A_k\quad k=0,1,\cdots,n$是与$f(x)$无关的常数，称为<font color="blue"><strong>求积系数</strong></font>，$[a,b]$上的点$x_k\quad k=0,1,\cdots,n$称为<font color="blue"> <strong>求积节点</strong> </font></p><p>第一积分中值定理</p><p>$\int_a^b f(x)dx=f(\xi)(b-a)\quad \xi\in(a,b)$的几何意义为用矩形面积$f(\xi)(b-a)$替代曲边梯形面积$\int_a^b f(x)dx$</p><p>根据此公式可以采取不同近似值方法得到下述数值求积公式：</p><ul><li>$\int_a^b f(x)dx=f(a)(b-a)\quad $左矩形求积公式</li><li>$\int_a^b f(x)dx=f(b)(b-a)\quad $右矩形求积公式</li><li>$\int_a^b f(x)dx=f(\dfrac{a+b}{2})(b-a)\quad $中矩形求积公式</li><li>$\int_a^b f(x)dx=\dfrac{(b-a)}{2}[f(a)+f(b)]\quad $梯形求积公式</li></ul><p>$f(x)$在<strong>等距节点</strong>上的插值多项式，得到的数值求积公式称为<font color="red"><strong>插值型求积公式</strong></font></p><p>将$[a,b]$进行$n$等分，令$h=\dfrac{b-a}{n}$（称为步长），将分点<br>$x_k=a+kh\quad k=0,1,\cdots,n$取为插值节点（也是求积节点），则$f(x)$可表示为它的$Lagrange$插值多项式及其余项之和，即</p><p>$f(x)=\sum\limits_{k=0}^nf(x_k)l_k(x)+r_n(x)$</p><p>所以有</p>$\begin{equation}\begin{aligned} \int_a^bf(x)&=\int_a^b\left[ \sum\limits_{k=0}^nf(x_k)l_k(x) \right]dx +  \int_a^b r_n(x)dx\\&=\sum\limits_{k=0}^n\left[ \int_a^bl_k(x)dx \right]f(x_k)+\int_a^b r_n(x)dx\\&=\sum\limits_{k=0}^nA_kf(x_k)+\int_a^b r_n(x)dx\end{aligned}\end{equation}$<p>这样得到的插值型求积公式$I_n(f)=\sum\limits_{k=0}^nA_kf(x_k)$称为$n+1$点的<strong>$Newton-Cotes$公式</strong></p><p>其中<font color="blue"><strong>求积系</strong></font>为$A_k=\int l_k(x)dx \quad k=0,1,\cdots,n$</p><p><font color="blue"><strong>求积余项</strong></font>为</p>$\begin{equation}\begin{aligned}E_n(f)&=\int_a^b r_n(x)dx\\&=\int_a^b\dfrac{f^{(n+1)}(\xi)}{(n+1)!}\omega_{n+1}(x)dx\\&=f[x,x_0,\cdots,x_n]\omega_{n+1}dx\end{aligned}\end{equation}$<p>标志着求积公式的误差大小</p><p>在$Newton-Cotes$公式中，最常用的是$n=1,2,4$时的三个公式</p><ul><li><p>$n=1$</p><p>$I_1(f)=A_0f(a)+A_1f(b)$</p><p>此时有</p>$\begin{equation}  \begin{aligned}\begin{cases}A_0=\int_a^bl_0(x)dx=\displaystyle\int_a^b\dfrac{x-b}{a-b}dx=\dfrac{b-a}{2}\\A_1=\int_a^bl_1(x)dx=\displaystyle\int_a^b\dfrac{x-a}{b-a}dx=\dfrac{b-a}{2}\end{cases}\end{aligned}  \end{equation}$<p>即为<strong>梯形求积公式</strong></p><p>$I_1(f)=T=\dfrac{b-a}{2}[f(a)+f(b)]$</p></li><li><p>$n=2$</p><p>$I_2(f)=A_0f(a)+A_1f(\dfrac{a+b}{2})+A_2f(b)$</p><p>此时有  $\begin{equation}  \begin{aligned}\begin{cases}A_0=\int_a^bl_0(x)dx=\displaystyle\int_a^b\dfrac{(x-\dfrac{a+b}{2})(x-b)}{(a-\dfrac{a+b}{2})(a-b)}dx=\dfrac{b-a}{6}\\A_1=\int_a^bl_1(x)dx=\displaystyle\int_a^b\dfrac{(x-a)(x-b)}{(\dfrac{a+b}{2}-a)(\dfrac{a+b}{2}-b)}dx=\dfrac{2(b-a)}{3}\\A_2=\int_a^bl_2(x)dx=\displaystyle\int_a^b\dfrac{(x-\dfrac{a+b}{2})(x-a)}{(b-\dfrac{a+b}{2})(b-a)}dx=\dfrac{b-a}{6}\end{cases}\end{aligned}  \end{equation}$</p><p>称为$Simpson$求积公式</p><p>$I_2(f)=S=\dfrac{b-a}{6}\left[ f(a)+4f(\dfrac{a+b}{2})+f(b) \right]$</p></li><li><p>$n=4$</p><p>$Cotes$公式</p><p>$I_4(f)=C=\dfrac{b-a}{90}\left[ 7f(a)+32f(x_1)+12f(x_2)+32f(x_3)+7f(b) \right]$</p></li></ul><p>$n+1$阶$Newton-cotes$公式求积系数的特点：</p><p>根据等距节点的$Lagrange$插值基函数对称，且满足单位分解性，因此$N-C$公式的求积系数是<strong>对称的</strong>，且满足<strong>单位分解性</strong></p><p>$\sum\limits_{k=0}^nA_k=\sum\limits_{k=0}^n\int_a^bl_k(x)dx=\int_a^b\sum\limits_{k=0}^nl_k(x)dx=\int_a^b1dx=b-a$</p><p>因为$l_k(x_i)$当且仅当$k=i$时取$1$，其他时取$0$</p><p><strong>定义6.1</strong> 如果某个数值求积公式，对于任何次数不超过$m$次的代数多项式都是精确成立的<br>$$<br>I(x^m)=\int_a^bx^mdx\equiv\sum\limits_{k=0}^nA_kx_k^m=I_n(x^m)<br>$$<br>但对于$m+1$次代数多项式不一定能准确成立，即<br>$$<br>I(x^{m+1})=\int_a^bx^{m+1}dx\not=\sum\limits_{k=0}^nA_kx_k^{m+1}=I_n(x^{m+1})<br>$$<br>则称该求积公式具有$m$次代数精度</p><p>所以，一个数值求积公式具有$m$次代数精度的充要条件是它对$f(x)=1,x,\cdots,x^m$都能准确成立，但对$x^{(m+1)}$不能准确成立</p><p><font color="orange"><strong>这是确定代数精度最常用方法</strong></font></p><ul><li><p>梯形公式</p><p>$I(1)=\int_a^b1dx=b-a=\dfrac{b-a}{2}\cdot(1+1)=I_1(1)$</p><p>$I(x)=\int_a^bxdx=\dfrac{b^2-a^2}{2}=\dfrac{b-a}{2}\cdot(a+b)=I_1(x)$</p><p>$I(x^2)=\int_a^bx^2dx=\dfrac{b^3-a^3}{3}\not=\dfrac{b-a}{2}\cdot(a^2+b^2)=I_1(x^2)$</p><p>所以梯形数值求积公式具有<strong>1次代数精度</strong></p></li><li><p>$Simpson$公式</p><p>$I(1)=\int_a^b1dx=b-a=\dfrac{b-a}{6}\cdot(1+4+1)=I_2(1)$</p><p>$I(x)=\int_a^bxdx=\dfrac{b^2-a^2}{2}=\dfrac{b-a}{6}\cdot(a+4\dfrac{b+a}{2}+b)=I_2(x)$</p><p>$I(x^2)=\int_a^bx^2dx=\dfrac{b^3-a^3}{3}=\dfrac{b-a}{6}\cdot(a^2+4(\dfrac{a+b}{2})^2+b^2)=I_2(x^2)$</p><p>$I(x^3)=\int_a^bx^2dx=\dfrac{b^4-a^4}{4}\not=\dfrac{b-a}{6}\cdot(a^3+4(\dfrac{a+b}{2})^3+b^3)=I_2(x^3)$</p><p>所以$Simpson$数值求积公式具有<strong>3次代数精度</strong></p></li></ul><p>也可以通过求积余项估计，得到代数精度</p><ul><li><p>梯形公式</p><p>$f(x)=p_1(x)+\dfrac{f’’(\xi)}{2}(x-a)(x-b)\quad \xi=\xi(x)\in[a,b]$</p><p>$E_1(f)=\dfrac{1}{2}\int_a^bf’’(\xi)(x-a)(x-b)dx$</p><p>因为$(x-a)(x-b)$在$(a,b)$上恒负（不变号），根据<strong>第二积分中值定理</strong></p><p>$E_1(f)=\dfrac{1}{2}f’’(\eta)\int_a^b(x-a)(x-b)dx=-\dfrac{(b-a)^3}{12}\quad \eta\in(a,b)$</p></li><li><p>$Simpson$公式的求积余项</p>$f(x)=p_2(x)+f[a,x_1,b,x](x-a)(x-x_1)(x-b)\quad x_1=\dfrac{a+b}{2}$$\begin{equation}  \begin{aligned}  E_2(f)&=\int_a^bf[a,x_1,b,x](x-a)(x-\dfrac{a+b}{2})(x-b)dx\\  &=\dfrac{1}{2}\int_a^bf[a,x_1,b,x](x-a)(x-b)d(x^2-(a+b)x+ab)\\  &=\dfrac{1}{2}\int_a^bf[a,x_1,b,x](x-a)(x-b)d(x-a)(x-b)\\  &=\int_a^bf[a,x_1,b,x]d\dfrac{(x-a)^2(x-b)^2}{4}\\  &={\dfrac{(x-a)^2(x-b)^2}{4}f[a,x_1,b,x]}\vert_a^b-\int_a^b\dfrac{(x-a)^2(x-b)^2}{4}df[a,x_1,b,x]\\  \end{aligned}  \end{equation}$<p>因为</p>$\begin{equation}  \begin{aligned}  \dfrac{df[a,x_1,b,x]}{dx}&=f'(x)=\lim\limits_{\Delta x_0\rightarrow x}\dfrac{f[a,x_1,b,x_0]-f[a,x_1,b,x]}{x_0-x}\\  &=\lim\limits_{x_0\rightarrow x}f[a,x_1,b,x,x_0]=f[a,x_1,b,x,x]  \end{aligned}  \end{equation}$<p>所以</p><p>$E_2(f)=- \displaystyle\int_a^b\dfrac{(x-a)^2(x-b)^2}{4}f[a,x_1,b,x,x]dx$</p><p>因为$\dfrac{(x-a)^2(x-b)^2}{4}$在$(a,b)$上恒正，根据<strong>积分第二中值定理</strong></p>$\begin{equation}  \begin{aligned}  E_2(f)&=- \displaystyle\dfrac{1}{4}f[a,x_1,b,\xi,\xi]\int_a^b(x-a)^2(x-b)^2dx\\  &=-\dfrac{1}{4}\cdot\dfrac{f^{(4)}(\eta)}{4!}\int_a^b(x-a)^2(x-b)^2dx\\  &=-\dfrac{1}{90}f^{(4)}(\eta)\left( \dfrac{b-a}{2} \right)\quad \eta\in(a,b)  \end{aligned}  \end{equation}$</li></ul><p>一般的$n+1$点$Newton-Cotes$公式的求积余项，有如下定理：</p><p><strong>定理6.1</strong> <strong>$n$是偶数</strong>，且$f(x)\in C^{n+2}[a,b]$，则</p><p>$E_n(f)=C_nh^{n+3}f^{(n+2)}(\eta)$，$\eta\in(a,b)$</p><p>其中$C_n=\dfrac{1}{(n+2)!}\int_0^nt^2(t-1)\cdots(t-n)dt$</p><p><strong>若$n$是奇数</strong>，且$f(x)\in C^{n+1}[a,b]$，</p><p>则$E_n(f)=C_nh^{n+2}f^{(n+1)}(\eta)$，$\eta\in(a,b)$</p><p>其中$C_n=\dfrac{1}{(n+1)!}\int_0^nt(t-1)\cdots(t-n)dt$</p><p>代数精度是“粗”误差估计，求积余项是“细”误差估计</p><p>由于对$n$次多项式$f(x)$，$f^{(n+1)}(x)\equiv0$所以由上述定理可知</p><ul><li>当$n$为偶数时，$n+1$点的$Newton-Cotes$公式的代数精度为$n+1$</li><li>当$n$为奇数时，$n+1$点的$Newton-Cotes$公式的代数精度为$n$</li></ul><p><strong>梯形公式、$Simpson$公式以及$Cotes$公式的代数精度分别为1,3,5</strong></p><h2 id="复化求积公式"><a href="#复化求积公式" class="headerlink" title="复化求积公式"></a>复化求积公式</h2><p>将$[a,b]$等分成若干个小区间，在每个小区间上用点数少的$Newton-Cotes$公式，然后再对所有子区间求和。这样得到的数值求积公式称为<strong>复化$Newton-Cotes$公式</strong></p><p>将区间$[a,b]$进行$n$等分，每个子区间的长度$h=\dfrac{b-a}{n}$，如果在每个子区间$[x_k,x_{k+1}]\quad$$k=0,1,\cdots,n-1$上用梯形求积公式，即</p><p>$\int_{x_k}^{x_{k+1}}f(x)dx\approx\dfrac{h}{2}[f(x_k)+f(x_{k+1})]$</p><p>则$\begin{equation}\begin{aligned}\int_a^bf(x)dx&=\sum\limits_{k=0}^{n-1}\int_{x_{k}}^{x_{k+1}}f(x)dx\approx \sum\limits_{k=0}^{n-1}\dfrac{h}{2}[f(x_k)+f(x_{k+1})]\\&=\dfrac{h}{2}[f(x_0)+f(x_1)+f(x_1)+f(x_2)+\cdots+f(x_{n-1})+f(x_{n-1})+f(x_n)]\\&=\dfrac{h}{2}[f(a)+2\sum\limits_{k=1}^{n-1}f(x_k)+f(b)]\\&=\dfrac{b-a}{2n}[f(a)+2\sum\limits_{k=1}^{n-1}f(x_k)+f(b)]\end{aligned}\end{equation}$</p><p>即有<strong>复化梯形公式</strong></p><p>$T_n=\dfrac{b-a}{2n}[f(a)+2\sum\limits_{k=1}^{n-1}f(x_k)+f(b)]$</p><p>如果在每个子区间$[x_k,x_{k+1}]\quad k=0,1,\cdots,n-1$上用$Simpson$公式，即</p><p>$\int_{x_k}^{x_{k+1}}f(x)dx\approx\dfrac{h}{6}[f(x_k)+4f(x_{x+\frac{1}{2}})+f(x_{k+1})]$</p>$\begin{equation}\begin{aligned}\int_a^bf(x)dx&=\sum\limits_{k=0}^{n-1}\int_{x_{k}}^{x_{k+1}}\dfrac{h}{6}[f(x_k)+4f(x_{x+\frac{1}{2}})+f(x_{k+1})]\\&=\dfrac{h}{6}[f(x_0)+4f(x_{\frac{1}{2}})+f(x_1)+f(x_1)+4f(x_{\frac{3}{2}})+f(x_2)+\cdots+f(x_n)]\end{aligned}\end{equation}$<p>即有<strong>复化$Simpson$公式</strong></p><p>$S_n=\dfrac{b-a}{6n}[f(a)+2\sum\limits_{k=1}^{n-1}f(x_k)+4\sum\limits_{k=1}^{n-1}f(x_{k+\frac{1}{2}})+f(b)]$</p><p><strong>复化$Cotes$公式</strong></p><p>$C_n=\dfrac{b-a}{90n}[7f(a)+14\sum\limits_{k=1}^{n-1}f(x_k)+32\sum\limits_{k=1}^{n-1}f(x_{k+\frac{1}{4}})+12\sum\limits_{k=1}^{n-1}f(x_{k+\frac{1}{2}})+32\sum\limits_{k=1}^{n-1}f(x_{k+\frac{3}{4}})+f(b)]$</p><p><font color="red"><strong>解题注意</strong></font></p><ul><li><p>$n=a$复化梯形，复化$Simpson$求积公式求解积分</p><p>复化梯形有$a+1$个点，复化$Simpson$有$2a+1$个点</p></li><li><p>限定$a$个求积节点，用复化梯形，复化$Simpson$求积公式求解积分</p><p>复化梯形的$n=a-1$，复化$Simpsony$的$n=\dfrac{a-1}{2}$</p></li></ul><p><strong>余项估计</strong></p><p>设$f(x)\in C^2[a,b]$，复化梯形公式的余项为</p>$\begin{equation}\begin{aligned}I-T_n&=\sum\limits_{k=0}^{n-1}\left( -\dfrac{h^3}{12}f''(\eta_k) \right)=-\dfrac{nh^3}{12}\sum\limits_{k=0}^{n-1}\dfrac{f''(\eta_k)}{n}\\&=-\dfrac{b-a}{12}h^2f''(\eta)\quad \eta\in(a,b)\end{aligned}\end{equation}$<p>又因为</p>$\begin{equation}\begin{aligned}\lim\limits_{h\rightarrow 0}\dfrac{I-T_n}{h^2}&=\lim\limits_{h\rightarrow 0}\left[-\dfrac{1}{12}\sum\limits_{k=0}^{n-1}hf''(\eta_k)\right]=-\dfrac{1}{12}\int_a^bf''(x)dx\\&=-\dfrac{1}{12}[f'(b)-f'(a)]\end{aligned}\end{equation}$<p>当$n$充分大时，$I-T_n\approx -\dfrac{1}{12}[f’(b)-f’(a)]$</p><p>同理可得复化$Simpson$公式的余项为：</p><p>$I-S_n=-\dfrac{b-a}{180}(\dfrac{h}{2})^4f^{(4)}(\eta)\quad \eta\in(a,b)$<br>$\lim\limits_{h\rightarrow 0}\dfrac{I-S_n}{h^4}=-\dfrac{1}{180}(\dfrac{h}{2})^4[f’’’(b)-f’’’(a)]$<br>当$n$充分大时，$I-S_n\approx -\dfrac{1}{180}[f’’’(b)-f’’’(a)]$</p><p>对于复化$Cotes$公式<br>$I-C_n=-\dfrac{2(b-a)}{945}(\dfrac{h}{4})^6f^{(6)}(\eta)\quad \eta\in(a,b)$<br>$\lim\limits_{h\rightarrow 0}\dfrac{I-S_n}{h^6}=-\dfrac{2}{945}(\dfrac{h}{4})^6[f^{(5)}(b)-f^{(5)}(a)]$<br>当$n$充分大时，$I-C_n\approx -\dfrac{2}{945}(\dfrac{h}{4})^6[f^{(5)}(b)-f^{(5)}(a)]$</p><h2 id="数值微分公式"><a href="#数值微分公式" class="headerlink" title="数值微分公式"></a>数值微分公式</h2><p>设已知$f(x)$在$n+1$互异节点$a\le x_0 &lt; x_0 &lt; x_1 &lt; \cdots &lt; x_n \le b$上的函数值<br>$f_i=f(x_i)\quad i=0,1,\cdots,n$<br>则有$Lagrange$插值<br>$f(x)=p_n(x)+\dfrac{f^{(n+1)}(\xi_x)}{n+1}\prod\limits_{j=0}^n(x-x_j)\quad \xi_x\in[a,b]$<br>两端求导得</p>$\begin{equation}\begin{aligned}f'(x)&=p_n'(x)+\dfrac{1}{n+1}[f^{(n+1)}(\xi_x)\prod\limits_{j=0}^n(x-x_j)]'\\&=p_n'(x)+\dfrac{1}{n+1}[\prod\limits_{j=0}^n(x-x_j)]'f^{(n+1)}(\xi_x)+\dfrac{1}{n+1}[f^{(n+1)}(\xi_x)]'\prod\limits_{j=0}^n(x-x_j)\end{aligned}\end{equation}$<p>而$[f^{(n+1)}(\xi_x)]’$无法确定</p><p>当$x=x_k\quad k=0,1,\cdots,n$时，有</p>$\begin{equation}\begin{aligned}f'(x_k)&=p_n'(x)+\dfrac{1}{n+1}[\prod\limits_{j=0}^n(x-x_j)]'_{x=x_k}f^{(n+1)}(\xi_x)\\&=p_n'(x)+\dfrac{1}{n+1}[\prod\limits_{j=0,j\not=k}^n(x_k-x_j)]f^{(n+1)}(\xi_x)\end{aligned}\end{equation}$<p>取$f’(x_k)=p_n’(x_k)$<br>截断误差为$\dfrac{1}{n+1}[\prod\limits_{j=0,j\not=k}^n(x_k-x_j)]f^{(n+1)}(\xi_x)$<br>因为高次多项式插值不稳定，故多采用$n=1,2,4$的二，三，五点插值型求导公式</p><ul><li><p>两点公式<br>  当$n=1$时，假设$f’(x)$连续，$f’’(x)$存在，则<br>  $p_1(x)=f_0\dfrac{x-x_1}{x_0-x_1}+f_1\dfrac{x-x_0}{x_1-x_0}$<br>  $p_1’(x)=\dfrac{f_0}{x_0-x_1}+\dfrac{f_1}{x_1-x_0}=\dfrac{f_1-f_0}{x_1-x_0}=f[x_0,x_1]$<br>  记$h=x_1-x_0$，得带余项的两点公式</p>  $    \begin{equation}    \begin{aligned}    \begin{cases}    f'(x_0)=\dfrac{f_1-f_0}{h}-\dfrac{h}{2}f''(\xi)\\    f'(x_1)=\dfrac{f_1-f_0}{h}-\dfrac{h}{2}f''(\xi)\\    \end{cases}    \end{aligned}    \end{equation}    $</li><li><p>三点公式<br>  当$n=2$时，取等距节点$x_k=x_0+kh\quad k=0,1,2$，若$f’’(x)$连续，$f’’’(x)$存在，则<br>  $p_1(x)=f_0\dfrac{(x-x_1)(x-x_2)}{(x_0-x_1)(x_0-x_2)}+f_1\dfrac{(x-x_0)(x-x_2)}{(x_1-x_0)(x_1-x_2)}+f_1\dfrac{(x-x_0)(x-x_1)}{(x_2-x_0)(x_2-x_1)}$<br>  $p_1’(x)=f_0\dfrac{2x-(x_1+x_2)}{(x_0-x_1)(x_0-x_2)}+f_1\dfrac{2x-(x_0+x_2)}{(x_1-x_0)(x_1-x_2)}+f_2\dfrac{2x-(x_0+x_1)}{(x_2-x_0)(x_2-x_1)}$<br>  即带余项的三点公式为</p>  $    \begin{equation}    \begin{aligned}    \begin{cases}    f'(x_0)=\dfrac{1}{2h}(-3f_0+4f_1-f_2)+\dfrac{h^2}{3}f'''(\xi)\\    f'(x_1)=\dfrac{1}{2h}(f_2-f_0)+\dfrac{h^2}{6}f'''(\xi)\\    f'(x_2)=\dfrac{1}{2h}(f_0-4f_1+3f_2)+\dfrac{h^2}{3}f'''(\xi)\\    \end{cases}    \end{aligned}    \end{equation}    $</li><li><p>五点公式<br>  当$n=4$时，取等距节点$x_k=x_0+kh\quad k=0,1,2,3,4$<br>  若$f^{(4)}$连续，$f^{(5)}$存在，则带余项的五点公式为：</p>  $    \begin{equation}    \begin{aligned}    \begin{cases}    f'(x_0)=\dfrac{1}{12h}(-25f_0+48f_1-36f_2+16f_3-3f_4)+\dfrac{h^4}{5}f^{(5)}(\xi)\\    f'(x_1)=\dfrac{1}{12h}(-3f_0-10f_1+18f_2-6f_3+f_4)-\dfrac{h^4}{20}f^{(5)}(\xi)\\    f'(x_0)=\dfrac{1}{12h}(f_0-8f_1+8f_3-f_4)+\dfrac{h^4}{30}f^{(5)}(\xi)\\    f'(x_0)=\dfrac{1}{12h}(-f_0+6f_1-18f_2+10f_3+3f_4)-\dfrac{h^4}{20}f^{(5)}(\xi)\\    f'(x_0)=\dfrac{1}{12h}(3f_0-16f_1+36f_2-48f_3+25f_4)+\dfrac{h^4}{5}f^{(5)}(\xi)\\    \end{cases}    \end{aligned}    \end{equation}    $</li></ul><h2 id="Gauss-型求积公式"><a href="#Gauss-型求积公式" class="headerlink" title="$Gauss$型求积公式"></a>$Gauss$型求积公式</h2><p>形如$I_n(f)=\sum\limits_{k=0}^n A_kf(x_k)$插值型求积公式（节点不需等距）的代数精度至少为$n$</p><p>在区间[-1,1]上的两点的求积公式的一般形式<br>$\int_{-1}^1 f(x)dx \approx A_0f(x_0)+A_1f(x_1)$<br>即两点的$Newton-Cotes$求积公式是<strong>梯形公式</strong><br>$\int_{-1}^1 f(x)dx \approx f(-1)+f(1)$<br>其代数精度为1</p><p>若不限制等距节点，随意选取$x_0,x_1,A_0,A_1$，根据代数精度定义，分别取$f(x)=1,x,x^2,x^3$，并令</p>$\int_{-1}^1 f(x)dx \approx A_0f(x_0)+A_1f(x_1)$可得如下非线性方程组$\begin{equation}\begin{aligned}\begin{cases}A_0+A_1=\int_{-1}^1 1dx=2\\A_0x_0+A_1x_1=\int_{-1}^1 x dx=0\\A_0x_0^2+A_1x_1^2=\int_{-1}^1 x^2 dx=\dfrac{2}{3}\\A_0x_0^3+A_1x_1^3=\int_{-1}^1 x^3 dx=0\\\end{cases}\Rightarrow\begin{cases}A_0=A_1=1\\x_0=-\dfrac{\sqrt{3}}{3}\\x_1=\dfrac{\sqrt{3}}{3}\end{cases}\end{aligned}\end{equation}$<p>即$\int_{-1}^1 f(x)dx \approx f(-\dfrac{\sqrt{3}}{3})+f(\dfrac{\sqrt{3}}{3})$<br>至少具有3次代数精度，取$f(x)=x^4$<br>$\int_{-1}^1 x^4dx=\dfrac{2}{5}\not=\dfrac{2}{9}=(-\dfrac{\sqrt{3}}{3})^4+(\dfrac{\sqrt{3}}{3})^4$<br>故具有3次代数精度，也为<font color="red"><strong>两点的$Gauss-Legendre$公式</strong></font></p><p>如果用代数精度最高原则，通过求解$2n+2$阶非线性方程组来确定所有$x_0,x_1,\cdots,x_n$和$A_0,A_1,\cdots,A_n$共$2n+2$，就可以构造出具有$2n+1$次代数精度的数值积分公式<br>事实上，$n+1$个节点的求积公式，代数精度必小于$2n+2$<br>取$2n+2$次多项式$p_{2n+2}(x)=(x-x_0)^2\cdots(x-x_n)^2$<br>$I(p_{2n+2})=\int_a^b\rho(x)p_{2n+2}(x)dx&gt;0\not=I_n(p_{2n+2})=\sum\limits_{k=0}^nA_kp_{2n+2}(x_k)=0$</p><p><strong>定义6.2</strong> 如果形如$I_n(f)=\sum\limits_{k=0}^n A_kf(x_k)$的求积公式具有代数精度$2n+1$次，则称其为$Gauss$型求积公式，并称其中的求积节点$x_k\quad k=0,1,\cdots,n$为$Gauss$点<br><strong>定理6.2</strong> 要使插值型求积公式<br>$\int_a^b\rho(x)f(x)dx=\sum\limits_{k=0}^nA_kf(x_k)+E_n(f)$<br>具有$2n+1$次代数精度，必须且只须以节点$x_0,x_1,\cdots,x_n$为零点的$n+1$次多项式<br>$\omega_{n+1}(x)=\prod\limits_{j=0}^n(x-x_j)$与所有次数不超过$n$的多项式在[a,b]上关于权函数$\rho(x)$正交<br>即</p><ul><li>$x_0,x_1,\cdots,x_n$是$Gauss$点$\leftrightarrow \omega_{n+1}(x)$是正交多项式</li><li>$x_0,x_1,\cdots,x_n$是$Gauss$点$\Longleftrightarrow x_0,x_1,\cdots,x_n$是正交多项式的根</li></ul><p>证明：</p><ul><li><p>必要性<br>  假设$\int_a^b\rho(x)f(x)dx=\sum\limits_{k=0}^nA_kf(x_k)+E_n(f)$具有$2n+1$次代数精度，则<br>  $\forall q(x)\in P_n\Rightarrow \omega_{n+1}(x)q(x)\in  P_{2n+1}$</p>  $\begin{equation}            \begin{aligned}            (\omega_{n+1},q)&=\int_a^b \rho(x)\omega_{n+1}(x)q(x)dx=I(\omega_{n+1}q)\\            &=I_n(\omega_{n+1}q)=\sum\limits_{k=0}^nA_k\omega_{n+1}(x)q(x)=0            \end{aligned}            \end{equation}$<p>  即$\omega_{n+1}(x)$与任意次数不超过$n$的多项式在$[a,b]$上关于$\rho(x)$正交</p></li><li><p>充分性<br>  假设$\omega_{n+1}(x)$与任意次数不超过$n$的多项式在$[a,b]$上关于$\rho(x)$正交<br>  $\forall f(x)\in P_{2n+1}$利用多项式的带余除法，有唯一的$q_n(x),r_n(x)\in P_n$<br>  使得$f(x)=\omega_{n+1}(x)q_n(x)+r_n(x)$<br>  由于$\omega_{n+1}(x)$与所有次数不超过$n$的多项式正交，所以</p>  $\begin{equation}           \begin{aligned}           \int_a^b\rho(x)f(x)dx&=\int_a^b[\rho(x)\omega_{n+1}(x)q_n(x)+\rho(x)r_n(x)]dx\\           &=\int_a^b\rho(x)r_n(x)dx           \end{aligned}           \end{equation}$<p>  又由于$n+1$点插值型求积公式对次数不超过$n$的多项式是精确的，所以<br>  $\int_a^b\rho(x)f(x)dx=\sum\limits_{k=0}^nA_kr(x_k)=\sum\limits_{k=0}^nA_k[\omega_{n+1}(x)q_n(x)+r_n(x)]=\sum\limits_{k=0}^nA_kf(x_k)$<br>  从而有$\int_a^b\rho(x)f(x)dx=\sum\limits_{k=0}^nA_kf(x_k)$<br>即$\int_a^b\rho(x)f(x)dx=\sum\limits_{k=0}^nA_kf(x_k)+E_n(f)$具有$2n+1$次代数精度，为$Gauss$型求积公式</p></li></ul><p>$Gauss$型求积公式其求积系数有如下性质</p><ul><li>$A_k &gt; 0\quad k=0,1\cdots,n$且$\sum\limits_{k=0}^nA_k=\int_a^b \rho(x)dx$<br>  证明：<br>  由于是$Gauss$型求积公式，故对$2n$次多项式$l_k^2(x)\quad k=0,1,\cdots,n$求积公式精确成立，即<br>  $\int_a^b \rho(x)l_k^2(x)dx=\sum\limits_{i=0}^nA_il_k^2(x_i)$<br>  根据$l_k(x_i)$的性质，$i=k$取$1$，否则取$0$，得<br>  $\int_a^b \rho(x)l_k(x)dx=A_k=\int_a^b \rho(x)l_k^2(x)dx &gt; 0\quad k=0,1\cdots,n$<br>  又根据$A_k$的定义$\sum\limits_{k=0}^n A_k=\sum\limits_{k=0}^n [\int_a^b \rho(x)l_k(x)dx]=\int_a^b \rho(x)\sum\limits_{k=0}^nl_k(x)dx=\int_a^b \rho(x)dx$</li><li>$A_k=\int_a^b \rho(x)l_k(x)dx=\int_a^b \rho(x)l_k^2(x)dx$<br>其中$l_k(x)\quad k=0,1\cdots,n$是以$x_0,x_1,\cdots,x_n$为插值节点的$Lagrange$插值基函数</li></ul><p><font color="red"><strong>解题思路</strong></font>   </p><ul><li>不在$[-1.1]$区间，进行线性变换，变换到该区间 </li><li>构造正交多项式</li><li>求$x$再求$A$</li></ul><p><font color="red"><strong>特殊的$Gauss$求积公式</strong></font></p><ul><li>两点的$Gauss-Legendre$公式<br>  $\int_{-1}^1f(x)dx\approx f(\dfrac{\sqrt{3}}{3})+f(-\dfrac{\sqrt{3}}{3})$</li><li>$Gauss-Chebyshev$公式为<br>  $\int_{-1}^1\dfrac{f(x)}{\sqrt{1-x^2}}dx\approx\dfrac{\pi}{n+1}\sum\limits_{k=0}^nf(cos\dfrac{(2k+1)\pi}{2n+2})$</li></ul><h1 id="常微分方程的数值解法"><a href="#常微分方程的数值解法" class="headerlink" title="常微分方程的数值解法"></a>常微分方程的数值解法</h1><p>考虑常微分方程的初值问题</p>$    \begin{equation}    \begin{aligned}    \begin{cases}    u' = f(t,u)\quad a\le t \le b\\    u(a) = u_0    \end{cases}    \end{aligned}    \end{equation}$<p>或与其等价的积分方程<br>$u(t)=u_0 + \int_a^t f(\tau,u(\tau))d\tau$<br>若$f(t,u)$满足$Lipschitz$条件，即存在常数$L$，对任意$t\in [a,b]$，均有<br>$|f(t,u)-f(t,\overline{u})|\le L|u-\overline{u}|$，<strong>则解存在且唯一</strong></p><p><strong>数值解法</strong>即为一种<strong>离散化方法</strong>，在一系列事先取定的$[a,b]$中的离散点$a &lt; t_1 &lt; t_2 &lt; \cdots &lt; t_M \le b$<br>通常取称等距，即$t_n = t_0 + nh\quad n = 1,\cdots,M$，$h$称为步长<br>在这些点上求出未知数$u(t)$的值$u(t_1),u(t_2),\cdots,u(t_N)$的近似值<br>$u_1,u_2,\cdots,u_N$，也称初值问题的数值解</p><p>构造数值解一般采用数值积分法和$Taylor$展开法</p><h2 id="线性单步法"><a href="#线性单步法" class="headerlink" title="线性单步法"></a>线性单步法</h2><p>将节点取为$t_n = a + nh\quad h = \dfrac{b-a}{N}\quad n = 0,1,2,\cdots,N$</p>$\begin{equation}\begin{aligned}\begin{cases}u(t_{n+1})=u(t_n)\int_{n-1}^{t_{n+1}} f(t,u(t))dt\\u(t_0)=u_0\end{cases}\end{aligned}\end{equation}$<ul><li><p>显式$Euler$法<br>  对右端积分项使用<strong>左矩形求积公式</strong>，有<br>  $u(t_{n+1})=u(t_n)+\int_{n-1}^{t_{n+1}} f(t,u(t))dt\approx u(t_n) + hf(t_n,u(t_n))$<br>  令$u_{n+1} = u_n + hf(t_n,u_n)\quad n=0,1,2,\cdots,N-1$<br>  称为$Euler$求解公式，又称<strong>矩形公式</strong></p></li><li><p>隐式$Euler$法<br>  对右端积分项使用<strong>右矩形求积公式</strong>，有<br>  $u(t_{n+1})=u(t_n)\int_{n-1}^{t_{n+1}} f(t,u(t))dt\approx u(t_n) + hf(t_{n+1},u(t_{n+1}))$<br>  令$u_{n+1} = u_n + hf(t_{n+1},u_{n+1})\quad n=0,1,2,\cdots,N-1$<br>  称为隐$Euler$求解公式，又称<strong>右矩形公式</strong>，<strong>向后$Euler$公式</strong></p></li><li><p>梯形法<br>  对右端积分项使用<strong>梯形求积公式</strong>，有<br>  $u(t_{n+1})=u(t_n)\int_{n-1}^{t_{n+1}} f(t,u(t))dt\approx u(t_n) + \dfrac{h}{2}(f(t_{n},u(t_{n})) + f(t_{n+1},u(t_{n+1})))$<br>  令$u_{n+1} = u_n + \dfrac{h}{2}(f(t_{n},u_{n}) + f(t_{n+1},u_n)))\quad n=0,1,2,\cdots,N-1$<br>  称为梯形公式，又称<strong>梯形法</strong><br>  将显隐$Euler$公式做算术平均即可得梯形公式，即梯形公式也为隐方法</p><p>  为了避免求解非线性代数方程，利用显式$Euler$法将梯形法显化，建立<strong>预测——矫正系统</strong></p>  $    \begin{equation}    \begin{aligned}    \begin{cases}    u(t_0)=u_0\\    \overline{u_{n+1}=u_{n} + hf(t_n,u_n)}\\    u_{n+1}=u_n+\dfrac{h}{2}(f(t_n,u_n)+f(t_{n+1},\overline{u_{n+1}}))    \end{cases}    \end{aligned}    \end{equation}    $<p>  称为改进的$Euler$法，其中$\overline{u_{n+1}}$称为<strong>预测值</strong>，$u_{n+1}$称为<strong>校正值</strong></p></li></ul><p>如果$f(t,u(t))$关于$u$是线性函数，则隐式公式可以显式化<br>若：$u’(t)=tu+b$</p><ul><li>隐$Euler$公式：<br>  $u_{n+1}=u_n+h(t_{n+1}u_{n+1}+b)$<br>  $u_{n+1}=\dfrac{u_n+5h}{1-t_{n+1}h}\quad n=0,1,2.\cdots,N$</li><li>梯形公式<br>  $u_{n+1}=u_n+\dfrac{h}{2}h(t_nu_n+t_{n+1}u_{n+1}+2b)$<br>  $u_{n+1}=\dfrac{1}{1-\dfrac{h}{2}t_{n+1}}((1+\dfrac{h}{2}t_n)u_n+5h)\quad n=0,1,2.\cdots,N$</li></ul><p>单步法一般可写成<br>$u_{n+1} = u_n + h\varphi(t_n,u_n.t_{n+1},u_{n+1};h)\quad n=0,1,2,\cdots,N-1$<br>其中$\varphi$是依赖于$u(t_{n+1})=u(t_n)+\int_{n-1}^{t_{n+1}} f(t,u(t))dt$右端的函数$f(t,u)$<br>当$\varphi = f(t_n,u_n)$时，为$Euler$法<br>当$\varphi = f(t_{n+1},u_{n+1})$时，为后$Euler$法<br>当$\varphi = \dfrac{1}{2}[f(t_n,u_n) + f(t_{n+1},u_{n+1})]$时，为梯形法</p><p>线性单步法共同点：<br>要计算$t_{n+1}$的近似值$u_{n+1}$，每次只要用到前一个节点的值$u_n$<br>且$u_{n+1}=u_n+h\phi(t_n,u_n,t_{n+1},u_{n+1})\quad n=0,1,2,\cdots$关于$u_n,f_n,u_{n+1},f_{n+1}$是线性的</p><p><strong>定义7.1</strong> 假设$u_i = u(t_i)\quad i=0,1,\cdots,n-1$，称$R_n(h)=u(t_n)-u_n$为求解公式第$n$步的局部截断误差<br><strong>定义7.2</strong> $E_n(h) = u(t_n)-u_n = \sum\limits_{i=1}^n R_i(h)$为求解公式在$t_n$点上的整体截断误差</p><p><strong>注</strong>：局部截断误差与整体截断误差的$u_n$不是一个值</p><p>若某求解公式的局部截断误差：$R_n(h)=O(h^{p+1})$，则可以证明其整体截断误差为：$E_n(h)=O(h^p)$，称该求解公式具有<strong>$p$阶精度</strong></p>$\begin{equation}\begin{aligned}R_n(h)&=O(h^{p+1})\quad i=1,2,\cdots,n\\E_n(h)&=\sum\limits_{i=1}^{n}R_i(h)=\sum\limits_{i=1}^{n}O(h^{p+1})=\sum\limits_{i=1}^{n}h\cdot O(h^p)\\&=h\cdot O(h^p)\cdot n = O(h^p)\cdot n \cdot \dfrac{b-1}{n}=O(h^p)\end{aligned}\end{equation}$<p>求解公式的精度越高，计算解的精确性可能越好。<br>$Euler$法具有<strong>一阶精度</strong>，梯形法具有<strong>二阶精度</strong></p><h2 id="线性多步法"><a href="#线性多步法" class="headerlink" title="线性多步法"></a>线性多步法</h2><ul><li>$Milne$公式<br>  若在区间$[t_n,t_{n+2}]$上，使用$Simpson$求积公式，得<br>  $\int_{t_n}^{t_{n+2}}f(t,u(t))dt \approx \dfrac{t_{n+2}-t_{n}}{6}[f(t_{n+2},u(t_{n+2}))+4f(t_{n+1},u(t_{n+1}))+f(t_n,u(t_n))]$<br>  令$u_{n+2}=u_n+ \dfrac{h}{3}[f(t_{n+2},u(t_{n+2}))+4f(t_{n+1},u(t_{n+1}))+f(t_n,u(t_n))]$<br>  可写成$u_{n+2}=u_n+ \dfrac{h}{3}(f_{n+2}+4f_{n+1}+f_n)$<br>  此为二步方法，需已知$u_n,u_{n+1}$，才可以计算出$u_{n+2}$的值</li></ul><p>线性多步法，一般公式为：<br>$ \sum\limits_{j=0}^{k}\alpha_j u_{n+j}=h \sum\limits_{k}^{j=0}\beta_jf_{n+1}\quad \alpha_k\not=0$<br>其中$f_{n+j}=f(t_{n+j},u_{n+j}),\alpha_j,\beta_j$是常数，$\alpha_0$和$\beta_0$不同时为0<br>因为上式关于$u_{n+j},f_{n+j}$是线性的，所以称为线性多步法<br>若$\beta_k=0$为显式，$\beta_k\not=0$则为隐式</p><p>当$\alpha_0 = -1,\alpha_1=0,\alpha_2=1,\beta_0=\beta_1=\dfrac{1}{3},\beta_2 = \dfrac{4}{3}$时，就是$Miline$法</p><h2 id="待定系数法"><a href="#待定系数法" class="headerlink" title="待定系数法"></a>待定系数法</h2><p>令$L_k[u(t);h]=\sum\limits_{k}^{j=0}[\alpha_ju_{n+j} - h\beta_ju’(t+jh)]$<br>设$u(t)$是常微分方程的初值问题的解，将$u(t+jh)$和$u’(t+jh)$在$t$点处进行$Taylor$展开<br>$u(t+jh)=u(t)+\dfrac{jh}{1!}u’(t)+\dfrac{(jh)^2}{2!}u’’(t)+\dfrac{(jh)^3}{3!}u^{(3)}(t)+\cdots$<br>$u’(t+jh)=u’(t)+\dfrac{jh}{1!}u’’(t)+\dfrac{(jh)^2}{2!}u^{(3)}(t)+\dfrac{(jh)^3}{3!}u^{(4)}(t)+\cdots$</p><p>代入上式，并按$h$的同幂次合并同类项，得</p>$\begin{equation}\begin{aligned}\sum\limits_{k}^{j=0}\alpha_ju(t+jh)&= \sum\limits_{k}^{j=0}\alpha_ju(t)+\sum\limits_{k}^{j=0}\alpha_j \dfrac{jh}{1!}u'(t)+\cdots\\&\quad + \sum\limits_{k}^{j=0}\alpha_j \dfrac{(jh)^p}{p!}u^{(p)}(t)+\cdots\\\sum\limits_{k}^{j=0}\beta_jhu'(t+jh)&= \sum\limits_{k}^{j=0}\beta_jhu'(t)+\sum\limits_{k}^{j=0}\beta_j h\dfrac{jh}{1!}u''(t)+\cdots\\&\quad + \sum\limits_{k}^{j=0}\beta_j h\dfrac{(jh)^{p-1}}{p!}u^{(p)}(t)+\cdots\\\sum\limits_{k}^{j=0}[\alpha_ju(t+jh)-&h\beta_ju'(t+jh)]=\sum\limits_{k}^{j=0}\alpha_ju(t)+\sum\limits_{k}^{j=0}(j\alpha_j-beta_j)hu'(t) + \cdots \\&\quad + \sum\limits_{k}^{j=0}(\dfrac{1}{p!}j^p\alpha_j - \dfrac{1}{(p-1)!}j^{p-1}\beta_j)h^pu^{(p)}(y)+\cdots\end{aligned}\end{equation}$<p>整理后有：<br>$L_k[u(t);h]=c_0u(t)+c_1hu’(t)+c_2h^2u’’(t)+\cdots+c_ph^pu^{(p)}(t)+\cdots$<br>其中</p>$\begin{equation}\begin{aligned}\begin{cases}c_0 = \alpha_0 + \alpha_1 + \cdots + \alpha_k\\c_1 = \alpha_1 + 2 \alpha_2 + \cdots + k \alpha_k - (\beta_0 + \beta_1 + \cdots + \beta_k)\\c_2 = \dfrac{1}{2!}(\alpha_1 + 2^2 \alpha_2 + \cdots +k^2 \alpha_k) - (\beta_1 + 2 \beta_2 +\cdots + k \beta_k)\\\quad \vdots\\c_p = \dfrac{1}{p!}(\alpha_1 + 2^p \alpha_2 + \cdots + k^p \alpha_k)- \dfrac{1}{(p-1)!}(\beta_1+2^{p-1} \beta_2 + \cdots + k^{p-1} \beta_k)\end{cases}\end{aligned}\end{equation}$<p>若$u(t)$有$p+2$次连续微商，则可选取适当的$k$和$ \alpha_j, \beta_j$使得<br>$c_0=c_1=c_2=\cdots =c_p=0,c_{p+1}\not=0$即可求解$ \alpha_j, \beta_j$的线性方程组<br>此时$L_k[u(t);h]=c_{p+1}h^{p+1}u^{({p+1})}(t)+O(h^{p+2})=R_n$<br>而$u’(t)=f(t,u(t))$，则$ \sum\limits_{k}^{j=0}[ \alpha_j u(t_n + jh) - h \beta_j f(t_n + jh, u(t_n + jh))] = R_n$<br>舍去余项$R_n$，并用$u_{n+j}$代替$u(t_n + jh)$，用$f_{n+j}$记$f(t{n+j},u_{n+j})$<br>（即$u’(t{n+j},u_{n+j})$）<br>线性多步法的局部截断误差为：<br>$R_{n+k} = L_k[u(t_n);h] = c_{p+1}h^{p+1}u^{(p+1)}(t_n)+O(h^{p+2})$<br>$c_{p+1}h^{p+1}u^{(p+1)}(t_n)$称为<strong>局部截断误差主项</strong><br>$c_{p+1}$称为<strong>局部截断误差主项系数</strong><br>其整体截断误差为$E_n=O(h^p)$，故称为$p$阶$k$步法<br><strong>线性$k$步法最高可达到$2k$阶精度（整体截断误差）</strong></p><p>一般线性二步法公式的待定系数法<br>$k=2,\alpha_2=1$，记$ \alpha_0 = \alpha$，其余四个系数$ \alpha_1,\beta_0,\beta_1,\beta_2$由$c_0=c_1=c_2=c_3=0$确定</p>$\begin{equation}\begin{aligned}\begin{cases}c_0 = \alpha_0 + \alpha_1 + \alpha_2 = 0\\c_1 = \alpha_1 + 2 \alpha_2 - (\beta_0 + \beta_1 + \beta_2) = 0\\c_2 = \dfrac{1}{2}(\alpha_1 + 4 \alpha_2) - (\beta_1 + 2 \beta_2)\\c_3 = \dfrac{1}{6}(\alpha_1 + 8 \alpha_2) - \dfrac{1}{2}(\beta_1 + 4 \beta_2)\\\end{cases}\\\Rightarrow \begin{cases}\alpha_1 = -(1 + \alpha)\\\beta_0 = -\dfrac{1}{12}(1+5 \alpha)\\\beta_1 = \dfrac{2}{3}(1- \alpha)\\\beta_2 = \dfrac{1}{12}(5+ \alpha)\end{cases}\end{aligned}\end{equation}$<p>所以一般二步法为：<br>$u_{n+2}-(1+\alpha)u_{n+1}+\alpha u_n =\dfrac{h}{12}[(5+\alpha)f_{n+2}+8(1-\alpha)f_{n+1}-(1+5 \alpha)f_n]$</p><p>同理<br>$c_4 = \dfrac{1}{24}(\alpha_1 + 16 \alpha_2) - \dfrac{1}{6}(\beta_1 + 8 \beta_2) = \dfrac{1}{24}(1+\alpha)$<br>$c_5 = \dfrac{1}{120}(\alpha_1 + 32 \alpha_2) - \dfrac{1}{24}(\beta_1 + 16 \beta_2) = -\dfrac{1}{360}(17+13\alpha)$<br>当$ \alpha\not = -1$时$c_4\not=0$，是三阶二步法<br>当$\alpha = -1$时$c_4=0,c_5\not=0$，方法化为$u_{n+2}=u_n+\dfrac{h}{3}(f_{n+2}+4f_{n+2}+f_n)$，为四阶二步法，具有<strong><font color="red">最高阶数的二步法，称为Milne方法(Simpson公式)</font></strong></p><p>此外，若取$ \alpha=0$，则有$u_{n+2}=u_{n+1}+\dfrac{h}{12}(5f_{n+2}+8f_{n1}-f_n)$<br>此为二步隐式$Adams$方法<br>若取$ \alpha=-5$，则有$u_{n+2}+4u_{n+1}-5u_n=2h(2f_{n1}+f_n)$<br>此为二步显式$Adams$方法</p><p>用类似方法可以获得一些常用线性多步法的局部截断误差<br>当$k=1$时，梯形法（二阶隐式方法）<br>$u_{n+1}=u_n+\dfrac{h}{2}(f_{n+1}+f_n)$<br>其中可知$ \alpha_1=1, \alpha_0=-1,\beta_1=\beta_0=\dfrac{1}{2}$，从而有</p>$\begin{equation}\begin{aligned}\begin{cases}c_0=1-1=0\\c_1=1-(\dfrac{1}{2}+\dfrac{1}{2})=0\\c_2=(\dfrac{1}{2}-\dfrac{1}{2})=0\\c_3=\dfrac{1}{3!}-(\dfrac{1}{2}\times \dfrac{1}{2})=-\dfrac{1}{12}\not=0\end{cases}\end{aligned}\end{equation}$<p>其局部截断误差为$R_{n+1}(h)=-\dfrac{1}{12}h^3u^{(3)}(t_n)+O(h^4)$<br>同理，后$Euler$法（一阶隐式方法）其局部截断误差为：<br>$R_{n+1}(h)=-\dfrac{1}{2}h^2u^{(2)}(t_n)+O(h^3)$<br>三步三阶显示$Adams$方法其局部截断误差为：<br>$R_{n+3}(h)=\dfrac{3}{8}h^4u^{(4)}(t_n)+O(h^5)$<br>三步四阶隐式$Adams$方法其局部截断误差为：<br>$R_{n+3}(h)=-\dfrac{19}{720}h^5u^{(5)}(t_n)+O(h^6)$<br>三步四阶$Hamming$方法：<br>$u_{n+3}=\dfrac{1}{8}(9u_{n+2}-u_n)+\dfrac{3h}{8}(f_{n+3}+2f_{n+2}-f_{n+1})$<br>其局部截断误差为：<br>$R_{n+3}(h)=-\dfrac{1}{40}h^5u^{(5)}(t_n)+O(h^6)$</p><h2 id="收敛性，绝对稳定性与绝对稳定区域"><a href="#收敛性，绝对稳定性与绝对稳定区域" class="headerlink" title="收敛性，绝对稳定性与绝对稳定区域"></a>收敛性，绝对稳定性与绝对稳定区域</h2><p>对于单步法，当方法的阶$p\ge 1$时，有整体误差$E_n = u(t_n)-u_n=O(h^p)$故有$ \lim\limits_{h \rightarrow 0}E_n=0$，因此方法是收敛的<br>对于多步法，若方法是$k$步$p$阶法，那么是一个$k$阶差分方程，引入多步法的<strong>第一特征多项式</strong>和<strong>第二特征多项式</strong><br>$\rho(\lambda)= \sum\limits_{k}^{j=0}\alpha_j\lambda^j,\sigma(\lambda)= \sum\limits_{k}^{j=0}\beta_j\lambda^j$</p><p><strong>定义7.3</strong> 若第一特征多项式$\rho(\lambda)$的所有根在单位圆内或圆上（$|\lambda|\le 1$），且位于单位圆周上的根都是单根，称多步法满足<strong>根条件</strong><br>现在考察多步法，将它用于解模型方程$u’=\mu u$可得<br>$ \sum\limits_{k}^{j=0}\alpha_ju_{n+j} = \mu h \sum\limits_{k}^{j=0}\beta_ju_{n+j}$<br>若取$ \overline{h}=\mu h$，则其特征方程为<br>$\rho(\lambda) - \overline{h}\sigma(\lambda)=0$<br>其中$\rho(\lambda)= \sum\limits_{k}^{j=0}\alpha_j\lambda^j \quad \sigma(\lambda)= \sum\limits_{k}^{j=0}\beta_j\lambda^j$</p><p>由$k$阶线性差分方程的性质我们可以得到如下结论，若特征方程的根都在单位圆内$(|\lambda|&lt;1)$，则线性多步法关于$ \overline{h}=\mu h$绝对稳定，其绝对稳定域是复平面$ \overline{h}$上的区域：</p>$D=\{\overline{h}||\lambda_j( \overline{h})| < 1 \quad j=1,2,\cdots,k\}$<p>$\lambda$的次数对应j的值<br><font color="red">实系数二次方程$\lambda^2-b\lambda-c=0$的根在单位圆的充要条件为$|b|&lt;1-c&lt;2$</font></p><h2 id="补充，计算特征值的幂法"><a href="#补充，计算特征值的幂法" class="headerlink" title="补充，计算特征值的幂法"></a>补充，计算特征值的幂法</h2><p><strong>定理8.1</strong> 若矩阵$A$具有$n$个线性无关的特征向量$x^{(1)},x^{(2)},\cdots,x^{(n)}$，且对应的特征值满足<br>$|\lambda_1|&gt;|\lambda_2|&gt;|\lambda_3|&gt;\cdots&gt;|\lambda_n|$，则取$v^{(0)}\not=0$<br>经使用$v^{(k)}=A^{(k)}v^{(0)}\quad k=1,2,\cdots$<br>迭代计算得<br>$v^{(k)}=\alpha_1\lambda_1^kx^{(1)}\quad (\alpha_1\not=0)$<br>$ \dfrac{v^{(k)}_i}{v^{(k+1)}_i}\approx \lambda_1$<br>利用上述过程计算$A$的主特征值$\lambda_1$，及其对应的特征向量$x^{(1)}$的方法，称为<strong>幂法</strong>，其中$(\lambda_1,x^{(1)})$也称为<strong>极端特征对</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;计算方法知识点归纳&lt;/br&gt;插值部分&lt;/center&gt;
    
    </summary>
    
    
      <category term="Course" scheme="http://yoursite.com/categories/Course/"/>
    
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Course" scheme="http://yoursite.com/tags/Course/"/>
    
  </entry>
  
  <entry>
    <title>计算方法作业</title>
    <link href="http://yoursite.com/2019/11/06/ComputationalMethodsWork/"/>
    <id>http://yoursite.com/2019/11/06/ComputationalMethodsWork/</id>
    <published>2019-11-06T07:48:42.000Z</published>
    <updated>2019-12-23T11:51:27.816Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>设$\begin{equation}\begin{aligned}A=\begin{bmatrix}{-1}&8&-2\\{-6}&49&{-10}\\{-4}&34&{-5}\\\end{bmatrix}\end{aligned}\end{equation}$。1，利用消去法求$A^{-1}$。2，先求$A$的$Doolittle$分解，再利用所得到的分解求$A^{-1}$</p><h3 id="消去法"><a href="#消去法" class="headerlink" title="消去法"></a>消去法</h3>$$\begin{equation}\begin{aligned}\quad[A,E] &= \begin{bmatrix}{-1}&8&-2&1&0&0\\{-6}&49&{-10}&0&1&0\\{-4}&34&{-5}&0&0&1\\\end{bmatrix} \\&=\begin{bmatrix}{-1}&8&-2&1&0&0\\{0}&1&2&{-6}&1&0\\{0}&2&{3}&{-4}&0&1\end{bmatrix} \\&=\begin{bmatrix}{-1}&8&-2&1&0&0\\{0}&1&2&{-6}&1&0\\{0}&0&{-1}&{8}&{-2}&1\end{bmatrix} \\&=\begin{bmatrix}{-1}&0&-18&49&-8&0\\{0}&1&0&{10}&-3&2\\{0}&0&{-1}&{8}&{-2}&1\end{bmatrix} \\&=\begin{bmatrix}{-1}&0&0&-95&28&-18\\{0}&1&0&{10}&-3&2\\{0}&0&{-1}&{8}&{-2}&1\end{bmatrix} \\&=\begin{bmatrix}{1}&0&0&95&-28&18\\{0}&1&0&{10}&-3&2\\{0}&0&{1}&{-8}&{2}&-1\end{bmatrix} \\\Longrightarrow A^{-1} &= \begin{bmatrix}95&-28&18\\{10}&-3&2\\{-8}&{2}&-1\end{bmatrix} \\\end{aligned}\end{equation}$$<h3 id="Doolittle-分解"><a href="#Doolittle-分解" class="headerlink" title="$Doolittle$分解"></a>$Doolittle$分解</h3>$$\begin{equation}\begin{aligned}\quad A &= \begin{bmatrix}{-1}&8&-2\\{-6}&49&{-10}\\{-4}&34&{-5}\\\end{bmatrix} \\\quad L_1 &= \begin{bmatrix}{1}&0&0\\{-6}&1&0\\{-4}&0&1\\\end{bmatrix} \\\quad L_1A &= \begin{bmatrix}{-1}&-8&2\\{0}&1&2\\{0}&2&3\\\end{bmatrix} \\\quad L_2 &= \begin{bmatrix}{1}&0&0\\{0}&1&0\\{0}&-2&1\\\end{bmatrix} \\\quad L_2L_1A &= \begin{bmatrix}{-1}&-8&2\\{0}&1&2\\{0}&0&-1\\\end{bmatrix} \\\quad L = L_1^{-1}L_2^{-1} &= \begin{bmatrix}{1}&0&0\\{6}&1&0\\{4}&2&1\\\end{bmatrix} \\\quad U &= \begin{bmatrix}{-1}&8&-2\\{0}&1&2\\{0}&0&-1\\\end{bmatrix} \\\quad AA^{-1} &= LUA^{-1} = LU[a1,a2,a3]  \\&= \begin{bmatrix}{1}&0&0\\{0}&1&0\\{0}&0&1\\\end{bmatrix} \\\quad LUa_1 = Ly  &= \begin{bmatrix}{1}&0&0\\{6}&1&0\\{4}&2&1\\\end{bmatrix} \begin{bmatrix}{y_1}\\{y_2}\\{y_3}\\\end{bmatrix} =\begin{bmatrix}{1}\\{0}\\{0}\\\end{bmatrix} \Rightarrow y = \begin{bmatrix}{1}\\{-6}\\{8}\\\end{bmatrix}\\\Rightarrow Ua_1 &= \begin{bmatrix}{-1}&8&-2\\{0}&1&2\\{0}&0&-1\\\end{bmatrix}\begin{bmatrix}   {a_{11}}\\{a_{21}}\\{a_{31}}\\\end{bmatrix}=\begin{bmatrix}{1}\\{-6}\\{8}\\\end{bmatrix}\Rightarrow a_1=\begin{bmatrix}{95}\\{10}\\{-8}\\\end{bmatrix}\\同理可得 a_2&= \begin{bmatrix}{-28}\\{-3}\\{2}\\\end{bmatrix}\\a_3&= \begin{bmatrix}{18}\\{2}\\{-1}\\\end{bmatrix}\\故 A^{-1}&=\begin{bmatrix}95&-28&18\\{10}&-3&2\\{-8}&{2}&-1\end{bmatrix} \\\end{aligned}\end{equation}$$<h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>求矩阵</p>$\begin{equation}\begin{aligned}A=\begin{bmatrix}  4&4&0\\  3&3&{-1}\\  0&1&1\\  \end{bmatrix}\end{aligned}\end{equation}$的$QR$分解，使$R$的对角元为正数$$\begin{equation}\begin{aligned}\quad A = [a_1,a_2,a_3] &= \begin{bmatrix}4&4&0\\3&3&{-1}\\0&1&1\\\end{bmatrix} \\\omega_1 = a_1 - \Vert a_1 \Vert_2 e_1 &=\begin{bmatrix}4\\3\\0\\\end{bmatrix} -\begin{bmatrix}5\\0\\0\\\end{bmatrix}=\begin{bmatrix}-1\\3\\0\\\end{bmatrix}\\H(\omega_1) = I - \dfrac{2}{w^Hw}ww^H &=\begin{bmatrix}{\dfrac{4}{5}}&{\dfrac{3}{5}}&0\\{\dfrac{3}{5}}&{\dfrac{-4}{5}}&0\\0&0&1\\\end{bmatrix} \\Q_1A=H(\omega_1)A&=\begin{bmatrix}{5}&{5}&{\dfrac{-3}{5}}\\{0}&{0}&{\dfrac{4}{5}}\\0&1&1\\\end{bmatrix} \\降阶易得置换矩阵Q_2 &= \begin{bmatrix}1&0&0\\0&0&{1}\\0&1&0\\\end{bmatrix} \\Q_2Q_1A&=\begin{bmatrix}{5}&{5}&{\dfrac{-3}{5}}\\0&1&1\\{0}&{0}&{\dfrac{4}{5}}\\\end{bmatrix} \\所以有Q^T=Q_1Q_2&=\begin{bmatrix}{\dfrac{4}{5}}&0&{\dfrac{3}{5}}\\{\dfrac{3}{5}}&0&{\dfrac{-4}{5}}\\0&1&0\\\end{bmatrix} \\R&=\begin{bmatrix}{5}&{5}&{\dfrac{-3}{5}}\\0&1&1\\{0}&{0}&{\dfrac{4}{5}}\\\end{bmatrix} \\\end{aligned}\end{equation}$$<h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>设$ \begin{equation} \begin{aligned} A= \begin{bmatrix} 0&1&0\\ -4&4&0\\ -2&1&2 \end{bmatrix} \end{aligned} \end{equation} $，求$T$使$T^{-1}AT$为$Jordan$标准型</p> $$ \begin{equation} \begin{aligned} A&=\begin{bmatrix} 0&1&0\\ -4&4&0\\ -2&1&2 \end{bmatrix}\\ |\lambda I - A|&= \begin{bmatrix} \lambda&-1&0\\ 4&\lambda-4&0\\ 2&-1&\lambda-2 \end{bmatrix}\\ &=(\lambda - 2)^3\\ &\Rightarrow\lambda = 2(三重),m=3\\ rank(\lambda I-A)=1&\Rightarrow \alpha=3-1=2\\ &\Rightarrow J= \begin{bmatrix} 2&0&0\\ 0&2&1\\ 0&0&2 \end{bmatrix}\\ &\therefore AT=TJ\\ &\because A(T_1,T_2)=(T_1,T_2)  \begin{bmatrix} 2&0&0\\ 0&2&1\\ 0&0&2 \end{bmatrix}\\ &令T_1=t^1,T_2=\{t_1^2, t_1^2\} \\ (A-\lambda I )t^1=0&\Leftrightarrow \begin{bmatrix} -2&1&0\\ -4&2&0\\ -2&1&0 \end{bmatrix} \begin{bmatrix} x_1\\ x_2\\ x_3 \end{bmatrix}=0\\ &\Rightarrow  t_1^1= \begin{bmatrix} 1\\ 2\\ 0 \end{bmatrix}, t_2^1= \begin{bmatrix} 0\\ 0\\ 1 \end{bmatrix}\\ &所以长度为1的Jordan链可任取t_1^1,t_2^1\\ &但在长度为2的Jordan链上，以t_1^2,t_2^2为链首\\&无法求另一个向量构成Jordan链\\ &令y=k_1t_1^2+k_2t_2^2=(k_1,2k_1,k_2)^T\\ &\Rightarrow\begin{bmatrix} -2&1&0\\ -4&2&0\\ -2&1&0 \end{bmatrix} \begin{bmatrix} z_1\\ z_2\\ z_3 \end{bmatrix}= \begin{bmatrix} k_1\\ 2k_1\\ k_2 \end{bmatrix}\\ &\Rightarrow\begin{bmatrix} -2&1&0&k_1\\ 0&0&0&0\\ 0&0&0&k_2-k_1 \end{bmatrix}\\ &不妨取k_1=k_2=1,此时具有非零解\\ &解得z= \begin{bmatrix} 0\\ 1\\ 0 \end{bmatrix}\\ &\Rightarrow  T= \begin{bmatrix} 1&1&0\\ 2&2&1\\ 0&1&0 \end{bmatrix}or \begin{bmatrix} 0&1&0\\ 0&2&1\\ 1&1&0 \end{bmatrix} \end{aligned} \end{equation} $$<h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><p> 设$   \begin{equation}   \begin{aligned}   A=   \begin{bmatrix}   1&0&-1\\   0&\omega&i\\   0&0&\omega^2   \end{bmatrix}   \end{aligned}   \end{equation}   $，其中$\omega=\dfrac{-1+\sqrt{3}i}{2}$，试用$Cayley-Hamilton$定理计算$A^{100}$</p>   $$  \begin{equation}  \begin{aligned}  A&=  \begin{bmatrix}  1&0&-1\\  &\omega&i\\  &&\omega^2  \end{bmatrix},  \omega = \dfrac{-1+\sqrt{3}i}{2}\\  |\lambda I-A|&=(\lambda-1)(\lambda-\omega)(\lambda-\omega^2)\\  \Psi(\lambda)&=(\lambda-1)(\lambda-\omega)(\lambda-\omega^2),\Psi(A)=0\\  \lambda^{100} &= g(\lambda)\Psi(\lambda) + a\lambda^2+b\lambda+c\\  \Psi(1)&=\Psi(\omega)=\Psi(\omega^2)=0\\  &\Rightarrow\begin{cases}  1^{100}=a+b+c\\  \omega^{100}=\omega^2a+\omega b+c\\  \omega^{200}=\omega^4a+\omega^2b+c   \end{cases}\\  &\therefore   \omega^2=\dfrac{-1-\sqrt{3}i}{2},\omega^3=1\\  &\Rightarrow\begin{cases}  1=a+b+c\\  \dfrac{-1+\sqrt{3}i}{2}=\dfrac{-1-\sqrt{3}i}{2}a+\dfrac{-1+\sqrt{3}i}{2} b+c\\  \dfrac{-1-\sqrt{3}i}{2}=\dfrac{-1+\sqrt{3}i}{2}a+\dfrac{-1-\sqrt{3}i}{2}b+c   \end{cases}\\  &\Rightarrow   a=0,b=1,c=0\\  A^{100}&=g(A)\Psi(A) + A\\  &=\begin{bmatrix}  1&0&-1\\  0&\dfrac{-1+\sqrt{3}i}{2}&i\\  0&0&\dfrac{-1-\sqrt{3}i}{2}  \end{bmatrix}  \end{aligned}  \end{equation}  $$<h2 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h2><p>  求矩阵$     \begin{equation}     \begin{aligned}     A=     \begin{bmatrix}     1&0&1\\     1&1&0     \end{bmatrix}     \end{aligned}     \end{equation}     $ 的奇异值分解</p> $$    \begin{equation}\begin{aligned}A&=\begin{bmatrix}1&0&1\\1&1&0\end{bmatrix}\\(\lambda I - A^TA)&=\begin{bmatrix}\lambda-2&-1&-1\\-1&\lambda-1&0\\-1&0&\lambda-1\end{bmatrix}\\&\Rightarrow |\lambda I - A^TA|=\lambda(\lambda -1)(\lambda -3)\\&\Rightarrow \lambda_1=0,\lambda_2=1,\lambda_3=3\\&\quad \sigma_1=0,\sigma_2=1,\sigma_3=\sqrt{3}\\&\lambda_3=3时\\&\begin{bmatrix}1&-1&-1\\-1&2&0\\-1&0&2\end{bmatrix}\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix}=0\\&\Rightarrow p_1=\begin{bmatrix}2\\1\\1\end{bmatrix}\\&同理可得\lambda_2=1时，p_2=\begin{bmatrix}0\\1\\-1\end{bmatrix}，\lambda_1=0时，p_3=\begin{bmatrix}-1\\1\\1\end{bmatrix}\\&\Rightarrow P=\begin{bmatrix}2&0&-1\\1&1&1\\1&-1&1\end{bmatrix}\\&\Rightarrow V=\begin{bmatrix}\dfrac{2}{\sqrt{6}}&0&-\dfrac{1}{\sqrt{3}}\\\dfrac{1}{\sqrt{6}}&\dfrac{1}{\sqrt{2}}&\dfrac{1}{\sqrt{3}}\\\dfrac{1}{\sqrt{6}}&-\dfrac{1}{\sqrt{2}}&\dfrac{1}{\sqrt{3}}\end{bmatrix}\\V_1&=\begin{bmatrix}\dfrac{2}{\sqrt{6}}&0\\\dfrac{1}{\sqrt{6}}&\dfrac{1}{\sqrt{2}}\\\dfrac{1}{\sqrt{6}}&-\dfrac{1}{\sqrt{2}}\end{bmatrix}\\U_1&=AV_1\Sigma^{-1}=\begin{bmatrix}1&0&1\\1&1&0\end{bmatrix}\begin{bmatrix}\dfrac{2}{\sqrt{6}}&0\\\dfrac{1}{\sqrt{6}}&\dfrac{1}{\sqrt{2}}\\\dfrac{1}{\sqrt{6}}&-\dfrac{1}{\sqrt{2}}\end{bmatrix}\begin{bmatrix}\dfrac{1}{\sqrt{3}}&0\\0&1\end{bmatrix}\\&=\begin{bmatrix}\dfrac{1}{\sqrt{2}}&-\dfrac{1}{\sqrt{2}}\\\dfrac{1}{\sqrt{2}}&\dfrac{1}{\sqrt{2}}\end{bmatrix}\\&\therefore A=\begin{bmatrix}\dfrac{1}{\sqrt{2}}&-\dfrac{1}{\sqrt{2}}\\\dfrac{1}{\sqrt{2}}&\dfrac{1}{\sqrt{2}}\end{bmatrix}\begin{bmatrix}\dfrac{1}{\sqrt{3}}&0&0\\0&1&0\end{bmatrix}\begin{bmatrix}\dfrac{2}{\sqrt{6}}&\dfrac{1}{\sqrt{6}}&\dfrac{1}{\sqrt{6}}\\0&\dfrac{1}{\sqrt{2}}&-\dfrac{1}{\sqrt{2}}\\-\dfrac{1}{\sqrt{3}}&\dfrac{1}{\sqrt{3}}&\dfrac{1}{\sqrt{3}}\end{bmatrix}\end{aligned}\end{equation}$$<h2 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h2><p>设$ \begin{equation} \begin{aligned} A= \begin{bmatrix} 2&4&-2\\ 1&-1&5\\ 4&1&-2 \end{bmatrix}  \end{aligned} \end{equation} $，求出$A$的$Doolittle$分解，$Crout$分解和$LDU$分解</p>$$\begin{equation}\begin{aligned}A&=\begin{bmatrix}2&4&-2\\1&-1&{5}\\4&1&-2\\\end{bmatrix} \\L_1&=\begin{bmatrix}1&0&0\\{-\dfrac{1}{2}}&1&0\\-2&0&1\\\end{bmatrix} \\L_1A &=\begin{bmatrix}2&4&-2\\0&-3&6\\0&-7&2\\\end{bmatrix} \\L_2&=\begin{bmatrix}1&0&0\\0&1&0\\0&{-\dfrac{7}{3}}&1\\\end{bmatrix} \\L_2L_1A&=\begin{bmatrix}2&4&-2\\0&-3&6\\0&0&-12\\\end{bmatrix} \\Doolittle分解,LU\\L=L_1^{-1}L_2^{-1}&=\begin{bmatrix}1&0&0\\{\dfrac{1}{2}}&1&0\\2&\dfrac{7}{3}&1\\\end{bmatrix} \\U&=\begin{bmatrix}2&4&-2\\0&-3&6\\0&0&-12\\\end{bmatrix} \\LDU分解,LDU'\\将U化为DU',D&=\begin{bmatrix}2&0&0\\0&-3&0\\0&0&-12\\\end{bmatrix} \\U'&=\begin{bmatrix}1&2&-1\\0&1&-2\\0&0&1\\\end{bmatrix} \\Crout分解L'U'\\合并LD得L',L'&=\begin{bmatrix}2&0&0\\1&-3&0\\4&-7&-12\\\end{bmatrix} \\\end{aligned}\end{equation}$$<h2 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h2><p>利用$Doolittle$分解，$Cholesky$方法和三对角追赶法求解线性方程组</p>$$\begin{equation}\begin{aligned}\begin{bmatrix}4&1&0\\1&5&2\\0&2&8\end{bmatrix}\begin{bmatrix}x_1\\x_2\\x_3\end{bmatrix}=\begin{bmatrix}5\\8\\10\end{bmatrix}\end{aligned}\end{equation}$$<h3 id="LU分解"><a href="#LU分解" class="headerlink" title="LU分解"></a>LU分解</h3>$$\begin{equation}\begin{aligned}A&=\begin{bmatrix}4&1&0\\1&5&{2}\\0&2&8\\\end{bmatrix} \\L_1&=\begin{bmatrix}1&0&0\\-\dfrac{1}{4}&1&{0}\\0&0&1\\\end{bmatrix} \\L_1A&=\begin{bmatrix}4&1&0\\0&\dfrac{19}{4}&2\\0&2&1\\\end{bmatrix} \\L_2&=\begin{bmatrix}1&0&0\\0&1&0\\0&-\dfrac{8}{19}&1\\\end{bmatrix} \\L_2L_1A&=\begin{bmatrix}4&1&0\\0&\dfrac{19}{4}&2\\0&0&\dfrac{136}{19}\\\end{bmatrix} \\L=L_1^{-1}L_2^{-1}&=\begin{bmatrix}1&0&0\\\dfrac{1}{4}&1&0\\0&\dfrac{8}{19}&1\\\end{bmatrix} \\U&=\begin{bmatrix}4&1&0\\0&\dfrac{19}{4}&2\\0&0&\dfrac{136}{19}\\\end{bmatrix} \\Ax=b \Rightarrow LUx = b \Rightarrow Ly =b &\Rightarrow \begin{bmatrix}1&0&0\\\dfrac{1}{4}&1&0\\0&\dfrac{8}{19}&1\\\end{bmatrix} \begin{bmatrix}y_1\\y_2\\y_3\\\end{bmatrix}=\begin{bmatrix}5\\8\\10\\\end{bmatrix} \\\Rightarrow y&=\begin{bmatrix}5\\\dfrac{27}{4}\\\dfrac{136}{19}\\\end{bmatrix} \\Ux=y &\Rightarrow \begin{bmatrix}4&1&0\\0&\dfrac{19}{4}&2\\0&0&\dfrac{136}{19}\\\end{bmatrix} \begin{bmatrix}y_1\\y_2\\y_3\\\end{bmatrix}=\begin{bmatrix}5\\\dfrac{27}{4}\\\dfrac{136}{19}\\\end{bmatrix}\\\Rightarrow x&=\begin{bmatrix}1\\1\\1\\\end{bmatrix}\end{aligned}\end{equation}$$<h3 id="Chelesky"><a href="#Chelesky" class="headerlink" title="Chelesky"></a>Chelesky</h3>$$\begin{equation}\begin{aligned}A&=\begin{bmatrix}4&1&0\\1&5&{2}\\0&2&8\\\end{bmatrix} \\因为D_1 &= 4, D_2 = 19, D_3 = 136\\所以A&=\tilde L\tilde L^T\\\tilde L &=\begin{bmatrix}2&0&0\\\dfrac{1}{2}&\dfrac{\sqrt{19}}{2}&0\\0&\dfrac{4}{\sqrt{19}}&\dfrac{\sqrt{136}}{\sqrt{19}}\\\end{bmatrix} \\Ax=b&\Rightarrow \tilde L\tilde L^Tx =b\Rightarrow \tilde Ly =b\\&\Rightarrow\begin{bmatrix}2&0&0\\\dfrac{1}{2}&\dfrac{\sqrt{19}}{2}&0\\0&\dfrac{4}{\sqrt{19}}&\dfrac{\sqrt{136}}{\sqrt{19}}\\\end{bmatrix} \begin{bmatrix}y_1\\y_2\\y_3\\\end{bmatrix}=\begin{bmatrix}5\\8\\10\\\end{bmatrix} \\y &=\begin{bmatrix}\dfrac{5}{2}\\\dfrac{27}{2\sqrt{19}}\\\dfrac{\sqrt{136}}{\sqrt{19}}\\\end{bmatrix} \\\tilde L^Tx=y\Rightarrow x&=\begin{bmatrix}1\\1\\1\\\end{bmatrix}\end{aligned}\end{equation}$$<h3 id="三对角追赶法"><a href="#三对角追赶法" class="headerlink" title="三对角追赶法"></a>三对角追赶法</h3>$$\begin{equation}\begin{aligned}A &= LU\\A&=\begin{bmatrix}4&1&0\\1&5&{2}\\0&2&8\\\end{bmatrix} \\令A'&=\{a_2, a_3\} = \{1, 2\}\\B'&=\{b_1, b_2, b_3\} = \{4, 5, 8\}\\C'&=\{c_1, c_2\}=\{1, 2\}\\D'&=\{d_1, d_2\}=\{c_1, c_2\}=\{1, 2\}\\U'&=\{u_1,u_2,u_3\}\\L'&=\{l_2,l_3\}\\&\Rightarrow u_1 = b_1 = 4 \quad l_2=\dfrac{a_2}{u_1}=\dfrac{1}{4}\\&\Rightarrow u_2 = b_2-l_2d_1 = \dfrac{19}{4} \quad l_3 = \dfrac{a_3}{u_2} = \dfrac{8}{19}\\&\Rightarrow u_3 = b_3 - l_3d_2 = \dfrac{136}{19}\\\Rightarrow L &=\begin{bmatrix}1&0&0\\\dfrac{1}{4}&1&0\\0&\dfrac{8}{19}&1\\\end{bmatrix} \\\Rightarrow U &=\begin{bmatrix}4&1&0\\0&\dfrac{19}{4}&2\\0&0&\dfrac{136}{19}\\\end{bmatrix} \\Ax=b&\Rightarrow LUx=b\\Ly=b&\Rightarrow \begin{bmatrix}1&0&0\\\dfrac{1}{4}&1&0\\0&\dfrac{8}{19}&1\\\end{bmatrix} \begin{bmatrix}y_1\\y_2\\y_3\\\end{bmatrix}=\begin{bmatrix}5\\8\\10\\\end{bmatrix}\\\Rightarrow y &= \begin{bmatrix}5\\\dfrac{27}{4}\\\dfrac{136}{19}\\\end{bmatrix}\\Ux=y&\Rightarrow  \begin{bmatrix}4&1&0\\0&\dfrac{19}{4}&2\\0&0&\dfrac{136}{19}\\\end{bmatrix} \begin{bmatrix}x_1\\x_2\\x_3\\\end{bmatrix}=\begin{bmatrix}5\\\dfrac{27}{4}\\\dfrac{136}{19}\\\end{bmatrix}\\\Rightarrow x&=\begin{bmatrix}1\\1\\1\\\end{bmatrix}\end{aligned}\end{equation}$$<h2 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h2><p>确定将向量$x=(5,1,12)^T$变换为$y=(0,1,t)^T$的正数$t$以及$Householder$矩阵$H$</p>$$\begin{aligned}&\quad\because H(\omega)x =y \quad \therefore \Vert x\Vert_2 = \Vert y\Vert_2 \\&\quad\therefore 5^2+1^2+12^2 = 1^2 + t^2 \Rightarrow t = \pm13\\    &\quad\because t > 0 \quad \therefore t = 13\\    &\quad \therefore\omega = x -y =     \begin{bmatrix}5\\0\\-1\\\end{bmatrix} \\&\quad\therefore H(\omega) = I - \dfrac{2}{\omega^Tw}ww^T = \begin{bmatrix}1&0&0\\0&1&0\\0&0&1\\\end{bmatrix} -\dfrac{1}{13}\begin{bmatrix}25&0&-5\\0&0&0\\-5&0&1\\\end{bmatrix}\\&=\begin{bmatrix}-\dfrac{12}{13}&0&\dfrac{5}{13}\\0&1&0\\\dfrac{5}{13}&0&\dfrac{12}{13}\\\end{bmatrix}\end{aligned}$$<h2 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h2><p>证明：当$A$为非奇异矩阵时，有$\Vert A^{-1} \Vert_2=\dfrac{1}{\sigma_n}$，其中$\sigma_n$为$A$的最小奇异值</p>$$\begin{equation}\begin{aligned}&\because |A|\not=0\\&\therefore \exists n阶酉阵U,V使A=U\begin{bmatrix}\sigma_1&&&\\&\sigma_2&&\\&&\ddots&\\&&&\sigma_n\end{bmatrix}V^H\\&\quad 不妨设\sigma_1>\sigma_2>\cdots>\sigma_n\\&\quad同理有A^{-1}=U_1\begin{bmatrix}\dfrac{1}{\sigma_n}&&&\\&\ddots&&\\&&\dfrac{1}{\sigma_2}&\\&&&\dfrac{1}{\sigma_1}\end{bmatrix}V_1^H\\{A^{-1}}^HA^{-1}&=V_1\begin{bmatrix}\dfrac{1}{\sigma_n}&&&\\&\ddots&&\\&&\dfrac{1}{\sigma_2}&\\&&&\dfrac{1}{\sigma_1}\end{bmatrix}^HU_1^HU_1\begin{bmatrix}\dfrac{1}{\sigma_n}&&&\\&\ddots&&\\&&\dfrac{1}{\sigma_2}&\\&&&\dfrac{1}{\sigma_1}\end{bmatrix}V_1^H\\&=V_1\begin{bmatrix}\dfrac{1}{\sigma_n^2}&&&\\&\ddots&&\\&&\dfrac{1}{\sigma_2^2}&\\&&&\dfrac{1}{\sigma_1^2}\end{bmatrix}V_1^H\\\Vert A^{-1} \Vert_2^2&=\lambda_{max}({A^{-1}}^HA^{-1})=\sigma_{max}^2({A^{-1}}^HA^{-1})\\&\because V_1为酉矩阵\\&\therefore {A^{-1}}^HA^{-1} \sim\begin{bmatrix}\dfrac{1}{\sigma_n^2}&&&\\&\ddots&&\\&&\dfrac{1}{\sigma_2^2}&\\&&&\dfrac{1}{\sigma_1^2}\end{bmatrix}\\&\therefore \sigma_{max}^2({A^{-1}}^HA^{-1})=\dfrac{1}{\sigma_n^2}\\&\quad即\Vert A^{-1} \Vert_2=\dfrac{1}{\sigma_n},其中\sigma_n为A的最小特征值\end{aligned}\end{equation}$$<h2 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h2><p>设$A$的奇异值分解为：</p>$$\begin{equation}\begin{aligned}A&=\begin{bmatrix}\dfrac{3}{5}&-\dfrac{4}{5}&0\\\dfrac{-4}{5}&\dfrac{3}{5}&0\\0&0&-1\end{bmatrix}\begin{bmatrix}8&0&0\\0&6&0\\0&0&2\end{bmatrix}\begin{bmatrix}\dfrac{5}{13}&-\dfrac{12}{13}&0\\\dfrac{12}{13}&\dfrac{5}{13}&0\\0&0&1\end{bmatrix}\\\end{aligned}\end{equation}$$<p>求$\Vert A \Vert_2,\Vert A^{-1} \Vert_2,\Vert A \Vert_F,cond_2(A)$</p>$$\begin{equation}\begin{aligned}A&=\begin{bmatrix}\dfrac{3}{5}&-\dfrac{4}{5}&0\\\dfrac{-4}{5}&\dfrac{3}{5}&0\\0&0&-1\end{bmatrix}\begin{bmatrix}8&0&0\\0&6&0\\0&0&2\end{bmatrix}\begin{bmatrix}\dfrac{5}{13}&-\dfrac{12}{13}&0\\\dfrac{12}{13}&\dfrac{5}{13}&0\\0&0&1\end{bmatrix}\\\Vert A \Vert_2 &=\sigma_{max}(A) =8\\\Vert A^{-1} \Vert_2 &=\dfrac{1}{\sigma_{min}(A)} =\dfrac{1}{2}\\\Vert A \Vert_F&= \sqrt{tr(A^HA)}=\sqrt{\sigma_1^2+\sigma_2^2+\sigma_3^2}=2\sqrt{26}\\cond_2(A)&=\Vert A \Vert_2\Vert A^{-1} \Vert_2=4\end{aligned}\end{equation}$$<h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="第一题-1"><a href="#第一题-1" class="headerlink" title="第一题"></a>第一题</h2><p>已知四阶矩阵$A$的特征值分别为$\pi,-\pi,0,0$，求$sinA,cosA$</p>$$\begin{equation}\begin{aligned}&\because A的特征值为\pi,-\pi,0,0  \\&\therefore \psi(\lambda)=\lambda^2(\lambda-\pi)(\lambda+\pi) \\&sin(\lambda)=p(\lambda)\psi(\lambda)+b_3\lambda^3+b_2\lambda^2+b_1\lambda^1+b_0\\&\begin{cases}b_0=sin0=0  \\b_1=cos0=1  \\b_3\pi^3+b_2\pi^2+\pi=sin\pi=0 \\-b_3\pi^3+b_2\pi^2-\pi=sin(-\pi)=0\end{cases} \\&\Rightarrow b_0=0,b_1=1,b_2=0,b_3=-\dfrac{1}{\pi^2} \\&\therefore sin(\lambda)=p(\lambda)\psi(\lambda)-\dfrac{1}{\pi^2}\lambda^3+b_1\lambda^1\\&\therefore sin(A)=-\dfrac{1}{\pi^2}A^3+b_1A\\&cos(\lambda)=p(\lambda)\psi(\lambda)+b_3\lambda^3+b_2\lambda^2+b_1\lambda^1+b_0\\&\begin{cases}b_0=cos0=1  \\b_1=-sin0=0  \\b_3\pi^3+b_2\pi^2+1=cos\pi=-1 \\-b_3\pi^3+b_2\pi^2+1=cos(-\pi)=-1\end{cases} \\&\Rightarrow b_0=1,b_1=0,b_2=-\dfrac{2}{\pi^2},b_3=0\\&\therefore cos(\lambda)=p(\lambda)\psi(\lambda)-\dfrac{2}{\pi^2}\lambda^2+1\\&\therefore cos(A)=-\dfrac{2}{\pi^2}A^2+I\\\end{aligned}\end{equation}$$<h2 id="第二题-1"><a href="#第二题-1" class="headerlink" title="第二题"></a>第二题</h2><p>已知$  \begin{equation}  \begin{aligned}  A=  \begin{bmatrix}  2&1&0&0&0 \\  0&2&0&0&0 \\  0&0&3&1&0 \\  0&0&0&3&1 \\  0&0&0&0&3   \end{bmatrix}  \end{aligned}  \end{equation}  $，$f(z)=4+z+6z^3$，求$f(A)$</p>$$\begin{equation}\begin{aligned}&A=\begin{bmatrix}2&1&0&0&0 \\0&2&0&0&0 \\0&0&3&1&0 \\0&0&0&3&1 \\0&0&0&0&3 \end{bmatrix}\\&\Rightarrow A为Jordan标准型\\&\Rightarrow J_1=\begin{bmatrix}2&1\\0&2\end{bmatrix},J_2=\begin{bmatrix}3&1&0\\0&3&1\\0&0&3\end{bmatrix}\\&f(z)=4+z+6z^3\\&\therefore f(A)= \begin{bmatrix}f(J_1)&\\&f(J_2)\end{bmatrix}\\&f(J_1)=\begin{bmatrix}54&73\\0&54\end{bmatrix},f(J_2)=\begin{bmatrix}169&163&54\\0&169&163\\0&0&169\end{bmatrix}\\&\therefore f(A)=\begin{bmatrix}54&73&0&0&0\\0&54&0&0&0\\0&0&169&163&54\\0&0&0&169&163\\0&0&0&0&169\end{bmatrix}\end{aligned}\end{equation}$$<h2 id="第三题-1"><a href="#第三题-1" class="headerlink" title="第三题"></a>第三题</h2><p>已知$  sin(tA)=\dfrac{1}{4}  \begin{bmatrix}  sin5t+sin3t&2sin5t-2sint\\  sin5t-sint&2sin5t+2sint  \end{bmatrix}    $，试求出矩阵$A$以及矩阵$A$的$Jordan$标准型</p>$$\begin{equation}\begin{aligned}&sin(tA)=\dfrac{1}{4}\begin{bmatrix}sin5t+sin3t&2sin5t-2sint\\sin5t-sint&2sin5t+2sint\end{bmatrix}\\&sin(tA)'=Acos(tA)=\dfrac{1}{4}\begin{bmatrix}5cos5t+3cos3t&10cos5t-2cost\\5cos5t-cost&10cos5t+2cost\end{bmatrix}\\&令t=0\\&A=\begin{bmatrix}2&2\\1&3\end{bmatrix}\\&|\lambda I-A|=\left |\begin{array}{cccc}\lambda-2&-2\\-1&\lambda-3  \end{array}\right|=0\\&\Rightarrow (\lambda-4)(\lambda-1)=0\\&\Rightarrow \lambda_1=4,\lambda_2=1\\&\Rightarrow J=\begin{bmatrix}1&0\\0&4\end{bmatrix}\\\end{aligned}\end{equation}$$<h2 id="第四题-1"><a href="#第四题-1" class="headerlink" title="第四题"></a>第四题</h2><p>已知$A\in R^{m\times n},b\in R^m$，对于矛盾方程组$Ax=b$，使得$f(x)=\Vert Ax-b\Vert_2^2$为最小的向量$x^{(0)}$称为最小二乘解，导出最小二乘解所满足的方程组</p>$$\begin{equation}\begin{aligned}\because A&\in R^{m\times n},b\in R^m\\f(x)&=\Vert Ax-b\Vert_2^2\\&=(Ax-b,Ax-b)=(Ax-b)^T(Ax-b)\\&=x^TA^TAx-x^TA^Tb-b^TAx+b^Tb\\&=x^TA^TAx-x^T(A^Tb)-(A^Tb)^Tx+b^Tb\\\frac{\mathrm{d}f}{\mathrm{d} x}&=2(A^TAx-A^Tb)\\当&\frac{\mathrm{d}f}{\mathrm{d} x}=0时，即A^TAx-A^Tb=0时\\存在&x^{(0)}为最小二乘解，方程组为A^TAx-A^Tb=0\end{aligned}\end{equation}$$<h2 id="第五题-1"><a href="#第五题-1" class="headerlink" title="第五题"></a>第五题</h2><p>设$ A= \begin{bmatrix} cosu&-sinu\\ sinu&cosu \end{bmatrix} $，求<br> （1）$\frac{\mathrm{d} }{\mathrm{d} u}(e^uA),\frac{\mathrm{d} }{\mathrm{d} u}(A^{-1}(u))$<br> （2）$若u=e^{2t},求\frac{\mathrm{d} }{\mathrm{d} t}A(u)$</p> $$ \begin{equation} \begin{aligned} &\because A= \begin{bmatrix} cosu&-sinu\\ sinu&cosu \end{bmatrix}\\ &(1)\frac{\mathrm{d} }{\mathrm{d} u}(e^uA),\frac{\mathrm{d} }{\mathrm{d} u}(A^{-1}(u))\\ &\frac{\mathrm{d} }{\mathrm{d} u}(e^uA)=e^uA+e^u\frac{\mathrm{d} A}{\mathrm{d} u}= e^u\begin{bmatrix} cosu-sinu&-sinu-cosu\\ sinu+cosu&cosu-sinu \end{bmatrix}\\ &\frac{\mathrm{d} }{\mathrm{d} u}(A^{-1}(u))= -A^{-1}(u)\left( \frac{\mathrm{d} }{\mathrm{d} u}A(u) \right)A^{-1}(u)\\ &A^{-1}(u)= \begin{bmatrix} cosu&sinu\\ -sinu&cosu \end{bmatrix}\\ &\therefore \frac{\mathrm{d} }{\mathrm{d} u}(A^{-1}(u))= -\begin{bmatrix} cosu&sinu\\ -sinu&cosu \end{bmatrix} \begin{bmatrix} -sinu&-cosu\\ cosu&-sinu \end{bmatrix} \begin{bmatrix} cosu&sinu\\ -sinu&cosu \end{bmatrix}\\ &\qquad\qquad\qquad= \begin{bmatrix} -sinu&cosu\\ -cosu&-sinu \end{bmatrix}\\ &(2)若u=e^{2t},求\frac{\mathrm{d} }{\mathrm{d} t}A(u)\\ &\frac{\mathrm{d} }{\mathrm{d} t}A(u)={e^{2t}}'\frac{\mathrm{d} }{\mathrm{d} u}A(u)=2e^{2t} \begin{bmatrix} -sinu&-cosu\\ cosu&-sinu \end{bmatrix} \end{aligned} \end{equation} $$<h2 id="第六题-1"><a href="#第六题-1" class="headerlink" title="第六题"></a>第六题</h2><p> 设$  A=  \begin{bmatrix}  2&2&1 \\  1&3&1 \\  1&1&3  \end{bmatrix}  $，试用有限待定系数法计算$cosA$</p>  $$  \begin{equation}  \begin{aligned}  &A=  \begin{bmatrix}  2&2&1 \\  1&3&1 \\  1&1&3  \end{bmatrix}\\  &|\lambda I -A|=  \left |\begin{array}{cccc}  \lambda-2&-2&-1 \\  -1&\lambda-3& -1  \\  -1& -1&\lambda-3 \\  \end{array}\right|=0\\  &\psi(\lambda)=(\lambda-1)(\lambda-2)(\lambda-5)\\  &cosA=p(\lambda)\psi(\lambda)+b_2\lambda^2+b_1\lambda+b_0\\  &\Rightarrow   \begin{cases}  b_2+b_1+b_0=cos1\\  4b_2+2b_1+b_0=cos2\\  25b_2+5b_1+b_0=cos5  \end{cases}\\  &\Rightarrow   \begin{cases}  b_2=\dfrac{1}{12}(cos5-4cos2+3cos1)\\  b_1=\dfrac{1}{12}(-3cos5+24cos2-21cos1)\\  b_0=\dfrac{1}{12}(2cos5-20cos2+30cos1)  \end{cases}\\  &cosA=\dfrac{1}{12}(cos5-4cos2+3cos1)A^2+\dfrac{1}{12}(-3cos5+24cos2-21cos1)A\\  &\qquad\quad+\dfrac{1}{12}(2cos5-20cos2+30cos1)\\  &\qquad\quad=  \dfrac{1}{12}(cos5-4cos2+3cos1)  \begin{bmatrix}  7&11&7 \\  6&12&7 \\  6&8&11  \end{bmatrix}\\  &\qquad\quad+\dfrac{1}{12}(-3cos5+24cos2-21cos1)  \begin{bmatrix}  2&2&1 \\  1&3&1 \\  1&1&3  \end{bmatrix}\\  &\qquad\quad+\dfrac{1}{12}(2cos5-20cos2+30cos1)  \begin{bmatrix}  1&0&0 \\  0&1&0 \\  0&0&1   \end{bmatrix}\\  &\qquad\quad=  \dfrac{1}{12}\begin{bmatrix}  3cos5+9cos1&5cos5+4cos2-9cos1&4cos5-4cos2 \\  3cos5-3cos1&5cos5+4cos2+3cos1&4cos5-4cos2 \\  3cos5-3cos1&5cos5-8cos2+3cos1&4cos5+8cos2   \end{bmatrix}  \end{aligned}  \end{equation}  $$<h2 id="第七题-1"><a href="#第七题-1" class="headerlink" title="第七题"></a>第七题</h2><p>  设$   A=    \begin{bmatrix}   0.6&0 \\   0.4&0.5   \end{bmatrix}   $，证明$\sum\limits_{k=0}^\infty A^k$收敛，并计算$\sum\limits_{k=0}^\infty A^k$</p>   $$   \begin{equation}   \begin{aligned}   &A=    \begin{bmatrix}   0.6&0 \\   0.4&0.5   \end{bmatrix}\\   &\because\Vert A \Vert_\infty=0.4+0.5=0.9\\   &\therefore \lim\limits_{k\rightarrow\infty}A^k =0\\   &\therefore \sum\limits_{k=0}^\infty A^k收敛\\   &\therefore \sum\limits_{k=0}^\infty=(I-A)^{-1} \\   &\qquad\quad =   \begin{bmatrix}   0.4&0\\   -0.4&0.5   \end{bmatrix}^{-1} \\   &\qquad\quad =   \begin{bmatrix}   2.5&0\\   2&2   \end{bmatrix}   \end{aligned}   \end{equation}   $$<h2 id="第八题-1"><a href="#第八题-1" class="headerlink" title="第八题"></a>第八题</h2><p>   证明$f(A^T)=[f(A)]^T$，并利用此结果计算$sintA,e^{tA}$，其中<br>   $$   A=   \begin{bmatrix}   1&&& \\   1&1&& \\   &1&1& \\   &&1&1   \end{bmatrix}   $$</p>   $$   \begin{equation}   \begin{aligned}   f(A^T)&=\sum\limits_{k=0}^\infty a_k(A^T)^k\\   &=a_1A^T+a_2(A^T)^2+\cdots+a_j(A^T)^j+\cdots\\   &=a_1A^T+a_2(A^2)^T+\cdots+a_j(A^j)^T+\cdots\\   &=\left(\sum\limits_{k=0}^\infty a_kA^k\right)^T = [f(A)]^T\\   A&=   \begin{bmatrix}   1&&& \\   1&1&& \\   &1&1& \\   &&1&1   \end{bmatrix}\\   A^T&=   \begin{bmatrix}   1&1&& \\   &1&1& \\   &&1&1 \\   &&&1   \end{bmatrix}为Jordan标准型且\lambda=1\\   \therefore(sintA)^T&=sintA^T=   \begin{bmatrix}   sint&tcost&-\dfrac{t^2sint}{2}&-\dfrac{t^3cost}{6} \\   &sint&tcost&-\dfrac{t^2sint}{2} \\   &&sint&tcost \\   &&&sint   \end{bmatrix}\\   \therefore sintA&=   \begin{bmatrix}   sint&&& \\   tcost&sint&& \\   -\dfrac{t^2sint}{2}&tcost&sint& \\   -\dfrac{t^3cost}{6}&-\dfrac{t^2sint}{2}&tcost&sint   \end{bmatrix}\\   \therefore (e^{tA})^T&=e^{tA^T}=   \begin{bmatrix}   e^t&te^t&\dfrac{t^2e^t}{2}&\dfrac{t^3e^t}{6} \\   &e^t&te^t&\dfrac{t^2e^t}{2} \\   &&e^t&te^t \\   &&&e^t   \end{bmatrix}\\   \therefore e^{tA}&=   \begin{bmatrix}   e^t&&& \\   te^t&e^t&& \\   \dfrac{t^2e^t}{2}&te^t&e^t& \\   \dfrac{t^3e^t}{6}&\dfrac{t^2e^t}{2}&te^t&e^t   \end{bmatrix}\\   \end{aligned}   \end{equation}   $$<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="第一题-2"><a href="#第一题-2" class="headerlink" title="第一题"></a>第一题</h2>$$\begin{equation}\begin{aligned}(A)\quad A&=\begin{bmatrix}1&1&2\\0&0&2\\2&0&1\\\end{bmatrix}\\D&=diag\{ 1,0,1 \}\\L&=\begin{bmatrix}0&0&0\\0&0&0\\-2&0&0\\\end{bmatrix}\\U&=\begin{bmatrix}0&-1&-2\\0&0&-2\\0&0&0\\\end{bmatrix}\\|\lambda I-B_G|&=|\lambda I-(D-L)^{-1}U|\\&=|(D-L)^{-1}||\lambda(D-L)-U|=0\\&\Rightarrow |\lambda(D-L)-U|=0\\|\lambda(D-L)-U|&=\left |\begin{array}{cccc}\lambda&1&2\\0&0&2\\2\lambda&0&\lambda\\\end{array}\right|=0\\&\Rightarrow \lambda=0\\&\therefore(A)收敛\\(B)\quad A&=\begin{bmatrix}3&1&1\\0&1&2\\1&0&\dfrac{1}{2}\\\end{bmatrix}\\|\lambda(D-L)-U|&=\left |\begin{array}{cccc}3\lambda&1&1\\0&\lambda&2\\\lambda&0&\dfrac{1}{2}\lambda\\\end{array}\right|=0\\&\Rightarrow \dfrac{3}{2}\lambda[(\lambda-\dfrac{1}{3})^2+\dfrac{11}{9}]\\&\Rightarrow \lambda=0\\&\therefore(B)收敛\\(C)\quad A&=\begin{bmatrix}5&2&1\\-2&-8&-3\\1&-1&-4\\\end{bmatrix}\\&\because |5|>|2|+|1|,|-8|>|-2|+|-3|\\&\quad |-4|>|1|+|-1|\\&\therefore A为严格对角占优矩阵，故(C)收敛\\(D)\quad A&=\begin{bmatrix}1&-9&-7\\0&2&2\\0&-2&1\\\end{bmatrix}\\|\lambda(D-L)-U|&=\left |\begin{array}{cccc}\lambda&-9&-7\\0&2\lambda&2\\0&-2\lambda&\lambda\\\end{array}\right|=0\\&\Rightarrow \lambda=0,-2\\&\because \rho(\lambda)=|-2|>0\\&\therefore (C)发散\end{aligned}\end{equation}$$<h2 id="第二题-2"><a href="#第二题-2" class="headerlink" title="第二题"></a>第二题</h2>$$\begin{equation}\begin{aligned}(1)\quad A&=\begin{bmatrix}3&7&1\\0&4&t-1\\0&3-t&-1\\\end{bmatrix}\\B_J=D^{-1}(L+U)&=\begin{bmatrix}\dfrac{1}{3}&0&0\\0&\dfrac{1}{4}&0\\0&0&-1\\\end{bmatrix}\begin{bmatrix}0&-7&-1\\0&0&1-t\\0&t-3&0\\\end{bmatrix}\\&=\begin{bmatrix}0&-\dfrac{7}{3}&-\dfrac{1}{3}\\0&0&\dfrac{1-t}{4}\\0&3-t&0\\\end{bmatrix}\\|\lambda I-B_J|&=\left |\begin{array}{cccc}\lambda&\dfrac{7}{3}&\dfrac{1}{3}\\0&\lambda&\dfrac{t-1}{4}\\0&t-3&\lambda\\\end{array}\right|=0\\&\Rightarrow \lambda(\lambda^2-\dfrac{(t-1)(t-3)}{4})=0\\&\Rightarrow \lambda=0,\sqrt{\dfrac{(t-1)(t-3)}{4}}\\&若Jacobi迭代收敛，则|\lambda|=\left\vert \sqrt{\dfrac{(t-1)(t-3)}{4}} < 1 \right\vert \\&\Rightarrow 0 \le (t-1)(t-3) < 4\\&\Rightarrow 2 - \sqrt{5} < t \le 1 或 3 \le t  < 2 + \sqrt{5}\\(2)\quad |\lambda I-B_G|&=|\lambda(D-L)-U|\\&=\left |\begin{array}{cccc}3\lambda&7&1\\0&4\lambda&t-1\\0&(3-t)\lambda&-\lambda\\\end{array}\right|=0\\&\Rightarrow -3 \lambda^2 (4 \lambda - (t-1)(t-3)) = 0\\&\Rightarrow \lambda = 0,\dfrac{(t-1)(t-3)}{4}\\&\because -4 < (t-1)(t-3) < 4\\&\therefore 2 - \sqrt{5}< \lambda < 2 + \sqrt{5}\\&\therefore G-S迭代收敛\end{aligned}\end{equation}$$<h2 id="第三题-2"><a href="#第三题-2" class="headerlink" title="第三题"></a>第三题</h2>$$\begin{equation}\begin{aligned}&\because\begin{bmatrix}4&-1&0\\-1&1&-1\\0&-1&1\\\end{bmatrix}\begin{bmatrix}x_1\\x_2\\x_3\\\end{bmatrix}=\begin{bmatrix}3\\-1\\0\\\end{bmatrix}\\&\because x^{(0)}=[0,0,0]^T\\&\begin{cases}x_1^{(1)}=\dfrac{1}{4}(3-0)=\dfrac{3}{4}\\x_2^{(1)}=(-1+\dfrac{3}{4}-0)=-\dfrac{1}{4}\\x_3^{(1)}=(0-\dfrac{1}{4})=-\dfrac{1}{4}\\\end{cases}\\&\therefore x^{(1)}=[\dfrac{3}{4},-\dfrac{1}{4},-\dfrac{1}{4}]\\&\begin{cases}x_1^{(2)}=\dfrac{1}{4}(3-\dfrac{1}{4})=\dfrac{11}{16}\\x_2^{(2)}=(-1+\dfrac{11}{16}-\dfrac{1}{4})=-\dfrac{9}{16}\\x_3^{(1)}=(0-\dfrac{9}{16})=-\dfrac{9}{16}\\\end{cases}\\&\therefore x^{(2)}=[\dfrac{11}{16},-\dfrac{9}{16},-\dfrac{9}{16}]\\\end{aligned}\end{equation}$$<h2 id="第四题-2"><a href="#第四题-2" class="headerlink" title="第四题"></a>第四题</h2>$$\begin{equation}\begin{aligned}\phi(x)& = x - \alpha(e^x - e^{-x})\\&\because \exists x_0 = 0 \Rightarrow \phi(0)=0 \\\phi'(x)& = 1 - \alpha(e^x + e^{-x})\\|\phi'(0)|& = |1-2\alpha| < 1时，\phi(x)局部收敛\\&\therefore \alpha \in (0,1)\\|\phi'(0)|& = |1 - 2 \alpha | = 0时，\phi(x)至少是平方收敛\\&\therefore \alpha = \dfrac{1}{2}\\\end{aligned}\end{equation}$$<h2 id="第五题-2"><a href="#第五题-2" class="headerlink" title="第五题"></a>第五题</h2>$$\begin{equation}\begin{aligned}x^{(k+1)}&=x^{(k)}+\omega(b-Ax^{(k)})\\x^{(k+1)}&=(I-\omega A)x^{(k)}+\omega b\\令B& = I - \omega A\\\rho(B)& = |1 - \omega \rho(A)| \\当\rho(B)& < 1时，迭代收敛\\&\Rightarrow -1 < 1 - \omega \rho(A) < 1\\&\Rightarrow 0 < \omega < \dfrac{2}{\rho(A)}\\\end{aligned}\end{equation}$$<h2 id="第六题-2"><a href="#第六题-2" class="headerlink" title="第六题"></a>第六题</h2>$$\begin{equation}\begin{aligned}(1)\quad x& = 1+\dfrac{1}{x^2}\\\varphi'(x)& = -\dfrac{2}{x^3}\\|\varphi'(x_0)|& = \left |-\dfrac{2}{1.5^3}\right | < 1\\&\therefore (1)收敛\\x_1&=1+ \dfrac{1}{1.5^2}=\dfrac{13}{9} \\k &\ge \log_{}\\(2)\quad x& = \sqrt[3]{1+x^2}\\\varphi'(x)& = \dfrac{2x}{3(1+x)^{\frac{2}{3}}}\\|\varphi'(x_0)|&= \left |\dfrac{1}{2.5^{\frac{2}{3}}}\right| < 1\\&\therefore (2)收敛\\(3)\quad x& = \sqrt{x^3-1}\\\varphi'(x)& = \dfrac{3x^2}{2\sqrt{x^3-1}}\\|\varphi'(x_0)|& = \left |\dfrac{1.5^3}{\sqrt{1.5^3-1}}\right| > 1\\&\therefore (3)发散\\(4)\quad x& = \dfrac{1}{\sqrt{x-1}}\\\varphi'(x)& = -\dfrac{1}{2(x-1)^{\frac{3}{2}}}\\|\varphi'(x_0)|& =\left |-\dfrac{1}{\sqrt{0.5}}\right| > 1\\&\therefore (4)发散\\&\because x^3 - x^2 - 1 = 0\\&\therefore \phi(x) = x-\dfrac{x^3-x^2-1}{3x^2-2x}\\&\because x_0 = 1.5\\&\therefore x_1 = 1.466666,x_2 = 1.465572 , x_3 = 1.465571\\&\because x_2 - x_3 = 0.000001 < \dfrac{1}{2} \times 10^{-3}\\&\therefore x \approx 1.465571\end{aligned}\end{equation}$$<h2 id="第七题-2"><a href="#第七题-2" class="headerlink" title="第七题"></a>第七题</h2>$$\begin{equation}\begin{aligned}f(x)&=x^3+2x^2+10x-20=0\\x&=x-\dfrac{x^3+2x^2+10x-20}{3x^2+4x+10}\\&取初值x_0=1\\x_1&=\dfrac{24}{17}=1.411764\\x_2&=1.369336\\x_3&=1.368808\end{aligned}\end{equation}$$<h2 id="第八题-2"><a href="#第八题-2" class="headerlink" title="第八题"></a>第八题</h2>$$\begin{equation}\begin{aligned}&\begin{bmatrix}6&3\\3&2\\\end{bmatrix}\begin{bmatrix}x_1\\x_2\end{bmatrix}=\begin{bmatrix}0\\1\end{bmatrix}\\\because& 系数矩阵对称正定\\\therefore& 取x_0=[0,0]^T\\r_o&=b-Ax_0=[0,1]^T=p_0\\\alpha_0&=\dfrac{(r_0,r_0)}{(p_0,Ap_0)}=\dfrac{1}{2}\\x_1&=x_0+\alpha_0p_0=[0,\dfrac{1}{2}]^T\\r_1&=r_0-\alpha_0Ap_0=[-\dfrac{3}{2},0]^T\\\beta_0&=\dfrac{(r_1,r_1)}{(r_0,r_0)}=\dfrac{9}{4}\\p_1&=r_1+\beta_0p_0=[-\dfrac{3}{2},\dfrac{9}{4}]^T\\\alpha_1&=\dfrac{(r_1,r_1)}{(p_1,Ap_1)}=\dfrac{2}{3}\\x_2&=x_1+\alpha_1p_1=[-1,2]^T\\r_2&=r_1-\alpha_1Ap_1=[0,0]^T\\&\therefore x=[-1,2]^T\end{aligned}\end{equation}$$<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="第一题-3"><a href="#第一题-3" class="headerlink" title="第一题"></a>第一题</h2><p>求一个4次多项式$p(x)$，使得<br>$p(-1)=1,p(0)=1,p(1)=5,p(2)=13,p(-2)=29$$$\begin{equation}\begin{aligned}设p(x)&=a_4x^4+a_3x^3+a_2x^2+a_1x+a_0\\&\Leftrightarrow\begin{bmatrix}1&-1&1&-1&1\\0&0&0&0&1\\1&1&1&1&1\\16&8&4&2&1\\16&-8&4&-2&1\\\end{bmatrix}\begin{bmatrix}a_4\\a_3\\a_2\\a_1\\a_0\\\end{bmatrix}=\begin{bmatrix}1\\1\\5\\13\\29\end{bmatrix}\\&\Rightarrow \begin{bmatrix}a_4\\a_3\\a_2\\a_1\\a_0\\\end{bmatrix}=\begin{bmatrix}\dfrac{8}{3}\\-2\\-\dfrac{2}{3}\\4\\1\\\end{bmatrix}\\&\therefore p(x)=\dfrac{8}{3}x^4-2x^3-\dfrac{2}{3}x^2+4x+1\end{aligned}\end{equation}$$</p><h2 id="第二题-3"><a href="#第二题-3" class="headerlink" title="第二题"></a>第二题</h2><p>设$x_0,x_1,\cdots,x_n$是互异的插值节点组，$l_i(x)$是$Lagrange$插值基函数</p>$l_i(x)=\dfrac{\omega_{n+1}(x)}{(x-x_i)\omega'_{n+1}(x_i)}\quad \omega_{n+1}(x)=(x-x_0)\cdots(x-x_n)$<p>试求$\sum\limits_{i=0}^n x_i^kl_i(x)\quad 0\le k\le n$$$\begin{equation}\begin{aligned}&\because  l_i(x)是Lagrange插值基函数\\&\therefore l_i(x)在其定义域上满足Haar条件\\&\therefore l_i(x_j)=\begin{cases}1\quad i=j\\0\quad i\not=j\end{cases}\quad i =1,2,\cdots,n;j=1,2,\cdots,n\\&\therefore\sum\limits_{i=0}^n x_i^kl_i(x)=x_i^k\\\end{aligned}\end{equation}$$</p><h2 id="第三题-3"><a href="#第三题-3" class="headerlink" title="第三题"></a>第三题</h2><p>求$[0,1]$上以$\rho(x)=1$为权函数的标准正交多项式系$\psi_0(x),\psi_1(x),\psi_2(x)$$$\begin{equation}\begin{aligned}&\phi_0(x)=\mu_0=\int_0^1 1dx=1\\&\mu_1=\int_0^1 xdx = \dfrac{1}{2}\\&\phi_1(x)=\left |\begin{array}{cccc}1&1\\\dfrac{1}{2}&x\\\end{array}\right|=x-\dfrac{1}{2}\\&\mu_2=\int_0^1 x^2dx=\dfrac{1}{3}\\&\mu_3=\int_0^1 x^3dx=\dfrac{1}{4}\\&\phi_2(x)=\left |\begin{array}{cccc}1&\dfrac{1}{2}&1\\\dfrac{1}{2}&\dfrac{1}{3}&x\\\dfrac{1}{3}&\dfrac{1}{4}&x^2\\\end{array}\right|=\dfrac{1}{12}x^2-\dfrac{1}{12}x+\dfrac{1}{72}\\&\psi_0(x)=1\\&\Delta_1=\left |\begin{array}{cccc}1&\dfrac{1}{2}\\\dfrac{1}{2}&\dfrac{1}{3}\end{array}\right|=\dfrac{1}{12}\quad \psi_1(x)=\dfrac{\phi_1(x)}{\sqrt{\Delta_0\Delta_1}}=2\sqrt{3}x-\sqrt{3}\\&\mu_4=\int_0^1 x^4dx=\dfrac{1}{5}\quad \Delta_2=\left |\begin{array}{cccc}1&\dfrac{1}{2}&\dfrac{1}{3}\\\dfrac{1}{2}&\dfrac{1}{3}&\dfrac{1}{4}\\\dfrac{1}{3}&\dfrac{1}{4}&\dfrac{1}{5}\\\end{array}\right|=\dfrac{1}{2160}\\&\psi_2(x)=\dfrac{\phi_2(x)}{\sqrt{\Delta_1\Delta_2}}=6\sqrt{5}x^2-6\sqrt{5}x+\sqrt{5}\\&\therefore \psi_0(x)=1,\psi_1(x)=2\sqrt{3}x-\sqrt{3},\psi_2(x)=6\sqrt{5}x^2-6\sqrt{5}x+\sqrt{5}\end{aligned}\end{equation}$$</p><h2 id="第四题-3"><a href="#第四题-3" class="headerlink" title="第四题"></a>第四题</h2><p>用最小二乘法求拟合下列数据的二次多项式</p><table><thead><tr><th align="center">$x_i$</th><th align="center">1</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th><th align="center">10</th></tr></thead><tbody><tr><td align="center">$y_i$</td><td align="center">10</td><td align="center">5</td><td align="center">4</td><td align="center">2</td><td align="center">1</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td></tr></tbody></table>$$\begin{equation}\begin{aligned}&法方程组为:\begin{bmatrix}9&53\\53&381\end{bmatrix}\begin{bmatrix}a\\b\end{bmatrix}=\begin{bmatrix}32\\147\end{bmatrix}\\&\Rightarrow \begin{bmatrix}a\\b\end{bmatrix}=\begin{bmatrix}7.0983\\-0.6016\end{bmatrix}\\&\therefore y=7.0983x-0.6016\end{aligned}\end{equation}$$<h2 id="第五题-3"><a href="#第五题-3" class="headerlink" title="第五题"></a>第五题</h2><p>判断下列函数是否为各自定义域上的三次样条函数</p>$\begin{equation}\begin{aligned}&(1)\quad s(x)=\begin{cases}2+3x+4x^2+x^3\quad x\in[-1,0]\\2+3x+4x^2+4x^3\quad x\in[0,1]\\1+6x+x^2+5x^3\quad x\in[1,2]\\\end{cases}\\&(2)\quad s(x)=\begin{cases}x^3+2x+1\quad x\in[0,1]\\x^3+x^2+2\quad x\in[1,2]\end{cases}\end{aligned}\end{equation}$ $$\begin{equation}\begin{aligned}&根据光滑因子进行判断\\(1)\quad &(2+3x+4x^2+4x^3)-(2+3x+4x^2+x^3)=3x^3\\&(1+6x+x^2+5x^3)-(2+3x+4x^2+4x^3)=-1+3x-3x^2+x^3 = (x-1)^3\\&故(1)满足\\(2)\quad &(x^3+x^2+2)-(x^3+2x+1)=x^2-2x+1\\&故(2)不满足\\\end{aligned}\end{equation}$$<h2 id="第六题-3"><a href="#第六题-3" class="headerlink" title="第六题"></a>第六题</h2><p>根据如下离散数据，请用最小二乘法拟合出形如$y=\dfrac{x}{ax+b}$的曲线</p><table><thead><tr><th align="center">$x_{i}$</th><th align="center">1</th><th align="center">$\dfrac{1}{2}$</th><th align="center">$\dfrac{1}{3}$</th><th align="center">$\dfrac{1}{4}$</th><th align="center">$\dfrac{1}{5}$</th></tr></thead><tbody><tr><td align="center">$y_i$</td><td align="center">$\dfrac{1}{2}$</td><td align="center">$\dfrac{1}{4}$</td><td align="center">$\dfrac{5}{32}$</td><td align="center">$\dfrac{1}{8}$</td><td align="center">$\dfrac{5}{43}$</td></tr></tbody></table>$$\begin{equation}\begin{aligned}&\because y=\dfrac{x}{ax+b}\\&\therefore \dfrac{1}{y}=b\dfrac{1}{x}+a\\&法方程组为:\begin{bmatrix}5&15\\15&25\end{bmatrix}\begin{bmatrix}b\\a\end{bmatrix}=\begin{bmatrix}29\\100.2\end{bmatrix}\\&\Rightarrow \begin{bmatrix}b\\a\end{bmatrix}=\begin{bmatrix}0.64\\1.72\end{bmatrix}\\&\Rightarrow y=\dfrac{x}{1.72x+0.64}\end{aligned}\end{equation}$$<h2 id="第七题-3"><a href="#第七题-3" class="headerlink" title="第七题"></a>第七题</h2><p>确定下列函数组在指定的区间上是否满足$Haar$条件</p>$(1){1,x,x^2,\cdots,x^m}$在任意闭区间$[a,b]$上；$(2){1,x^2,x^4,x^6}$在闭区间$[0,1]$上；$(3){1,x^2,x^4}$在闭区间$[-1,1]$上；$$\begin{equation}\begin{aligned}(1)\quad &在[a,b]上\forall取m+1个互异点{x_0,x_1,\cdots,x_m}\\&D[x_0,x_1,\cdots,x_m]=\left |\begin{array}{cccc}1&x_0&x_0^2&\cdots&x_0^m\\1&x_1&x_1^2&\cdots&x_1^m\\\vdots&\vdots&\vdots&&\vdots\\1&x_m&x_m^2&\cdots&x_m^m\\\end{array}\right|=\prod\limits_{0\le i < j\le m}(x_i-x_j)\not=0\\&\therefore (1)满足Haar条件\\(2)\quad &在[0,1]上取{0\le x_0 < x_1 < x_2 < x_3\le 1}\\&D[x_0,x_1,x_2,x_3]=\left |\begin{array}{cccc}1&x_0^2&x_0^4&x_0^6\\1&x_1^2&x_1^4&x_1^6\\1&x_2^2&x_2^4&x_2^6\\1&x_3^2&x_3^4&x_3^6\end{array}\right|\not=0\\&\therefore (2)满足Haar条件\\(3)\quad &在[-1,1]上取{-1,0,1}\\&D[-1,0,1]=\left |\begin{array}{cccc}1&1&1\\1&0&0\\1&1&1\\\end{array}\right|=0\\&\therefore (3)不满足Haar条件\\\end{aligned}\end{equation}$$<h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><h2 id="第一题-4"><a href="#第一题-4" class="headerlink" title="第一题"></a>第一题</h2><p>取7个节点的函数值，分别利用复化的梯形公式和复化$Simpson$公式计算积分</p><p>$\int_0^{\frac{\pi}{2}}\dfrac{\sin x}{x}dx$的近似值$(\lim\limits_{x\rightarrow 0}\dfrac{\sin x}{x}=1)$$$\begin{equation}\begin{aligned}(1)\quad &复化梯形公式\\&取7个等距节点0,\dfrac{\pi}{12},\dfrac{2\pi}{12},\dfrac{3\pi}{12},\dfrac{4\pi}{12},\dfrac{5\pi}{12},\dfrac{\pi}{2}\\&\int_0^{\frac{\pi}{2}}\dfrac{\sin x}{x}dx=\dfrac{\pi}{24}(f(0)+2(f(\dfrac{\pi}{12})+f(\dfrac{2\pi}{12})+f(\dfrac{3\pi}{12})+f(\dfrac{4\pi}{12})+f(\dfrac{5\pi}{12}))+f(\dfrac{\pi}{2}))\\&\qquad\qquad\qquad = 1.368446\\(1)\quad &复化Simpson公式\\&7个节点，n=3\\&S_3=\dfrac{\pi}{36}(f(0)+2(f(\dfrac{2\pi}{12})+f(\dfrac{4\pi}{12}))+4(f(\dfrac{\pi}{12})+f(\dfrac{3\pi}{12})+f(\dfrac{5\pi}{12}))+f(\dfrac{\pi}{2}))\\&\quad = 1.370768\end{aligned}\end{equation}$$</p><h2 id="第二题-4"><a href="#第二题-4" class="headerlink" title="第二题"></a>第二题</h2><p>确定求积公式$\int_{-1}^1f(x)dx\approx Af(-1)+Bf(x_1)$中的待定系数，使其代数精度尽可能高，并指出其代数精度</p>$$\begin{equation}\begin{aligned}&因为有3个未知数，故分别取f(x)=1,x,x^2\\&\begin{cases}\int_{-1}^11dx= 2 = A+B\\\int_{-1}^1xdx= 0 = -A+Bx_1\\\int_{-1}^1x^2dx= \dfrac{2}{3} = A+Bx_1^2\\\end{cases}\\&\Rightarrow\begin{cases}A=\dfrac{3}{2}\\B=\dfrac{1}{2}\\x_1=\dfrac{1}{3}\end{cases}\\&\therefore \int_{-1}^1f(x)dx\approx \dfrac{3}{2}f(-1)+\dfrac{1}{2}f(\dfrac{1}{3})\\&当f(x)=x^3时\\&\int_{-1}^1x^3dx = 0\not= -\dfrac{3}{2}+\dfrac{1}{2}\times\dfrac{1}{27}\\&所以代数精度为2\end{aligned}\end{equation}$$<h2 id="第三题-4"><a href="#第三题-4" class="headerlink" title="第三题"></a>第三题</h2><p>$\omega_0(x),\omega_1(x),\cdots,\omega_n(x),\cdots$是$[a,b]$上以$\rho(x)$为权函数的标准正交多项式系，$x_i(i=0,1,\cdots,n)$是$\omega_{n+1}(x)$的零点，$\int_a^b\rho(x)f(x)dx\approx\sum\limits_{k=0}^nA_kf(x_k)$是以$x_i(i=0,1,\cdots,n)$为节点的$Gauss$型求积公式，证明：当$0\le i &lt; j\le n$时，$\sum\limits_{k=0}^nA_k\omega_i(x_k)\omega_j(x_k)=0$</p>$$\begin{equation}\begin{aligned}&\int_a^b\rho(x)f(x)dx\approx\sum\limits_{k=0}^nA_kf(x_k)\\&具有(2n+1)次代数精度，而当0\le i < j\le n时deg(\omega_j(x)\omega_i(x))=i+j < 2n\\&因此根据正交多项式的正交性有\\&\sum\limits_{k=0}^nA_k\omega_j(x_k)\omega_i(x_k)=\int_a^b\rho(x)\omega_j(x)\omega_i(x)=0\end{aligned}\end{equation}$$<h2 id="第四题-4"><a href="#第四题-4" class="headerlink" title="第四题"></a>第四题</h2><p>利用$Gauss-Legendre$公式构造$Gauss$型求积公式</p><p>$\int_0^1f(x)dx\approx A_0f(x_0)+A_1f(x_1)$</p>$$\begin{equation}\begin{aligned}&已知，两点Gauss-Legendre公式为\int_{-1}^1f(x)dx\approx f(\dfrac{\sqrt{3}}{3})+f(-\dfrac{\sqrt{3}}{3})\\&令t=2x-1,即x=\dfrac{t+1}{2}\\&\int_0^1f(x)dx=\dfrac{1}{2}\int_{-1}^1f(\dfrac{t+1}{2})dt\approx \dfrac{1}{2}f(\dfrac{\sqrt{3}+3}{6})+\dfrac{1}{2}f(-\dfrac{\sqrt{3}+3}{6})\end{aligned}\end{equation}$$<h2 id="第五题-4"><a href="#第五题-4" class="headerlink" title="第五题"></a>第五题</h2><p>利用三点$Gauss-Chebyshev$求积公式计算定积分：$\displaystyle\int_{-1}^1\dfrac{x^2}{\sqrt{1-x^2}}dx$的近似值</p>$$\begin{equation}\begin{aligned}&Gauss-Chebyshev公式为：\int_{-1}^1\dfrac{f(x)}{\sqrt{1-x^2}}dx\approx\dfrac{\pi}{n+1}\sum\limits_{k=0}^nf(cos\dfrac{(2k+1)\pi}{2n+2})\\&\because 三点Gauss-Chebyshev求积公式\\&\therefore n=2\\&\therefore \int_{-1}^1\dfrac{x^2}{\sqrt{1-x^2}}dx=\dfrac{\pi}{3}(\cos^2\dfrac{\pi}{6}+\cos^2\dfrac{3\pi}{6}+\cos^2\dfrac{5\pi}{6})\\&\qquad \qquad\qquad\qquad=\dfrac{\pi}{3}(\dfrac{3}{4}+0+\dfrac{3}{4})=\dfrac{\pi}{2}\\&因为n=2，所以Gauss-Chebyshev公式具有5次代数精度，故值精确，误差为0\end{aligned}\end{equation}$$<h2 id="第六题-4"><a href="#第六题-4" class="headerlink" title="第六题"></a>第六题</h2><p>用三点公式求$f(x)$求$f(x)=\dfrac{1}{(1+x)^2}$在$x=1.0,1.1,1.2$处的导数值，已知$f(1.0)=0.250000$，$f(1.1)=0.226757$，$f(1.2)=0.206612$</p>$$\begin{equation}\begin{aligned}&因为f(x)在[1.0,1.2]上f''(x)连续，f'''(x)存在\\&\therefore\begin{cases}f'(1.0)=\dfrac{1}{0.2}(-3\times 0.250000+4\times 0.226757-0.206612)=-0.247920\\f'(1.1)=\dfrac{1}{0.2}(0.206612-0.250000)=-0.216940\\f'(1.0)=\dfrac{1}{0.2}(0.250000-4\times 0.226757+3\times 0.206612)=-0.185960\\\end{cases}\end{aligned}\end{equation}$$<h2 id="第七题-4"><a href="#第七题-4" class="headerlink" title="第七题"></a>第七题</h2><p>确定下列插值型求积公式中的待定系数，并求其代数精度</p><p>$\int_{-1}^1f(x)dx\approx A_0f(-1)+A_1f(0)+A_2f(1)$</p>$$\begin{equation}\begin{aligned}&因为存在3个待定系数，故取f(x)=1,x,x^2\\&\begin{cases}\int_{-1}^11dx=2= A_0+A_1+A_2\\\int_{-1}^1xdx=0= -A_0+A_2\\\int_{-1}^1x^2dx=\dfrac{2}{3}= A_0+A_2\\\end{cases}\\&\Rightarrow\begin{cases}A_0=\dfrac{1}{3}\\A_0=\dfrac{4}{3}\\A_0=\dfrac{1}{3}\\\end{cases}\\&取f(x)=x^3,有\\&\int_{-1}^1x^3dx=0= -\dfrac{1}{3}+\dfrac{1}{3}\\&取f(x)=x^4,有\\&\int_{-1}^1x^4dx=\dfrac{2}{5}\not= \dfrac{1}{3}+\dfrac{1}{3}\\&即代数精度为3\\\end{aligned}\end{equation}$$<h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><h2 id="第一题-5"><a href="#第一题-5" class="headerlink" title="第一题"></a>第一题</h2><p>设初值问题</p>$\begin{equation}\begin{aligned}\begin{cases}u'=at+b\quad 0 < t\le1\\u(0)=0\end{cases}\end{aligned}\end{equation}$<p>有解$u(t)=\dfrac{1}{2}at^2+bt$，若$t_n=nh$，$u_n$是由$Euler$方法得到的数值解，证明：</p><p>$Euler$方法的整体截断误差为：$u(t_n)-u_n=\dfrac{1}{2}aht_n$$$\begin{equation}\begin{aligned}u(t_n)-u_n&=\dfrac{1}{2}at_n^2+bt_n-[u_{n-1}+h(at_{n-1}+b)]\\&=\dfrac{1}{2}at_n^2+bt_n-[u_{0}+h(at_{n-1}+b)+\cdots+h(at_{0}+b)]\\&=\dfrac{1}{2}at_n^2+bt_n-nhb+ah(t_0+\cdots+t_{n-1})\\&=\dfrac{1}{2}at_n^2-ah(t_0+\cdots+t_{n-1})\\&=\dfrac{1}{2}an^2h^2-ah[h+\cdots+(n-1)h]\\&=\dfrac{1}{2}an^2h^2-\dfrac{n(n-1)}{2}ah^2\\&=\dfrac{1}{2}anh^2\\&=\dfrac{1}{2}aht_n\end{aligned}\end{equation}$$</p><h2 id="第四题-5"><a href="#第四题-5" class="headerlink" title="第四题"></a>第四题</h2><p>求线性多步法</p><p>$u_{n+2}+(b-1)u_{n+1}-bu_n=\dfrac{h}{4}[(3+b)f_{n+2}+(3b+1)f_n]$</p><p>的阶以及局部截断误差</p>$$\begin{equation}\begin{aligned}&k=2\\&\alpha_0=-b,\alpha_1=b-1,\alpha_2=1\\&\beta_0=\dfrac{(3b+1)}{4},\beta_1=0,\beta_2=\dfrac{(3+b)}{4}\\&\begin{cases}c_0=\alpha_0+\alpha_1+\alpha_0=2\\c_1=(\alpha_1+2\alpha_2)-(\beta_0+\beta_1+\beta_2)=b-1+2-b-1=0\\c_2=\dfrac{1}{2}(\alpha_1+4\alpha_2)-(\beta_1+2\beta_2)=\dfrac{b-1+4}{2}-\dfrac{3+b}{4}=0\\c_3=\dfrac{1}{6}(\alpha_1+8\alpha_2)-\dfrac{1}{2}(\beta_1+4\beta_2)=\dfrac{b-1+8}{6}-\dfrac{3+b}{2}\\\qquad=-\dfrac{b+1}{3}\\\end{cases}\\&阶为2，局部截断误差为R_{n+3}(h)=-\dfrac{b+1}{3}h^3u^{(3)}(t_n)+O(h^4)\end{aligned}\end{equation}$$<h2 id="第五题-5"><a href="#第五题-5" class="headerlink" title="第五题"></a>第五题</h2><p>求线性多步法的绝对稳定区间</p><p>$u_{n+2}-\dfrac{4}{3}u_{n+1}+\dfrac{1}{3}u_n=\dfrac{2h}{3}f_{n+2}$</p><p>$u_{n+2}-\dfrac{4}{5}u_{n+1}-\dfrac{1}{5}u_n=\dfrac{h}{5}(2f_{n+2}+4f_{n+1})$</p>$$\begin{equation}\begin{aligned}(1)\quad &u_{n+2}-\dfrac{4}{3}u_{n+1}+\dfrac{1}{3}u_n=\dfrac{2h}{3}f_{n+2}\\&\rho(\lambda)=\lambda^2-\dfrac{4}{3}\lambda+\dfrac{1}{3},\sigma(\lambda)=\dfrac{2}{3}\lambda^2\\&\rho(\lambda)-\overline{h}\sigma(\lambda)=(1-\dfrac{2\overline{h}}{3})\lambda^2-\dfrac{4}{3}\lambda-\dfrac{-1}{3}=0\\&\lambda^2-\dfrac{\dfrac{4}{3}}{(1-\dfrac{2\overline{h}}{3})}\lambda-\dfrac{-1}{3(1-\dfrac{2\overline{h}}{3})}=0\\&\left|\dfrac{\dfrac{4}{3}}{(1-\dfrac{2\overline{h}}{3})}\right| < 1+\dfrac{1}{3(1-\dfrac{2\overline{h}}{3})} < 2\\&\therefore 4 < 3-2\overline{h}+1\\&\overline{h} < 0\\&即区间为(-\infty,0)\\(2)\quad &u_{n+2}-\dfrac{4}{5}u_{n+1}-\dfrac{1}{5}u_n=\dfrac{h}{5}(2f_{n+2}+4f_{n+1})\\&\rho(\lambda)=\lambda^2-\dfrac{4}{5}\lambda-\dfrac{1}{5},\sigma(\lambda)=\dfrac{2}{5}\lambda^2+\dfrac{4}{5}\lambda\\&\rho(\lambda)-\overline{h}\sigma(\lambda)=(1-\dfrac{2\overline{h}}{5})\lambda^2-\dfrac{4}{5}(1+\overline{h})\lambda-\dfrac{1}{5}=0\\&\lambda^2-\dfrac{\dfrac{4}{5}(1+\overline{h})}{(1-\dfrac{2\overline{h}}{5})}\lambda-\dfrac{\dfrac{1}{5}}{(1-\dfrac{2\overline{h}}{5})}=0\\&而让|\lambda| < 1的充要条件为\\&\left\vert \dfrac{\dfrac{4}{5}(1-\overline{h})}{(1-\dfrac{2\overline{h}}{5})} \right\vert = 1 - \dfrac{\dfrac{1}{5}}{(1-\dfrac{2\overline{h}}{5}\lambda)} < 2\\&\dfrac{1}{5}-(1-\dfrac{2\overline{h}}{5}) < \dfrac{4}{5}(1+\overline{h}) < (1-\dfrac{2\overline{h}}{5})-\dfrac{1}{5}\\&-4 < \overline{h} < 0\\&即区间为(-4,0)\end{aligned}\end{equation}$$]]></content>
    
    <summary type="html">
    
      &lt;center&gt;计算方法作业题&lt;/center&gt;
    
    </summary>
    
    
      <category term="Course" scheme="http://yoursite.com/categories/Course/"/>
    
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Course" scheme="http://yoursite.com/tags/Course/"/>
    
  </entry>
  
  <entry>
    <title>TridiumNiagara</title>
    <link href="http://yoursite.com/2019/10/28/TridiumNiagara/"/>
    <id>http://yoursite.com/2019/10/28/TridiumNiagara/</id>
    <published>2019-10-28T02:16:50.000Z</published>
    <updated>2019-10-28T03:15:15.434Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="JACE"><a href="#JACE" class="headerlink" title="JACE"></a>JACE</h1><p>JACE是一个边缘计算网关，集成200多种协议，具有一定计算能力，其作用为从下面终端设备提取数据上传至服务器，或从服务器获取指令分配到对应设备</p><h1 id="Niagara"><a href="#Niagara" class="headerlink" title="Niagara"></a>Niagara</h1><p>Niagara是Tridium基于Java开发的控制平台</p><h1 id="利用Tridium配置JACE"><a href="#利用Tridium配置JACE" class="headerlink" title="利用Tridium配置JACE"></a>利用Tridium配置JACE</h1><p>Niagara分为服务器部分站点和JACE站点<br>因为JACE与交换机互联，所以先将电脑IP地址修改成与JACE同一网段</p><ul><li>利用JACE的IP打开其Platform，在服务器端新建Station，新建的Station需要设置一个强密码（大小写数字），在服务器端进入Station Copier将新建的Station导入，一次只能同时运行一个Station，默认运行443的Https协议</li><li>利用JACE的IP打开其Platform，新建Station，打开JACE的Platform，找到Station Copier将新建的Station拷贝至JACE，同样只能有一个Station运行</li><li>在JACE的Platform中打开Application Director，双击新建的Station进入，等其加载完成</li><li>进入JACE的Station，配置Drivers，因为配置环境为JACE利用RS-485的Modbus通信协议，所以在Drivers中添加Modbus Network，并在Modbus Network下添加Modbus Device</li><li>在Modbus Device中根据硬件特性，例如硬件地址（1-255，硬件上修改），AI输入还是DI输入，还是输出，对应输入输出端口，数据类型等，新建Point</li><li>JACE中获取数据后，进入服务器端Station，在Niagara Network中DiscoverJACE的station，然后Ping JACE的Station<br>  注：第一次Ping会Ping不通，需要去服务器端进行授权，遇见Device Limit报错是授权限制Station数量，替换Station后需要重启对应JACE Station以及服务器端Station</li><li>完成后，服务器端便可获取JACE的数据，利用其自带的可视化.px文件编程将数据显示或者自行编写HTML</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;Tridium的Niagara基础使用&lt;/center&gt;
    
    </summary>
    
    
      <category term="IIoT" scheme="http://yoursite.com/categories/IIoT/"/>
    
    
      <category term="Tridium" scheme="http://yoursite.com/tags/Tridium/"/>
    
      <category term="Niagara" scheme="http://yoursite.com/tags/Niagara/"/>
    
  </entry>
  
  <entry>
    <title>一些小证明</title>
    <link href="http://yoursite.com/2019/10/20/Math/"/>
    <id>http://yoursite.com/2019/10/20/Math/</id>
    <published>2019-10-20T09:20:47.000Z</published>
    <updated>2020-02-24T08:16:28.097Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="x-n-前-n-项和"><a href="#x-n-前-n-项和" class="headerlink" title="$x^n$ 前$n$项和"></a>$x^n$ 前$n$项和</h1><p>$x^n$前$n$项和由$(x + 1)^{n+1} - (x - 1)^{n+1}$求得<br>$x$的前$n$项和:n<br>$(x + 1)^2 - (x - 1)^2 = 4x$<br>$((x-1) + 1)^2 - ((x-1) - 1)^2 = 4(x-1)$<br>$…$<br>$2^2 = 4$<br>$(x + 1)^2 + ((x-1) - 1)^2 - 1^2 - 0^2 = 4Sn \Rightarrow Sn = \dfrac{x(x+1)}{2}$</p><p>$x^2$的前$n$项和:<br>$(x + 1)^3 - (x - 1)^3 = 6x^2 + 2$<br>$((x - 1) + 1)^3 - ((x -1) - 1)^3 = 6(x-1)^2 + 2$<br>$…$<br>$2^3 = 8$<br>$(x + 1)^3 + ((x - 1) + 1)^3 - 1^3 - 0^3 = 6Sn + 2x \Rightarrow Sn = \dfrac{2x^3+3x^2+x}{6}$</p><h1 id="Cauchy-Schwarz不等式"><a href="#Cauchy-Schwarz不等式" class="headerlink" title="Cauchy-Schwarz不等式"></a>Cauchy-Schwarz不等式</h1><ol><li>向量空间中<br> $\vert (x,y) \vert =|x^Ty|\le \Vert x\Vert\Vert y\Vert$<br> 证明：<br> 将向量$x$在水平方向$u$和竖直方向$v$分解<br> $x=u+v$<br> $u=ky$<br> $\Vert x \Vert^2 = (x,x) = (u,u)+2(u,v)+(v,v)$<br> $ \Vert x \Vert \ge \Vert u \Vert$<br> $ \Vert u \Vert = \dfrac{(x,y)}{ \Vert y \Vert}$<br> $\Vert x \Vert \Vert y \Vert \ge (x,y)$</li><li>积分中<br> $[\int_{a}^{b}f(x)g(x)dx]^2\le \int_{a}^{b}f^2(x)dx\int_{a}^{b}g^2(x)dx $<br> 证明：<br> 令$F(x)=\int_{a}^{t}f^2(x)dx\int_{a}^{t}g^2(x)dx - [\int_{a}^{x}f(t)g(t)dx]^2$<br> $F’(x)=f^2(x)\int_{a}^{x}g^2(t)dx+g^2(x)\int_{a}^{x}f^2(t)dx-2f(x)g(x)\int_{a}^{x}f(t)g(t)dx$<br> $=\int_{a}^{x}[f^2(x)g^2(t)+g^2(x)f^2(t)-2f(x)g(x)f(t)g(t)]dx$<br> $=\int_{a}^{x}[f(x)g(t)-g(x)f(t)]^2dt\ge 0$<br> 故$F(x)$在$x\ge a$上单增，所以$F(x)\ge F(a)=0$，所以$F(b)\ge F(a) = 0$<br> 即$[\int_{a}^{b}f(x)g(x)dx]^2\le \int_{a}^{b}f^2(x)dx\int_{a}^{b}g^2(x)dx $</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;一些不常用证明&lt;/center&gt;
    
    </summary>
    
    
      <category term="Course" scheme="http://yoursite.com/categories/Course/"/>
    
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>LaTeX</title>
    <link href="http://yoursite.com/2019/10/19/LeTaX/"/>
    <id>http://yoursite.com/2019/10/19/LeTaX/</id>
    <published>2019-10-19T02:11:14.000Z</published>
    <updated>2020-08-05T11:37:57.557Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#记一些用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">\le 或 \leq 为小于等于</span><br><span class="line">\ge 或 \geq 为大于等于</span><br><span class="line">\not= 为不等于</span><br><span class="line">\approx 为约等于</span><br><span class="line">x_1 为x下标1</span><br><span class="line">x^2 为x上标2</span><br><span class="line">\frac&#123;分子&#125;&#123;分母&#125; 为分式表示</span><br><span class="line">\dfrac&#123;分子&#125;&#123;分母&#125; 为分式表示,数字大小不压缩</span><br><span class="line">\partial  偏导符号</span><br><span class="line">\mathrm&#123;d&#125;  正规的导数d（正体）</span><br><span class="line">\sum  求和符号，压缩</span><br><span class="line">\sum\limits  求和符号，不压缩</span><br><span class="line">\prod  求积符号，压缩</span><br><span class="line">\prod\limits  求积符号，不压缩</span><br><span class="line">\lim  求极限符号，压缩</span><br><span class="line">\lim\limits  求极限符号，不压缩</span><br><span class="line">\int  求积分符号，压缩</span><br><span class="line">\int\limits  求积分符号，不压缩</span><br><span class="line">\Vert 范数符号</span><br><span class="line">\cdot 点乘</span><br><span class="line">\sqrt[“几次幂”]&#123; &#125; 开n次根号</span><br><span class="line">\infty 无穷大</span><br><span class="line">\max 最大值</span><br><span class="line">\Leftarrow 左推出</span><br><span class="line">\Rightarrow 右退出</span><br><span class="line">\Leftrightarrow 等价</span><br><span class="line">\perp 垂直</span><br><span class="line">\subset 真包含</span><br><span class="line">\subseteq  包含</span><br><span class="line">\forall 任意</span><br><span class="line">\exists 存在</span><br><span class="line">$$   $$  公式块</span><br><span class="line">\\ 换行，需禁用Markdown渲染</span><br><span class="line">\quad 空格一个字母位</span><br><span class="line">\tilde&#123;&#125; 字母上方加波浪</span><br><span class="line">\overline&#123;&#125; 字母上方加横线</span><br><span class="line">\triangleq  等号上加三角，定义式</span><br><span class="line">\mathrm&#123;d&#125; x 求导符号dx</span><br><span class="line">\partial x 偏导符号dx</span><br><span class="line">\int 积分符号</span><br><span class="line">\triangleup 三角形</span><br><span class="line">\triangledown 倒三角形</span><br><span class="line">\substack&#123;j=1\\j\not=i&#125; 下标多行</span><br><span class="line">\equiv 恒等</span><br><span class="line">\displaystyle 调整符号大小，如积分符号放大</span><br><span class="line">\\方程组</span><br><span class="line">$$\begin&#123;cases&#125;</span><br><span class="line">a_1x+b_1y+c_1z=d_1 \\ </span><br><span class="line">a_2x+b_2y+c_2z=d_2 \\ </span><br><span class="line">a_3x+b_3y+c_3z=d_3</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br><span class="line">或者</span><br><span class="line">$$</span><br><span class="line">\left \&#123; </span><br><span class="line">\begin&#123;array&#125;&#123;c&#125;</span><br><span class="line">a_1x+b_1y+c_1z=d_1 \\ </span><br><span class="line">a_2x+b_2y+c_2z=d_2 \\ </span><br><span class="line">a_3x+b_3y+c_3z=d_3</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">\right. </span><br><span class="line">$$</span><br><span class="line">等号对齐</span><br><span class="line">$$</span><br><span class="line">\left\&#123;</span><br><span class="line">\begin&#123;aligned&#125; </span><br><span class="line">a_1x+b_1y+c_1z &amp;= d_1+e_1 \\ </span><br><span class="line">a_2x+b_2y &amp;= d_2 \\ </span><br><span class="line">a_3x+b_3y+c_3z &amp;= d_3 </span><br><span class="line">\end&#123;aligned&#125; </span><br><span class="line">\right. </span><br><span class="line">$$</span><br><span class="line"></span><br><span class="line">\begin&#123;equation&#125;</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">      内部公式=改为&amp;=实现等号对齐</span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">\end&#123;equation&#125;$</span><br><span class="line">\\行列式</span><br><span class="line">\left |\begin&#123;array&#125;&#123;cccc&#125;</span><br><span class="line"></span><br><span class="line">\end&#123;array&#125;\right|=0\\</span><br></pre></td></tr></table></figure><h1 id="字母表"><a href="#字母表" class="headerlink" title="字母表"></a>字母表</h1><p><img src="/images/LaTeXLetterList.png" alt="字母表"></p><h1 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h1><p><a href="https://jingyan.baidu.com/article/4b52d702df537efc5c774bc9.html" target="_blank" rel="noopener">有空重写表格</a></p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;LaTeX使用相关&lt;/center&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>计算方法知识点（1-4）</title>
    <link href="http://yoursite.com/2019/10/19/ComputationalMethods/"/>
    <id>http://yoursite.com/2019/10/19/ComputationalMethods/</id>
    <published>2019-10-19T01:51:08.000Z</published>
    <updated>2019-12-24T06:16:00.161Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><style>    th{text-align: center}    td{text-align: center}</style><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="误差来源与分类"><a href="#误差来源与分类" class="headerlink" title="误差来源与分类"></a>误差来源与分类</h2><table><thead><tr><th align="center">阶段</th><th align="center">误差类型</th></tr></thead><tbody><tr><td align="center">实际问题-&gt;数学模型</td><td align="center">模型误差</td></tr><tr><td align="center">数学模型-&gt;数值计算方法</td><td align="center">截断误差</td></tr><tr><td align="center">数值计算方法-&gt;编程实现算法</td><td align="center">观测误差</td></tr><tr><td align="center">编程实现算法-&gt;计算机数值结果</td><td align="center">舍入误差</td></tr></tbody></table><p><strong>定义1.1</strong> 设$x$为精确值，$a$为$x$的一个近似值，称  <center>$x - a$</center><br>为近似值$a$的<strong>绝对误差</strong>，简称<strong>误差</strong>。误差$x - a$可正可负</p><p><strong>定义1.2</strong> 设$x$为精确值，$a$为$x$的一个近似值，若有常数$e_a$使得  <center>$|x - a| \le e_a$</center><br>则$e_a$叫做近似值$a$的<strong>误差界（限）</strong>。他总是正数</p><p><strong>定义1.3</strong> 若$x \not= 0$，则将近似值的误差与准确值的比值  <center>$\dfrac{x - a}{x}$</center><br>称为近似值$a$的<strong>相对误差</strong>。相对误差也可正可负</p><p>实际计算中，如果真值$x$未知时，通常取  <center>$\dfrac{x - a}{x}\approx\dfrac{x - a}{a}$</center><br>作为$a$的相对误差，条件是$\dfrac{x - a}{x}$较小</p><p>相对误差的绝对值上界叫做<strong>相对误差界（限）</strong>，记为  <center>$|\dfrac{x - a}{a}| \le \dfrac{e_a}{|a|}$</center></p><p><strong>四舍五入</strong>求误差界，其误差界不超过其末尾的半个单位，例如：</p><center>$|\pi - 3.14| \le \dfrac{1}{2} \times 10^{-2} , |\pi - 3.1416| \le \dfrac{1}{2} \times 10^{-4}$</center><h2 id="有效数字的概念"><a href="#有效数字的概念" class="headerlink" title="有效数字的概念"></a>有效数字的概念</h2><p><strong>定义1.4</strong> 设$x$为精确值，$a$为$x$的一个近似值，表示为：  <center>$a = \pm 10^k \times 0.a_1a_2…a_n…$</center><br>可以是有限或无限小数形式，其中$a_i(i = 1,2,…,n)$是0到9中的一个数字，<strong>$a_1 \not= 0$, $k$为整数, $n$为正整数</strong>，如果其绝对误差界  <center>$|x - a| \le \dfrac{1}{2} \times 10^{k-n}$</center><br>则称$a$为$x$的具有<strong>$n$</strong>位有效数字的近似值</p><p>例如：$e = 2.71828182…$, $a = 2.718$，其绝对误差界为：  <center>$|e - a| &lt; \dfrac{1}{2} \times 10^{-3}$</center><br>而$a = 10^1 \times 0.2718$，则$k = 1$，$k - n = -3 \Rightarrow n = 4$，即$a$是$e$的具有4位有效数字的近似值</p><p><strong>有效数字位数与小数点的位置无关</strong></p><p><strong>定理1.1</strong> 设实数$x$为某个精确值，$a$为它的一个近似值，其表达形式如$a = \pm 10^k \times 0.a_1a_2…an…$，则</p><ul><li>如果$a$有$n$位有效数字，则其相对误差界满足  <center>$\dfrac{|x - a|}{|a|} \le \dfrac{1}{2a_1} \times 10^{1-n}$</center><br>  <strong>证明</strong> 首先$|a|$满足  <center>$a_1 \times 10^{k-1} \le |a| \le (a_1 + 1) \times 10^{k-1}$</center><br>  &emsp;&emsp; 如果$a$有$n$位有效数字，则<center>$\dfrac{|x - a|}{|a|} = |x - a| \times \dfrac{1}{|a|} \le \dfrac{1}{2}\times 10^{k - n} \times \dfrac{1}{a_1 \times 10^{k-1}} = \dfrac{1}{2a_1} \times 10^{1 - n}$</center></li><li>如果其相对误差界满足  <center>$\dfrac{|x - a|}{|a|} \le \dfrac{1}{2(a_1 + 1)} \times 10^{1-n}$</center>  则$a$至少具有$n$位有效数字<br>  <strong>证明</strong>  <center>$\dfrac{|x - a|}{|a|} \le \dfrac{1}{2(a_1 + 1)} \times 10^{1-n} \le \dfrac{(a_1 + 1) \times 10^{k - 1}}{2(a_1 + 1)} \times 10^{1 - n} = \dfrac{1}{2} \times 10 ^{k - n}$ </center></li></ul><h2 id="函数计算的误差值"><a href="#函数计算的误差值" class="headerlink" title="函数计算的误差值"></a>函数计算的误差值</h2><p>设一元函数$f(x)$具有二阶连续导数，自变量$x$的一个近似值为$a$，$f(a)$作为$f(x)$的近似，其误差为：</p><ul><li>绝对误差  <center>$|f(x) - f(a)| \approx |f’(a)||x-a|$</center></li><li>相对误差  <center>$\dfrac{|f(x) - f(a)|}{|f(a)|} \approx \dfrac{|f’(a)|}{|f(a)|}|x-a|$</center></li></ul><p>如果$f(x_1, x_2,…, x_n)$为$n$元函数，自变量$x_1, x_2,…, x_n$的近似值分别为$a_1, a_2,…, a_n$，则  <center>$f(x_1, x_2,…, x_n) - f(a_1, a_2,…, a_n) \approx \sum\limits_{k=1}^{n}(\dfrac{\partial f(a_1, a_2,…, a_n)}{\partial x_k})(x_k-a_k)$</center></p><p>由此可以推出误差界为：  <center>$|f(x_1, x_2,…, x_n) - f(a_1, a_2,…, a_n)| \le \sum\limits_{k=1}^{n}|\dfrac{\partial f(a_1, a_2,…, a_n)}{\partial x_k}||x_k-a_k|$</center></p><p>针对2元函数的误差估计四元运算：</p><ul><li><p>$f(x_1, x_2) = x_1 \pm x_2$</p>  <center>$|f(x_1, x_2) - f(a_1, a_2)| \le |x_1 - a_1| + |x_2 - a_2|$</center><p>  <strong>两个近似数相加减，其运算结果的精度不比原始数据任何一个精度高</strong></p></li><li><p>$f(x_1, x_2) = x_1 \cdot x_2$</p>  <center>$|f(x_1, x_2) - f(a_1, a_2)| \le |a_2||x_1 - a_1| + |a_1||x_2 - a_2|$</center></li><li><p>$f(x_1, x_2) = \dfrac{x_1}{x_2}$</p>  <center>$|f(x_1, x_2) - f(a_1, a_2)| \le \dfrac{|x_1 - a_1|}{|a_2|} + \dfrac{|a_1||x_2 - a_2|}{|a_2|^2}$</center>  <center>$ = \dfrac{|a_2||x_1 - a_1| + |a_1||x_2 - a_2|}{|a_2|^2}$</center><p>  <strong>小的数字做除数会导致差得相对误差变很大</strong></p></li></ul><p><strong>计算中应避免出现相近数相减</strong></p><h2 id="数值函数的值稳定性"><a href="#数值函数的值稳定性" class="headerlink" title="数值函数的值稳定性"></a>数值函数的值稳定性</h2><p>计算过程中<strong>放大舍入误差</strong>的方法是<strong>数值不稳定</strong>的，反之<strong>数值稳定</strong></p><h2 id="避免误差危害的基本原则"><a href="#避免误差危害的基本原则" class="headerlink" title="避免误差危害的基本原则"></a>避免误差危害的基本原则</h2><ul><li>避免有效数字损失<br>  即避免两个相近数相减，例如求二次方程的解时求同符号的根，另外根由韦达定理求解</li><li>减少运算次数<br>  有效减少误差累计，例如秦九韶算法</li></ul><h2 id="向量范数"><a href="#向量范数" class="headerlink" title="向量范数"></a>向量范数</h2><p><strong>定义1.4</strong> 定义在$C^n$（n维复向量空间）上的一个非负实值函数，记为$f(x)=\Vert x \Vert$，若该函数满足以下三个条件：<br>    即对任意向量$x$和$y$以及任意复常数$\alpha \in C$满足</p><ul><li>非负性&emsp;&emsp;&emsp;&emsp;$\Vert x \Vert \ge 0$当且仅当$x=0_{n \times 1}$时$\Vert x \Vert =0$</li><li>齐次性&emsp;&emsp;&emsp;&emsp;$\Vert \alpha x \Vert = |\alpha|\Vert x \Vert$</li><li>三角不等式&emsp;&emsp;$\Vert x + y \Vert \le \Vert x \Vert + \Vert y \Vert$<br>则称函数$\Vert \cdot \Vert$为$C^n$上的一个向量范数</li></ul><p>设任意$n$维向量$x = (x_1, x_2,…,x_n)^T$<br>常用的向量范数有：</p><ul><li>向量的一范数，向量元素绝对值的和&emsp;&emsp;&emsp;$\Vert x \Vert_1 = \sum\limits_{i=1}^{n}|x_i|$</li><li>向量的二范数，向量的长度&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$\sqrt{\sum\limits_{i=1}^{n}|x_i|^2} = \sqrt{x^Hx} = \sqrt{(x,x)}$</li><li>向量的无穷范数，向量元素绝对值最大的&emsp;$\Vert x \Vert_\infty = \max \limits_{1\le x \le n}|x_i|$</li><li>向量的p范数&ensp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$\sqrt[p]{\sum\limits_{i=1}^{n}|x_i|^p}$，$1 \le p \le +\infty$</li></ul><p>加权向量范数：$\Vert x \Vert_w = \Vert Wx \Vert_p$<br>即利用一个对角矩阵$W$，为向量每个元素赋权值</p><p>向量范数的等价性</p><ul><li>$\Vert x \Vert_\infty \le \Vert x \Vert_1 \le n\Vert x \Vert_\infty$</li><li>$\dfrac{1}{\sqrt{n}}\Vert x \Vert_1 \le \Vert x \Vert_2 \le \Vert x \Vert_1$</li><li>$\dfrac{1}{\sqrt{n}}\Vert x \Vert_2 \le \Vert x \Vert_\infty \le \Vert x \Vert_2$</li></ul><p>证明：</p><ul><li>$\Vert x \Vert_\infty = \max\limits_{1 \le x \le n}|x_i| \le \sum\limits_{i=1}^{n}|x_i| = \Vert x \Vert_1 \le \sum\limits_{i=1}^{n}\max\limits_{1 \le x \le n}|x_i| = n\Vert x \Vert_\infty$</li><li>$\dfrac{1}{n}\Vert x \Vert_1^2 = \dfrac{1}{n}(\sum\limits_{i=1}^{n}|x_i|)^2 \le \sum\limits_{i=1}^{n}|x_i|^2 = \Vert x \Vert_2^2 \le (\sum\limits_{i=1}^{n}|x_i|)^2 = \Vert x \Vert_1^2$<br>注:第一步证明根据算术平均数$\le$平方平均数得到</li><li>$\dfrac{1}{n}\Vert x \Vert_2^2 = \dfrac{1}{n}\sum\limits_{i=1}^{n}|x_i|^2 \le \max\limits_{1 \le x \le n}|x_i|^2 = \Vert x \Vert_\infty^2 \le \sum\limits_{i=1}^{n}|x_i|^2 = \Vert x \Vert_2^2$</li></ul><p><strong>定理1.2</strong> 向量范数等价性定理<br>设$\Vert \cdot \Vert_\beta$和$\Vert \cdot \Vert_\alpha$为$C^n$上的任意两种向量范数。则存在两个与向量无关的正常数$c_1 &gt; 0$和$c_2 &gt; 0$，使得下面不等式成立  <center>$c_1 \Vert x \Vert_\beta \le \Vert x \Vert_\alpha \le c_2\Vert x \Vert_\beta$</center><br>并称$\Vert \cdot \Vert_\alpha$和$\Vert \cdot \Vert_\beta$为$C^n$的等价范数。<br>由向量范数的等价性可知  <center>$\lim\limits_{x \to 0} \Vert x \Vert_\alpha = 0 \Leftrightarrow \Vert x \Vert_\beta = 0$</center></p><h2 id="矩阵范数"><a href="#矩阵范数" class="headerlink" title="矩阵范数"></a>矩阵范数</h2><p><strong>定义1.5</strong> 定义在$C^{m \times n}$上的一个非负实值函数，记为$f(A)=\Vert A \Vert$，若该函数满足以下条件：<br>即对于任意矩阵A,B以及任意复常数$\alpha \in C$</p><ul><li>非负性&emsp;&emsp;&emsp;&emsp;&emsp;$\Vert A \Vert \ge 0$当且仅当$A = 0_{m \times n}$时$\Vert A \Vert = 0$</li><li>齐次性&emsp;&emsp;&emsp;&emsp;&emsp;$\Vert \alpha A \Vert = |\alpha|\Vert A \Vert$</li><li>三角不等式&emsp;&emsp;&emsp;$\Vert A + B \Vert \le \Vert A \Vert +\Vert B \Vert$</li><li>相容性&emsp;&emsp;&emsp;&emsp;&emsp;$\Vert AB \Vert \le \Vert A \Vert \cdot \Vert B \Vert$&emsp;&emsp;$A \in C^{m \times l}, B \in C^{l \times n}$</li></ul><p>则称函数$\Vert \cdot \Vert$为$C^{m \times n}$上的一个矩阵范数</p><p>将矩阵$A$按列分块，$A = (A_1, A_2,…, A_n)$</p><ul><li>矩阵的$m_1$范数，矩阵各元素绝对值之和&emsp;&emsp;$\sum\limits_{j=1}^{n} \Vert A_j \Vert_1 = \sum\limits_{j=1}^{n}\sum\limits_{i=1}^{n}|a_{ij}|$</li><li>矩阵的$F$范数，矩阵各元素平方和开方&ensp;&emsp;&emsp;$\sum\limits_{j=1}^{n} \Vert A_j \Vert_2 = \sqrt{\sum\limits_{j=1}^{n}\sum\limits_{i=1}^{n}|a_{ij}|^2}$<br>  $\Vert A \Vert_F^2=tr(A^HA)$</li></ul><p><strong>定义1.6</strong> 称如下集合为矩阵$A \in C^{n \times n}$的<strong>谱</strong>$\sigma(A)=\{\lambda|\Delta(\lambda I-A)=0\}$，即<strong>谱</strong>为特征值向量<br>称如下实数为矩阵$A \in C^{n \times n}$的<strong>谱半径</strong>$\rho(A) = \max\limits_{i}|\lambda_i|$</p><p><strong>补充</strong> </p><ul><li>正定矩阵：设$M$是$n$阶方阵，如果对任何非零向量$x$,都有$x^TMx&gt;0$，则称$M$为正定矩阵</li><li>半正定矩阵：设$M$是$n$阶方阵，如果对任何非零向量$x$,都有$x^TMx \le 0$，则称$M$为半正定矩阵</li><li>共轭转置：矩阵转置后虚部符号相反</li></ul><p>对任给$x = (x_1, x_2,…,x_n)^T \in C^n$，设矩阵$A \in C^{m \times n}$，有</p><ul><li>$(A^HA)^H = A^H(A^H)^H = A^HA$</li><li>$(A^HAx, x)=x^H(A^HAx)=x^HA^HAx$<br>  $=(Ax)^H(Ax)=(Ax, Ax)=\Vert Ax \Vert_2^2 \ge 0$</li></ul><p>即$A^HA$，$AA^H$为半正定复对称（Hermite）矩阵</p><h2 id="矩阵范数与向量范数的相容性"><a href="#矩阵范数与向量范数的相容性" class="headerlink" title="矩阵范数与向量范数的相容性"></a>矩阵范数与向量范数的相容性</h2><p><strong>定义1.7</strong> 对于一种矩阵范数$\Vert \cdot \Vert_M$和一种向量范数$\Vert \cdot \Vert_V$，如果对任意$m \times n$矩阵$A$和任意$n$维向量$x$，满足  <center>$\Vert Ax \Vert_V \le \Vert A \Vert_M \Vert x \Vert_V$</center><br>则称矩阵范数$\Vert \cdot \Vert_M$与向量范数$\Vert \cdot \Vert_V$是相容的</p><ul><li>矩阵$m_1$范数与向量的$p$范数是相容的，即&emsp;$\Vert Ax \Vert_p \le \Vert A \Vert_{m_1} \Vert x \Vert_p$<br>证明：设$A = (a_{ij}) \in C^{n \times n}$，$x = [x_1, x_2,…,x_n]^T \in C^n$<br>&emsp;&emsp;&emsp;&emsp;$\Vert Ax \Vert_p^p = \sum\limits_{i = 1}^n|\sum\limits_{j=1}^n a_{ij} x_j|^p \le \sum\limits_{i = 1}^n(\sum\limits_{j=1}^n |a_{ij}||x_j|)^p $<br>&emsp;&emsp;&emsp;&emsp;$\le \sum\limits_{i = 1}^n[(\sum\limits_{j=1}^n |a_{ij}|^p)(\sum\limits_{j=1}^n|x_j|^p)] = (\sum\limits_{i = 1}^n\sum\limits_{j=1}^n |a_{ij}|^p)(\sum\limits_{j=1}^n|x_j|^p)$<br>&emsp;&emsp;&emsp;&emsp;$=\Vert A \Vert_{m_1}^p \Vert x \Vert_p^p$</li><li>矩阵$F$范数与向量的$2$范数是相容的，即&emsp;&emsp;$\Vert Ax \Vert_2 \le \Vert A \Vert_{F} \Vert x \Vert_2$<br>证明：设$A = (a_{ij}) \in C^{n \times n}$，$x = [x_1, x_2,…,x_n]^T \in C^n$<br>&emsp;&emsp;&emsp;&emsp;$\Vert Ax \Vert_2^2 = \sum\limits_{i = 1}^n|\sum\limits_{j=1}^n a_{ij} x_j|^2 \le \sum\limits_{i = 1}^n(\sum\limits_{j=1}^n |a_{ij}||x_j|)^2 $<br>&emsp;&emsp;&emsp;&emsp;$\le \sum\limits_{i = 1}^n[(\sum\limits_{j=1}^n |a_{ij}|^2)(\sum\limits_{j=1}^n|x_j|^2)] = (\sum\limits_{i = 1}^n\sum\limits_{j=1}^n |a_{ij}|^2)(\sum\limits_{j=1}^n|x_j|^2)$<br>&emsp;&emsp;&emsp;&emsp;$=\Vert A \Vert_{F}^2 \Vert x \Vert_2^2$</li></ul><p>证明方法类似，可以证明任意一种矩阵范数必然存在与之相容的向量范数<br>证明使用到$Cauchy-Schwarz$不等式：$ \left( \sum\limits_{n}^{i=1}a_kb_k \right) \ le \left( \sum\limits_{n}^{k=1} a_k^2 \right)\left( \sum\limits_{n}^{k=1} b_k^2 \right)$（$F$范数与$2$范数相容）<br>以及其更一般化的$Holder$不等式：$\left( \sum\limits_{n}^{i=1}a_kb_k \right) \ le \left( \sum\limits_{n}^{k=1} a_k^p \right)^{\dfrac{1}{p}}\left( \sum\limits_{n}^{k=1} b_k^2 \right)^{\dfrac{1}{p}}$</p><h2 id="算子范数"><a href="#算子范数" class="headerlink" title="算子范数"></a>算子范数</h2><p><strong>定理1.3</strong> $C^n$上的任何向量范数$f(x) = \Vert x \Vert$，则$f(x)$为$x$的分量$x_1, x_2,…,x_n$的连续函数<br><strong>定理1.4</strong> 已知$C^m$和$C^n$上的同类向量范数$\Vert \cdot \Vert_v$，$A$为$m \times n$矩阵，定义  <center>$\Vert A \Vert_M = \max\limits_{x \not= 0}\dfrac{\Vert Ax \Vert_V}{\Vert x \Vert_V} = \max\limits_{\Vert x \Vert_V = 1}\Vert Ax \Vert_V$</center><br>则$\Vert A \Vert_M$是一种矩阵范数，且与已知的向量范数相容，称由上述关系式定义的矩阵范数为<strong>从属向量范数的矩阵范数</strong>简称<strong>从属范数</strong>或<strong>算子范数</strong><br>证明：</p><ul><li>等价性证明：<br>$\max\limits_{x \not= 0}\dfrac{\Vert Ax \Vert_V}{\Vert x \Vert_V} = \max\limits_{x \not= 0}\dfrac{1}{\Vert x \Vert_V}\cdot\Vert Ax \Vert_V = \max\limits_{x \not= 0}\Vert A(\dfrac{x}{\Vert x \Vert_V})\Vert_V = \max\limits_{\Vert y \Vert_V = 1}\Vert Ay \Vert_V$</li><li>验证$\Vert A \Vert_M$与从属的向量范数相容：<br>$\Vert A \Vert_M \ge \dfrac{\Vert Ax \Vert_V}{\Vert x \Vert_V} \Rightarrow \Vert A \Vert_M\Vert x \Vert_V \ge \Vert Ax \Vert_V$</li><li>非负性：<br>当$A=0$时，对任意$x \in C^n$，有$\Vert Ax \Vert_V = 0$，从而得$\Vert A \Vert_M = 0$；而当$A \not= 0$时，存在$x_0 \in C^n$，从而$\Vert A \Vert_M \ge \dfrac{\Vert Ax_0 \Vert_V}{\Vert x_0 \Vert_V }\ge 0$</li><li>齐次性<br>对任意的$\alpha \in C$，有<br>$\Vert \alpha A \Vert_M = \max\limits_{x \not= 0}\dfrac{\Vert (\alpha A)x \Vert_V}{\Vert x \Vert_V}=|\alpha|\cdot\max\limits_{x \not= 0}\dfrac{\Vert Ax \Vert_V}{\Vert x \Vert_V}=|\alpha|\cdot \Vert A \Vert_M$</li><li>三角不等式<br>$\Vert A+B \Vert_M = \max\limits_{\Vert x \Vert_V = 1}\Vert (A+B)x \Vert_V $<br>$\ge \max\limits_{\Vert x \Vert_V = 1}\Vert Ax \Vert_V  + \max\limits_{\Vert x \Vert_V = 1}\Vert Bx \Vert_V  \ge \Vert A \Vert_M + \Vert B \Vert_M  $</li><li>相容性<br>设$AB \not= 0$，且$A$，$B$分别为$m \times l$和$l \times n$阶矩阵，令$y = Bx \not= 0$<br>$\Vert AB \Vert_M = \max\limits_{\Vert x \Vert_V = 1}\Vert (AB)x \Vert_V = \max\limits_{\Vert x \Vert_V = 1}\dfrac{\Vert (AB)x \Vert_V}{\Vert Bx \Vert_V}\Vert Bx \Vert_V$<br>$\le \max\limits_{y \not= 0}\dfrac{\Vert Ay \Vert_V}{\Vert y \Vert_V}\max\limits_{\Vert x \Vert_V}\Vert Bx \Vert_M \le \Vert A \Vert_M \Vert B \Vert_M$</li></ul><p>常用算子范数</p><ul><li>列和范数，最大列和&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$\Vert A \Vert_1 = \max\limits_{1 \le j \le n}\sum\limits_{i=1}^{m}|a_{ij}|$</li><li>行和范数，最大行和&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;$\Vert A \Vert_\infty = \max\limits_{1 \le i \le m}\sum\limits_{j=1}^{n}|a_{ij}|$</li><li>谱范数，矩阵$A^HA$最大特征值开方&emsp;$\Vert A \Vert_2 = \sqrt{\lambda_{max}(A^HA)}$</li></ul><p><strong>推论</strong> 对于任何算子范数，单位矩阵$I \in R^{n \times n}$的范数值为1<br>$m_1$范数和$F$范数均不满足，值分别为$n$和$\sqrt{n}$</p><p><strong>矩阵范数具有向量范数的一切性质</strong><br><strong>定理1.5</strong>矩阵范数的等价性定理<br>设$\Vert \cdot \Vert_\beta$和$\Vert \cdot \Vert_\alpha$为$C^{m \times n}$上的任意两种矩阵范数，则存在两个与矩阵无关的正常数$c_1 &gt; 0$和$c_2 &gt; 0$，使得下面的不等式成立  <center>$c_1\Vert \cdot \Vert_\beta \le \Vert \cdot \Vert_\alpha \le c_2\Vert \cdot \Vert_\beta$</center><br>并称$\Vert \cdot \Vert_\alpha$和$\Vert \cdot \Vert_\beta$为$C^{m \times n}$上的<strong>等价范数</strong><br>由矩阵范数的等价性可知：&emsp;&emsp;$\lim\limits_{A \Rightarrow 0}\Vert A \Vert_\alpha \Leftrightarrow \lim\limits_{A \Rightarrow 0}\Vert A \Vert_\beta = 0$</p><p>可证：</p><ul><li>任意给定的矩阵范数必然存在与之相容的向量范数；任意给定的向量范数必然存在与之相容的矩阵范数</li><li>一个矩阵范数可以与多种向量范数相容；多种矩阵范数可以与一个向量范数相容</li><li>从属范数一定与所定义的向量范数相容，但是矩阵范数与向量范数相容不一定有从属关系</li></ul><p><strong>酉矩阵$U$</strong><br>对于酉矩阵$U^HU=UU^H=I$，有如下结论：<br>$\Vert U\Vert_2 = 1 \quad \Vert AU \Vert_2 = \Vert UA \Vert_2 = \Vert A \Vert_2$<br>酉矩阵的范数不变性<br>证明：<br>$\Vert U\Vert_2^2 = \rho(U^HU) = \rho(I) = 1$<br>$\Vert UA \Vert_2^2 = \rho[(UA)^H(UA)] = \rho(A^HU^HUA) = \rho(A^HA) = \Vert A\Vert_2^2$<br>$\Vert AU \Vert_2^2 = \rho[(AU)^H(AU)] = \rho(U^HA^HAU) $<br>因为$U$可逆，所以$U^HA^HAU \sim UU^HA^HAUU^H = A^HA$，根据相似矩阵特征值相同，故<br>$\rho(U^HA^HAU) =  \rho(A^HA) = \Vert A\Vert_2^2$</p><h2 id="矩阵范数的性质"><a href="#矩阵范数的性质" class="headerlink" title="矩阵范数的性质"></a>矩阵范数的性质</h2><p><strong>定理1.7</strong> 设$\Vert \cdot \Vert_M$为矩阵$C^{n \times n}$空间的任一矩阵范数，则对任意的$n$阶方阵$A$均有  <center>$\rho(A) \le \Vert A \Vert_M$</center><br>其中$\rho(A)$为方阵$A$的谱半径<br>证明：设$|\lambda|=\rho(A)$，则存在向量$x \not= 0$，满足$Ax = \lambda x$<br>从而$|\lambda| \cdot \Vert x \Vert_M = \Vert \lambda x \Vert_M = \Vert Ax \Vert_M \le \Vert A \Vert_M \Vert x\Vert_M \Rightarrow \rho(A) = |\lambda| \le \Vert A \Vert_M$</p><p>当$A = A^T$时，有$\Vert A \Vert_2 = \sqrt{\lambda_{max}(A^TA)}=\sqrt{\lambda_{max}(A)^2}=\lambda_{max}(A)=\rho(A)$</p><p><strong>定理1.8</strong> 对于任给的$\eta &gt; 0$，则存在$C^{n \times n}$上的一种算子范数$\Vert \cdot \Vert_M$(依赖矩阵$A$和常数$\eta$)，使得  <center>$\Vert A \Vert_M \le \rho(A) + \eta$</center><br>上述定理针对矩阵$A$构造的矩阵范数$\Vert \cdot \Vert_M$，对于其他矩阵不一定成立</p><p><strong>定理1.9</strong> 设$A \in C^{n \times n}$，如果有$C^{n \times n}$上的一种矩阵范数$\Vert \cdot \Vert$，使得$\Vert A \Vert &lt; 1$，则</p><ul><li>$I \pm A$可逆<br>  证明：若$I \pm A$奇异，则$\Delta(I \pm A)=0$，则存在特征值$\mu_k = 1 \pm \lambda_k = 0$，则$\lambda = \pm 1$是$A$的一个特征值，从而必有$\rho (A) \ge 1$</li><li>$\Vert (I \pm A)^{-1} \Vert \le \dfrac{\Vert I \Vert}{1 - \Vert A \Vert}$<br>  证明：$(I \pm A)^{-1}(I \pm A) = I \Rightarrow (I \pm A)^{-1} \pm (I \pm A)^{-1}A = I$<br>  &emsp;&emsp;&emsp;$\Vert (I \pm A)^{-1} \Vert = \Vert I \mp (I \pm A)^{-1}A \Vert \le \Vert I \Vert + \Vert (I \pm A)^{-1}\Vert \Vert A \Vert$<br>  &emsp;&emsp;&emsp;$\Rightarrow \Vert (I \pm A)^{-1} \Vert \le \dfrac{\Vert I \Vert}{1 - \Vert A \Vert}$</li><li>$\Vert I - (I \pm A)^{-1} \Vert \le \dfrac{\Vert A \Vert}{1 - \Vert A \Vert}$<br>  证明：$I - (I \pm A)^{-1} = ((I \pm A) - I)(I \pm A)^{-1} = \pm A(I \pm A)^{-1}$<br>  &emsp;&emsp;&emsp;$\Rightarrow A - A(I \pm A)^{-1} = A[\pm A(I \pm A)^{-1}]$<br>  &emsp;&emsp;&emsp;$\Vert (I - (I \pm A)^{-1}) \Vert = \Vert A(I \pm A)^{-1} \Vert = \Vert \dfrac{A}{I \pm A} \Vert \le \dfrac{\vert A \vert}{1 - \vert A \vert}$<br>  注：根据三角不等式（不等关系）且因为$\vert A \vert &lt; 1$（去绝对值），所以$\vert I \pm A \vert \ge 1 - \vert A \vert $</li></ul><h1 id="矩阵变换和计算"><a href="#矩阵变换和计算" class="headerlink" title="矩阵变换和计算"></a>矩阵变换和计算</h1><h2 id="高斯消去法"><a href="#高斯消去法" class="headerlink" title="高斯消去法"></a>高斯消去法</h2><p>利用初等行变换将增广矩阵$(A|B)$转化成上三角矩阵(U|c)，然后通过回代求解与$Ax=b$同解的三角方程组$Ux=c$<br>高斯消去法的计算量：设系数矩阵$A_{n \times n}$</p><ul><li>第一行：(n + 1)(n - 1)</li><li>第二行：n(n - 2)</li><li>…<br>综上，通项为$n^2-1$，所以乘法运算量为$Sn = \dfrac{2n^3+3n^2+n}{6} - x = \dfrac{2n^3+3n^2-5n}{6}$<br>解上三角矩阵的乘法运算量为：$\dfrac{n(n+1)}{2}$<br>综上，高斯消元法总乘法运算量为：$\dfrac{n^3+3n^2-n}{3}$</li></ul><h2 id="矩阵的LU分解"><a href="#矩阵的LU分解" class="headerlink" title="矩阵的LU分解"></a>矩阵的LU分解</h2><p><strong>定义2.1</strong> 对于$n$阶方阵$A$，如果存在$n$阶单位下三角矩阵$L$和$n$阶上三角矩阵$U$，使得$A=LU$，则称其为矩阵$A$的$LU$分解，也称<strong>Doolittle分解</strong></p><p>对于一般$n$阶方阵$A$进行$LU$分解，每一次行变换提出一个$L_i$矩阵，最终使得$L_{n-1}L_{n-2}…L_{2}L_{1}A = U$，令$L = (L_{n-1}L_{n-2}…L_{2}L_{1})^{-1}$，则有$A = LU$</p><p><strong>Doolittle分解</strong>解线性方程组$Ax = b \Leftrightarrow (LU)x = b \Leftrightarrow Ly = b Ux = y$<br>在如下情况可以极大减少计算量</p><ul><li>$A^nB^nx=b$<br>利用高斯消元法做计算量为：&emsp;&emsp;$\dfrac{n^4}{3}$<br>利用$LU$分解做计算量为:&emsp;&emsp;&emsp;&emsp;$\dfrac{2n^3}{3}$</li><li>$Ax = b_k$，$k = 1,2,3…,m$<br>利用高斯消元法做计算量为：&emsp;&emsp;$\dfrac{mn^3}{3}$<br>利用$LU$分解做计算量为:&emsp;&emsp;&emsp;&emsp;$\dfrac{n^3}{3}$</li></ul><h2 id="紧凑格式的Doolittle公式"><a href="#紧凑格式的Doolittle公式" class="headerlink" title="紧凑格式的Doolittle公式"></a>紧凑格式的Doolittle公式</h2>$\begin{bmatrix}{a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}\\{a_{21}}&{a_{22}}&{\cdots}&{a_{2n}}\\{\vdots}&{\vdots}&{\ddots}&{\vdots}\\{a_{n1}}&{a_{n2}}&{\cdots}&{a_{nn}}\\\end{bmatrix} = \begin{bmatrix} {1}&{0}&{\cdots}&{0}\\ {l_{21}}&{1}&{\cdots}&{0}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}\\ {l_{n1}}&{l_{n2}}&{\cdots}&{1}\\ \end{bmatrix}  \begin{bmatrix} {u_{11}}&{u_{12}}&{\cdots}&{u_{1n}}\\ {0}&{u_{22}}&{\cdots}&{u_{2n}}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}\\ {0}&{0}&{\cdots}&{u_{nn}}\\ \end{bmatrix}$<p>分析$a_{1i}$与$a_{i1}$可得：</p>$$\begin{cases}u_{1j} = a_{1j}\quad j=1,2,...,n \\ l_{j1} = \dfrac{u_{j1}}{u_{11}} \quad j=2,3,...,n\\ \end{cases}$$<p>推广可得：</p>$$\begin{cases}u_{ij} = a_{ij} - \sum\limits_{k=1}^{i-1}l_{ik}u_{kj}\quad j = i,i+1,...,n \\ l_{ji} = \dfrac{a_{ji}-\sum\limits_{k=1}^{i-1}l_{jk}u_{ki}}{u_{11}}\quad j = i+1,i+2,...,n\\ \end{cases}$$<p>高斯消去法的可行条件为：<strong>$A$的各阶顺序主子式均不为0</strong></p><p><strong>定理2.1</strong> 矩阵$LU$分解的存在和唯一性<br>如果$n$阶矩阵$A$的各阶顺序主子式$D_k \quad k = 1,2,…,n-1$均不为零，则必有单位下三角矩阵$L$和上三角矩阵$U$，使得$A=LU$，且$L$和$U$唯一存在</p><p><strong>Crout分解</strong> $LU$分解中$L$为下三角矩阵$U$为单位上三角矩阵<br><strong>LDU分解</strong> $L$为单位下三角矩阵$D$为非奇异对角矩阵$U$为单位上三角矩阵</p><p>$LU$分解获取$L$阵和$U$阵后，利用$U=DU’$，得$LDU$分解的$D$阵和$U$阵，其中$D$为$U$阵的对角元构成，$U’$为$U$对角元置$1$的单位上三角阵<br>然后利用$LDU$可得$Crout$分解的$L$阵和$U$阵，其中$L’=LD$，$U’=U$</p><h2 id="利用LU分解求矩阵的逆"><a href="#利用LU分解求矩阵的逆" class="headerlink" title="利用LU分解求矩阵的逆"></a>利用LU分解求矩阵的逆</h2><p>如前文所述，令$x = [x_1, x_2,…,x_n], I = [e_1, e_2,…,e_n]$此处可以看成<br>$Ax = LUx_i = e_i \quad i = 1,2,…,n$</p><p>同时，若某步$a_{kk}^{k-1} \not= 0$，但很小，会造成很大的舍入误差，无法使用$LU$分解</p><h2 id="高斯列主元消去法"><a href="#高斯列主元消去法" class="headerlink" title="高斯列主元消去法"></a>高斯列主元消去法</h2><p>高斯列主元消去法即为在高斯消去法的基础上增加选主元的过程，即在第$k \quad k=1,2,…,n-1$步消元时，首先在第$k$列主对角元以下元素中挑选绝对值最大的数，经过初等行变换，使其成为$a_{kk}^{(k-1)}$，再继续消元<br>置换矩阵，左乘行交换，右乘列交换</p><h2 id="带列主元的LU分解"><a href="#带列主元的LU分解" class="headerlink" title="带列主元的LU分解"></a>带列主元的LU分解</h2><p>根据如上定义，经过带列主元的$LU$分解，我们可以得到$L_{n-1}P_{n-1}…L_2P_2L_1P_1A = U$<br>但是$L_{n-1}P_{n-1}…L_2P_2L_1P_1$不是单位下三角矩阵，故经过如下改写：<br>$L_{n-1}(P_{n-1}L_{n-2}P_{n-1}^{-1})(P_{n-1}…P_2L_2P_2^{-1}…P_{n-1}^{-1})(P_{n-1}…P_2P_1)A = U$</p><h2 id="对称正定矩阵的Cholesky分解法"><a href="#对称正定矩阵的Cholesky分解法" class="headerlink" title="对称正定矩阵的Cholesky分解法"></a>对称正定矩阵的Cholesky分解法</h2><p>正定（半正定）对称矩阵的定义和某些性质</p><ul><li>$A$为半正定对称矩阵，对任何$x \in R^n \quad (Ax, x) \ge 0$</li><li>$A$为正定对称矩阵，如果$x \not= 0 \in R^n$，恒有$(Ax, x) &gt; 0$</li><li>$A$为正定(半正定)对称矩阵$\Longleftrightarrow$$A$的特征值为正（非负）</li><li>$A$为正定(半正定)对称矩阵$\Longleftrightarrow$$A$的各阶主子式为正（非负）</li></ul><p>对于对称正定线性方程组，最常用<strong>Cholesky分解法</strong>也叫<strong>平方根法</strong><br>将对称正定矩阵$A$做$LU$分解，得到$L$和$U$，进一步可将$U$化为$D \tilde{U}$<br>因为$A$是对称矩阵，所以有$L(D\tilde{U}) = (L(D\tilde{U}))^T = \tilde{U}^T(DL^T)$<br>因为$LU$分解的唯一性，可得$L = \tilde{U}^T$，即$A = LDL^T$<br>令$\tilde{L} = LD^{\frac{1}{2}}$，可得$A = \tilde{L}\tilde{L}^T$</p><p><strong>定理2.3</strong> $Cholesky$分解<br>对任意$n$阶对称正定矩阵A，均存在下三角矩阵$L$使$A=LL^T$成立，称其为对称正定矩阵$A$的Cholesky分解。进一步，如果规定$L$的对角元为正数，则L是唯一确定的。<br>因此，若线性方程组$Ax=b$的系数矩阵时对称正定的，便可按如下步骤求解：</p><ul><li>A的Cholesky分解：$A = LL^T$</li><li>$Ly=b \Rightarrow y$</li><li>$L^Tx=y \Rightarrow x$</li></ul><h2 id="Cholesky分解的直接分解法"><a href="#Cholesky分解的直接分解法" class="headerlink" title="Cholesky分解的直接分解法"></a>Cholesky分解的直接分解法</h2>$\begin{bmatrix}{a_{11}}&{a_{12}}&{\cdots}&{a_{1n}}\\{a_{21}}&{a_{22}}&{\cdots}&{a_{2n}}\\{\vdots}&{\vdots}&{\ddots}&{\vdots}\\{a_{n1}}&{a_{n2}}&{\cdots}&{a_{nn}}\\\end{bmatrix} = \begin{bmatrix} {l_{11}}&{0}&{\cdots}&{0}\\ {l_{21}}&{l_{22}}&{\cdots}&{0}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}\\ {l_{n1}}&{l_{n2}}&{\cdots}&{l_{nn}}\\ \end{bmatrix}  \begin{bmatrix} {l_{11}}&{l_{21}}&{\cdots}&{l_{n1}}\\ {0}&{l_{22}}&{\cdots}&{u_{n2}}\\ {\vdots}&{\vdots}&{\ddots}&{\vdots}\\ {0}&{0}&{\cdots}&{l_{nn}}\\ \end{bmatrix}$<p>分析可得：</p>$\begin{cases}a_{ii} = \sum\limits_{k = 1}^{i-1} l_{ik}^2 + l_{ii}^2 \\a_{ij} = \sum\limits_{k=1}^{j-1}l_{ik}l_{jk} + l_{ij}l_{jj}\quad j = 1,2,...,i-1 \end{cases}$<p>由上可得：</p>$\begin{cases}\\l_{ii} = \sqrt{a_{ii} - \sum\limits_{k = 1}^{i-1}l_{ik}^2}\\l_{ij} = \dfrac{a_{ij}-\sum\limits_{k=1}^{j-1}l_{ik}l_{jk}}{l_{jj}}\quad j = 1,2,...,i-1\end{cases}$<p>Cholesky分解计算$l$的次序<br>$l_{11},l_{21},..,l_{n1},l_{22},l_{32},…,l_{n2},…,l_{nn}$</p><p>因为$l_{ii} = \sqrt{a_{ii} - \sum\limits_{k = 1}^{i-1}l_{ik}^2} \ge 0$<br>所以$|l_ik| \le \sqrt{a_{ii}} \quad k = 1,2,…,i$<br>因此在分解过程中$L$元素的数量级不会增长，故<strong>平方根法</strong>通常是数值稳定的，不需要选取主元<br>其运算量为高斯消去法的一半</p><p>利用$LDL^T$分解可以避免开方运算</p><h2 id="三对角矩阵的三角分解"><a href="#三对角矩阵的三角分解" class="headerlink" title="三对角矩阵的三角分解"></a>三对角矩阵的三角分解</h2><p>三对角矩阵，对其进行$LU$分解</p>$\begin{bmatrix}{b_1}&{c_1}&{\cdots}&{\cdots}&{0}\\{a_2}&{b_2}&{c_2}&{\cdots} &{0}\\{\vdots}&{\vdots}&{\ddots}&{\ddots} &{\vdots}\\{0}&{\cdots}&{a_{n-1}}&{b_{n-1}}&{c_{n-1}}\\{0}&{\cdots}&{\cdots}&{a_n}&{b_n}\\\end{bmatrix} $$= \begin{bmatrix}{1}&{0}&{\cdots}&{\cdots}&{0}\\{l_2}&{1}&{0}&{\cdots} &{0}\\{\vdots}&{\vdots}&{\ddots}&{\ddots} &{\vdots}\\{0}&{\cdots}&{l_{n-1}}&{1}&{0}\\{0}&{\cdots}&{\cdots}&{l_n}&{1}\\\end{bmatrix} \begin{bmatrix}{u_1}&{d_1}&{\cdots}&{\cdots}&{0}\\{0}&{u_2}&{d_2}&{\cdots} &{0}\\{\vdots}&{\vdots}&{\ddots}&{\ddots} &{\vdots}\\{0}&{\cdots}&{0}&{u_{n-1}}&{d_{n-1}}\\{0}&{\cdots}&{\cdots}&{0}&{u_n}\\\end{bmatrix} $<p><strong>追赶法</strong>解三对角型方程组的步骤：</p>$$\begin{cases}d_i = c_i \quad i=1.2....,n-1 \\u_1 = b_1 \\l_i = \dfrac{a_i}{u_{i-1}} \quad i =2,3,...,n \\u_i = b_i - l_ic_{i-1} \quad i=2,3,...,n\end{cases}$$<p>计算次序为：<br>$u_1 \Rightarrow l_2 \Rightarrow u_2 \Rightarrow l_3 \Rightarrow u_3 \Rightarrow … \Rightarrow l_n \Rightarrow u_n$</p><p><strong>定理2.4</strong> 设具有三对角形式的矩阵$A$，满足条件</p><ul><li>$|b_1| &gt; |c_1| &gt; 0$</li><li>$|b_n| &gt; |c_n| &gt; 0$</li><li>$|b_i| \ge |a_i| + |c_i| \quad a_ic_i \not= 0 \quad i = 2,3,…,n-1$</li></ul><p>对角占优且矩阵不可约<br>则方程$Ax=f$可用追赶法，且解存在唯一<br>定理条件中有$a_ic_i \not= 0 $，如果有某个$a_i=0$或$c_i=0$，则可化成低阶方程组求解<br>追赶法整个求解过程仅需$5n-4$次乘除法，$3(n-1)$次加减法，总计$8n-7$次运算，$4$个一维数组即可<br>当$A$<strong>对角占优</strong>时，追赶法通常<strong>数值稳定</strong></p><p>严格对角占优，即$|b_i| &gt; |a_i| + |c_i| \quad a_ic_i \not= 0 \quad i = 2,3,…,n-1$，一定非奇异，解存在唯一</p><p>注：矩阵可约即为通过初等行列变换可以化成某一块全为0的分块矩阵，否则不可约</p><h2 id="条件数与方程组的性态"><a href="#条件数与方程组的性态" class="headerlink" title="条件数与方程组的性态"></a>条件数与方程组的性态</h2><p><strong>定义2.2</strong> 如果线性方程组$Ax=b$中，$A$或$b$的元素的微小变化，就会引起方程组解的巨大变化，则称方程组为“病态”方程组，矩阵$A$成为“病态”矩阵。否则称方程组为“良态”方程组，矩阵$A$成为“良态”矩阵。</p><p><strong>定义2.3</strong>设A为非奇异矩阵，$\Vert \cdot \Vert$为矩阵的算子范数，则称  <center>$cond(A)=\Vert A \Vert \Vert A^{-1} \Vert$</center><br>为矩阵$A$的条件数</p><p>相对误差放大因子<br>$A(x + \delta x) = b + \delta x \Rightarrow Ax + A\delta x = b + \delta b \Rightarrow \delta x = A^{-1}\delta b$<br>$\Vert \delta x \Vert \le \Vert A^{-1}\Vert \delta b \Vert $<br>$\Vert b \Vert = \Vert Ax \Vert \le \Vert A \Vert \Vert x \Vert \Rightarrow \dfrac{1}{\Vert x \Vert} \le \dfrac{\Vert A \Vert}{\Vert b \Vert}$<br>$\dfrac{\Vert \delta x \Vert}{\Vert x \Vert} \le \Vert A \Vert \Vert A^{-1} \Vert\dfrac{\Vert \delta b \Vert}{\Vert b \Vert}$<br>其中$\Vert A \Vert \Vert A^{-1} \Vert$被称为误差放大因子，令$cond(A) = \Vert A \Vert \Vert A^{-1} \Vert$为条件数</p><p>常用条件数有：</p><ul><li>$cond_\infty(A) = \Vert A \Vert_\infty \Vert A^{-1}\Vert_\infty$</li><li>$cond_1(A) = \Vert A \Vert_1 \Vert A^{-1}\Vert_1$</li><li>$cond_2(A) = \Vert A \Vert_2 \Vert A^{-1}\Vert_2 = \sqrt{\dfrac{\lambda_{max}(A^HA)}{\lambda_{min}(A^HA)}}$</li></ul><p>这里因为$AA^{-1}=I$，所以$\lambda_{max}(A^HA)^{-1} = \dfrac{1}{\lambda_{min}(A^HA)}$<br>矩阵条件数性质</p><ul><li>$cond(A) \ge 1$<br>  $cond(A) = \Vert A \Vert \Vert A^{-1} \Vert \ge \Vert AA^{-1} \Vert = \Vert I \Vert = 1$</li><li>$cond(A) = cond(A^{-1})$<br>  $cond(A^{-1})=\Vert A^{-1}\Vert\Vert (A^{-1})^{-1}\Vert=\Vert A^{-1}\Vert\Vert A \Vert = cond(A)$</li><li>$cond(\alpha A) = cond(A) \quad \alpha \not= 0 \quad \alpha \in R$<br>  $\Vert \alpha A \Vert\Vert (\alpha A)^{-1} \Vert= |\alpha|\Vert A\Vert \dfrac{1}{|\alpha|}\Vert A^{-1} \Vert =\Vert A \Vert\Vert A^{-1}\Vert = cond(A)$</li><li>如果$U$为酉（正交）矩阵，则<br>  $cond_2(U) = 1 \quad cond_2(UA) = cond_2(AU) = cond_2(A)$</li><li>$cond(AB) \le cond(A)cond(B)$  $cond(AB) = \Vert AB \Vert\Vert(AB)^{-1}\Vert \le \Vert A \Vert\Vert A^{-1}\Vert\Vert B \Vert\Vert B^{-1}\Vert \\ = cond(A)cond(B)$</li></ul><p>根据矩阵范数的等价性容易推出，$R^{n \times n}$上任意两个范数的条件数$cond_{\alpha}(A)$和$cond_{\beta}(A)$都是等价的，即存在常数$c_1$和$c_2$，使得<br>$c_1cond_{\alpha}(A) \le cond_{\beta}(A) \le c_2cond_{\alpha}(A)$<br>推广到</p><ul><li>$\dfrac{1}{n}cond_2(A) \le cond_1(A) \le ncond_2(A)$</li><li>$\dfrac{1}{n}cond_\infty(A) \le cond_2(A) \le ncond_\infty(A)$</li><li>$\dfrac{1}{n^2}cond_1(A) \le cond_\infty(A) \le n^2cond_1(A)$</li></ul><p>一个矩阵范数在$\alpha$范数下病态，则其在$\beta$范数下也是病态的<br>$cond(A)$越大，解的相对误差界可能越大，$A$对求解线性方程组来说越可能呈现病态，所以$cond(A)$越小越好</p><p>$n$阶$Hilbert$矩阵，随着$n$增大严重病态</p>$H_n = (h_{ij})_{n \times n} = (\dfrac{1}{i + j -1})_{n \times n} \quad i,j=1,2,...,n$<p><strong>定理2.5</strong> 设$Ax=b$，$A$为非奇异矩阵，$b$为非零向量且$A$与$b$均有扰动。若$A$的扰动$\delta A$非常小，使得$\Vert A^{-1} \Vert \Vert \delta A\Vert &lt; 1$ 则  </p><center>$\dfrac{\Vert \delta x \Vert}{\Vert x \Vert} \le \dfrac{cond(A)}{1-cond(A)\frac{\Vert \delta A \Vert}{\Vert A \Vert}}(\dfrac{\Vert \delta A \Vert}{\Vert A \Vert} + \dfrac{\Vert \delta b \Vert}{\Vert b \Vert})$</center>注：当A不存在扰动，即$\delta A = 0$时，原式变为$\dfrac{\Vert \delta x \Vert}{\Vert x \Vert} \le cond(A)\dfrac{\Vert \delta b \Vert}{\Vert b \Vert}$<p>注：当$\dfrac{\Vert \delta x \Vert}{\Vert x \Vert}$较小时，有$\dfrac{cond(A)}{1-cond(A)\frac{\Vert \delta A \Vert}{\Vert A \Vert}} \approx cond(A)$，从而有</p><center>$\dfrac{\Vert \delta x\Vert}{\Vert x \Vert} < \approx cond(A)(\dfrac{\Vert \delta A \Vert}{\Vert A \Vert} + \dfrac{\Vert \delta b \Vert}{\Vert b \Vert}) $</center><p>条件数的几何意义<br><strong>定理2.7</strong> 设$A \in R^{n \times n}$非奇异，则</p><center>$min{\dfrac{\Vert \delta A \Vert_2}{\Vert A \Vert_2}| A+\delta A奇异} = \dfrac{1}{\Vert \delta A \Vert_2\Vert \delta A^{-1} = \dfrac{1}{cond(A)}\Vert_2}$</center><p>即在谱范数下，一个矩阵的条件数的倒数正好等于该矩阵与全体奇异矩阵所成集合的相对距离（最小距离）<br>定理表明，当$A\in R^{n \times n}$十分病态时，就说明$A$已与一个奇异矩阵十分接近<br>说明了条件数越大，离奇异矩阵越近</p><h2 id="Householder矩阵"><a href="#Householder矩阵" class="headerlink" title="Householder矩阵"></a>Householder矩阵</h2><p><strong>正交矩阵</strong><br>$AA^T=E$，则$n$阶实对称矩阵A称为正交矩阵，其满足：</p><ul><li>$A^T$为正交矩阵</li><li>$A$各行为单位向量且两两正交</li><li>$A$各列为单位向量且两两正交</li><li>$(Ax,Ay)=y^TA^TAx = (x,y)$</li></ul><p>由矩阵的条件数定义可知，正交矩阵是性态最好的矩阵，例：$cond_2(A) = 1$<br>若能用正交矩阵代替高斯消去过程的单位下三角矩阵，即$Q_{n-1}…Q_2Q_1A = R$，记$Q^T=Q_{n-1}…Q_2Q_1$，则有$A=QR$<br>且$cond_2(A)=cond_2(QR)=cond_2(R)$，因此变换后所得的矩阵$R$条件数不变，故该计算过程具有数值稳定性</p><p><strong>初等矩阵</strong><br>$E(u，v;\alpha) = I - \alpha uv^H \quad u,v \in C^n, \alpha \in C$<br>$uv^H$是一个秩为1的矩阵，$1 \le rank(uv^H) \le rank(u) = 1$，其特征值为$v^Hu,0,0,..,0$<br>$(uv^H)u = u(v^Hu) = (v^Hu)u$ 结合律交换律，数乘列向量等于列向量乘数<br>$\lambda = v^Hu \not= 0$是矩阵$uv^H$的唯一非零特征值</p><p><strong>Householder变换矩阵</strong><br><strong>定义2.4</strong> 设$\omega \in R^n \quad \omega \not= 0 $称初等矩阵  <center>$H(\omega) = I - \dfrac{2}{\omega^T\omega}\omega\omega^T$</center><br>为Householder矩阵（简称H阵），或称其为Householder变换<br>实际上因为$\omega^T\omega = \Vert \omega \Vert_2^2$，所以原式为$$H(\omega) = I - \dfrac{2}{\Vert \omega \Vert_2^2}\omega\omega^T$$<br>特别的，令$\omega = (e_i - e_j)$则$\Vert \omega \Vert_2^2 = 2$，原式为$H(\omega)=I - (e_i - e_j)(e_i - e_j)^T$ 为一个初等<strong>置换矩阵</strong></p><p><strong>Householder性质</strong></p><ul><li><p>$H$阵为对称阵<br>  $H(\omega)^T = (I - \dfrac{2}{\omega^T\omega}\omega\omega^T)^T = I - \dfrac{2}{\omega^T\omega}(\omega\omega^T)^T = I - \dfrac{2}{\omega^T\omega}\omega\omega^T$</p></li><li><p>$H(\omega)^TH(\omega) = I$，即$H$阵为正交阵 </p>      $\begin{equation}      \begin{aligned}        H(\omega)^TH(\omega) &= (I - \dfrac{2}{\omega^T\omega}\omega\omega^T)^2 \\        &=I - \dfrac{4}{\omega^T\omega}\omega\omega^T + \dfrac{4}{\omega^T\omega}\omega\omega^T \\        &=I    \end{aligned}    \end{equation}$    </li><li><p>如果$H(\omega)x=y$，则$\Vert y \Vert_2 = \Vert x \Vert_2$</p>          $\begin{equation}          \begin{aligned}            \Vert y \Vert_2^2 = y^Ty &= (H(\omega)x)^T(H(\omega)x) \\            &=x^TH(\omega)^TH(\omega)x\\            &=x^Tx = \Vert x \Vert_2^2        \end{aligned}        \end{equation}$     <p>   故称Householder矩阵为镜面反射变换</p></li></ul><p><strong>镜面反射变换几何意义</strong><br>对任意$x$，可以找到一个平面$\pi$，使$x$由这个发出，对这个平面取单位法向量$\omega \quad \Vert \omega \Vert_2 = 1$，做$u$垂直于$\pi$，$v \in \pi$，有$u = \lambda \omega \quad x = u + v$<br>$H(\omega)x = (I -2\omega\omega^T)x = u + v -2\omega\omega^Tu - 2\omega\omega^Tv$<br>因为$u = \lambda \omega \quad v \perp \omega$<br>所以$H(\omega)x = u + v - 2 \omega \omega^T \lambda \omega =u + v -2 \lambda \omega = u + v - 2u = -u + v$</p><p>两个<strong>同等长度</strong>的已知向量$x$和$y$，寻找H阵使其构成镜面反射关系，即为寻找法向量$\omega$，而取$\omega = x-y$即可满足<br>计算$H(\omega)$的方法需利用如下性质：</p><ul><li>$\Vert x \Vert_2 = \Vert y \Vert_2$</li><li>$\omega = x-y$</li><li>$H(\omega) = I - \dfrac{2}{\omega^T\omega}\omega\omega^T $</li></ul><p>对$H$阵性质3进行扩展</p><ul><li>设$x = (x_1,x_2,…,x_n)^T \in R^n$且$x\not=0$，取$\omega = x \pm \Vert x \Vert_2e_1$则<br>  $H(\omega) = H(x \pm \Vert x \Vert_2e_1)x = \pm\Vert x \Vert_2e_1$<br>  $e^1$是一个方向向量，$x$的镜面反射在$e_1$方向上，则$y=\Vert x \Vert e_1$，且，这里有两个方向（$e_1$正向与$e_1$反向）<br>  与$e_1$正向时，$\omega = x - y = x - \Vert x \Vert e_1$<br>  与$e_1$反向时，$\omega = x + y = x + \Vert x \Vert e_1$</li></ul><p><strong>推论2.1</strong>设$x=(x_1,x_2,…,x_n)^T\in C^n $且$x\not=0$，则存在Householder矩阵$H(\omega)=I - \dfrac{2}{\omega^T\omega}\omega\omega^T$，使得$H(\omega)x=\alpha e_1$<br>其中$|\alpha|=\Vert x \Vert_2$，且$\alpha x^He_1$为实数，此为复Householder矩阵消元    </p><p>计算复$H(\omega)$的方法需利用如下性质：</p><ul><li>$\Vert x \Vert_2 = \Vert y \Vert_2$</li><li>$|\alpha| = \Vert x \Vert_2$，注此处获取的$\alpha$暂定为正</li><li>$\alpha x^He_1$ 为实数 $\Rightarrow \alpha x_1 $为实数获取$\alpha$实际值</li><li>$\omega = x-\alpha e_1$ </li><li>$H(\omega) = I - \dfrac{2}{\omega^T\omega}\omega\omega^T $</li></ul><h2 id="矩阵的QR分解"><a href="#矩阵的QR分解" class="headerlink" title="矩阵的QR分解"></a>矩阵的QR分解</h2><p>令矩阵$A = {x_1,x_2,…,x_n}$<br>求$x_1$的$H$阵，求得后，将$A$分块，求分块后$A^{(1)}$的$x_1$，即原降一阶$x_2$的$H$阵，以此类推，变化过程如下：</p>$\begin{bmatrix}{x_{11}^{(0)}}&{a_{12}^{(0)}}&{\cdots}&{a_{1m}^{(0)}}\\{a_{21}^{(0)}}&{a_{22}^{(0)}}&{\cdots}&{a_{2m}^{(0)}}\\{\vdots}&{\vdots}&{\ddots}&{\vdots}\\{a_{n1}^{(0)}}&{a_{n2}^{(0)}}&{\cdots}&{a_{nm}^{(0)}}\end{bmatrix}=\begin{bmatrix}{x_{11}^{(1)}}&{b^T}\\{0}&{A^{(1)}}\\\end{bmatrix}\qquad$<p>而经过如此分解获取的$Q_i$也是依次降阶，可以通过分块补齐阶数，例如$Q_2$</p>$Q_2=\begin{bmatrix}{1}&{0}\\{0}&{H_1}\\\end{bmatrix}$<p>依旧是正交对称矩阵<br>所以有$Q_{n-1}…Q_2Q_1A = R$，$R$为上三角矩阵，$Q_i$为对称正定矩阵<br>令$Q^T=Q_{n-1}…Q_2Q_1$，可得$A=QR$<br>$Q$正定不一定对称</p><p>注$Ax=b \Leftrightarrow (QR)x=b \Leftrightarrow Rx = Q^Tb$<br>所以计算步骤为$A=QR \Rightarrow y=Q^Tb \Rightarrow Rx=y$</p><p>QR分解的数值稳定性比LU分解好，但是计算量远大于LU分解，所以QR分解只适用于求解病态线性方程组<br>QR分解还可对非方阵进行分解</p><h2 id="矩阵的Schur分解"><a href="#矩阵的Schur分解" class="headerlink" title="矩阵的Schur分解"></a>矩阵的Schur分解</h2><p><strong>定理2.8</strong> Schur定理<br>设$A\in C^{n\times n}$，则存在酉阵$U\in C^{n\times n}$，使得$A=URU^H$，其中$R\in C^{n\times n}$为上三角矩阵。$A=URU^H$也称为<strong>矩阵的Schur分解</strong></p><ul><li>在矩阵的Schur分解中，由于$A$和$R$酉相似$(A=URU^H,U^HAU=R)$，所以具有相同的特征值，而上三角矩阵的特征值为其对角元，故Schur定理还可表示为<br>  任意$n$阶方阵酉相似于一个以其特征值为对角元的上三角矩阵$R$</li><li>通常称$R$为$A$的Schur标准型，通过$R$理论上得到了$A$的特征值，但是特征值的计算一般必须采取迭代法，通常无法在有限步内准确得到</li><li>Schur分解只能在复矩阵空间成立，实矩阵空间可能存在复数特征值</li><li>$U$的列向量未必都是$A$的特征向量，尽管第一列是$A$的特征向量，因为$U$的$u_1$对应$A$的第一个特征值$\lambda_1$的特征向量，剩下由其正交补空间中取标准正交基构成</li></ul><h2 id="正规矩阵的Schur分解"><a href="#正规矩阵的Schur分解" class="headerlink" title="正规矩阵的Schur分解"></a>正规矩阵的Schur分解</h2><p><strong>定义2.5</strong> 设$A\in C^{n\times n}$，若$A^HA=AA^H$，则称矩阵$A$为正规矩阵<br>常见正规矩阵有：</p><ul><li>Hermite阵：$A^H=A$</li><li>斜Hermite阵：$A^H=-A$</li><li>实对称矩阵：$A^T=A$</li><li>实反对称矩阵：$A^T=-A$</li><li>酉矩阵：$A^TA=AA^H=I$</li><li>正交矩阵：$A^TA=AA^T=I$</li></ul><p><strong>推论2.2</strong> 设A为$n$阶方阵，则$A$为正规矩阵的充要条件是存在$n$阶酉矩阵$U$，满足$A=UDU^H$，其中$D\in C^{n\times n}$为对角矩阵<br>充分性证明：<br>由于$A=UDU^H$，则</p>$$\begin{equation}\begin{aligned}A^HA &= (UDU^H)^H(UDU^H) \\&=UD^HU^HUDU^H=UD^HDU^H \\ AA^H&=(UDU^H)(UDU^H)^H \\&=UDU^HUD^HU^H=UDD^HU^H \\\end{aligned}\end{equation}$$<p>因为$D$为对角矩阵，$D^HD=DD^H$，所以$A^HA=AA^H$<br>必要性证明：<br>根据Schur定理，有$A=URU^H$，$U\in C^{n\times n}$为酉矩阵，$R$为上三角阵。则由假设可知$A$为正规矩阵，即可得$A^HA=AA^H \Rightarrow R^HR=RR^H$，即$R$是正规矩阵。而上三角阵$R$为正规矩阵$\Longleftrightarrow R$为对角矩阵</p><p>根据<strong>推论2.2</strong>可知$A=UDU^H$其中$D\in C^{n \times n}$为对角阵，可得$AU=DU$，即</p>$$D=\begin{bmatrix}\lambda_1&&&&\\&\ddots&&&\\&&\lambda_i&&\\&&&\ddots&\\&&&&\lambda_n\end{bmatrix}$$$$\begin{equation}\begin{aligned}A(u_1,u_2,\cdots,u_i,\dots,u_n)&=D(u_1,u_2,\dots,u_i,\cdots,u_n)\\Au_i &=\lambda u_i \quad i=1,2,\cdots,n\end{aligned}\end{equation}$$<p>由此可知酉阵$U$的列为矩阵$A$的特征值对应的特征向量</p><p><strong>推论2.3</strong> 设$A\in C^{n\times n}$，则</p><ul><li>$A$为Hermite矩阵的充要条件是存在$n$阶酉矩阵$U$，使得$A=UDU^H$，其中$D\in R^{n\times n}$为对角矩阵</li><li>$A$为斜Hermite矩阵的充要条件是存在$n$阶酉矩阵$U$，使得$A=UDU^H$，其中$D\in R^{n\times n}$为对角矩阵，且对角元素为纯虚数</li></ul><p><strong>推论2.4</strong> 设$A$为$n$阶方阵，则$A$为酉阵的充要条件是存在$n$阶酉矩阵$U$，使得$A=UDU^H$，其中$D\in C^{n\times n}$为对角矩阵，且其对角元的模均为1</p><p><strong>矩阵的基本分类</strong></p><ul><li>在正规矩阵集合中，特征值均为实数的子集为Hermite矩阵的集合，矩阵的特征值的模均为1的子集是酉矩阵的集合</li><li>$\begin{equation}\begin{aligned}一般矩阵&\supset 可对角化矩阵\\ &\supset正规矩阵\\ &\supset \begin{cases}Hermite矩阵 &\supset 实对称矩阵\\ 酉矩阵&\supset 实正交矩阵 \end{cases}\end{aligned}\end{equation}$</li></ul><h2 id="矩阵的谱半径与矩阵范数关系"><a href="#矩阵的谱半径与矩阵范数关系" class="headerlink" title="矩阵的谱半径与矩阵范数关系"></a>矩阵的谱半径与矩阵范数关系</h2><p><strong>定理2.9</strong> 设$A$为$n$阶方阵，$\varepsilon &gt; 0$，则在$C^{n\times n}$中存在一种矩阵范数$\Vert \cdot \Vert_M$（依赖矩阵$A$$\varepsilon$），满足$\Vert I \Vert_M=1$，且$\Vert A \Vert_M\le \rho(A) + \varepsilon$<br>构造性证明：<br>根据Schur定理，存在$n$阶酉阵$U$，使得$R=U^HAU$为上三角矩阵，其中对角元为矩阵$A$的特征值<br>记矩阵$R$的上三角元素为$R_{ij}(j\ge i)$，对任意的$\varepsilon &gt; 0$，取  </p>$\begin{equation}\begin{aligned}\delta &= min\{1, \dfrac{\varepsilon}{(n-1)\max\limits_{1\le i < j \le n}|r_{ij}|}\}  \quadD=\begin{bmatrix}1&&&& \\&\delta&&& \\&&\delta^2&& \\&&&\ddots& \\&&&&\delta^{n-1} \\\end{bmatrix} \\R&=\begin{bmatrix}r_{11}&r_{12}&\cdots&\cdots&r_{1n} \\&r_{22}&r_{23}&\cdots&r_{2n} \\&&\ddots&\ddots&\vdots \\&&&\ddots&r_{n-1n} \\&&&&r_{nn} \\\end{bmatrix}\quad\\D^{-1}RD&=\begin{bmatrix}r_{11}&r_{12}\delta&\cdots&\cdots&r_{1n}\delta^{n-1} \\&r_{22}&r_{23}\delta&\cdots&r_{2n}\delta^{n-2} \\&&\ddots&\ddots&\vdots \\&&&\ddots&r_{n-1n}\delta \\&&&&r_{nn} \\\end{bmatrix}\end{aligned}\end{equation}$<p>推导出</p>\begin{equation}\begin{aligned}\Vert D^{-1}U^HAUD\Vert_\infty &= \Vert D^{-1}RD\Vert_\infty \\ &=\max\limits_{1 \le i \le n}\sum\limits_{i \le j}^n|r_{ij}\delta^{i-1}|\le \max\limits_{1 \le i \le n}(|r_{ij}|+  \sum\limits_{i < j}^n \delta^{i-1} |r_{ij}|)\\&\le \max\limits_{1 \le i \le n}|\lambda_i| + \max\limits_{1 \le i < j \le n}|r_{ij}|(1+\delta+\cdots+\delta^{n-2})\delta\\&\le \rho(A)+(n-1)\max\limits_{1 \le i < j \le n}|r_{ij}|\delta\\&\le \rho(A)+\varepsilon \end{aligned}\end{equation}<p>现记<br>$\Vert A\Vert_M = \Vert D^{-1}U^HAUD\Vert_\infty=\Vert (UD)^{-1}A(UD)\Vert_\infty=\Vert MAM^{-1}\Vert_\infty$<br>其中$M=(UD)^{-1}$，$A$为任意$n$阶方阵，且满足<br>$\Vert I \Vert_M = \Vert MIM^{-1}\Vert_\infty=\Vert MM^{-1}\Vert_\infty=\Vert I \Vert_\infty=1$</p><p><strong>推论2.5</strong> 若$\rho(A)&lt;1$，则存在范数$\Vert \cdot \Vert$，使得$\Vert A\Vert&lt;1$<br>证明：<br>令$\varepsilon=\dfrac{1}{2}(1-\rho(A))&gt;0$</p>$\begin{equation}\begin{aligned}\Vert A \Vert \le \rho(A) + \varepsilon &= \rho(A) + \dfrac{1}{2}(1 - \rho(A))\\ &=\dfrac{1}{2}(1 + \rho(A)) \\& < 1 \end{aligned}\end{equation}$<p>$<br>tr(A)=\sum\limits_{k=1}^n a_{kk} \qquad<br>\Vert A \Vert_F^2 = \sum\limits_{i=1}^m \sum\limits_{j=1}^n |a_{ij}|^2 = tr(A^HA)<br>$</p><p><strong>定理2.10</strong> 设$A$为$n$阶方阵，则存在$n$阶酉矩阵$U$和$V$，使得<br>$$<br>\Vert UA\Vert_F=\Vert AV \Vert_F =\Vert UAV \Vert_F = \Vert A \Vert_F<br>$$<br>称之为<strong>F范数的酉不变性</strong><br>易证$\Vert UA\Vert_F^2=\Vert A \Vert_F^2$<br>证明$\Vert AV \Vert_F^2=\Vert A \Vert_F^2$<br>$<br>\Vert AV \Vert_F^2 = tr((AV)^H(AV))=tr(V^HA^HAV)<br>$<br>因为$V$可逆，所以$V^HA^HAV \sim VV^HA^HAVV^H$，相似矩阵具有相同特征值，所以<br>$<br>tr(V^HA^HAV)=tr(VV^HA^HAVV^H)=tr(A^HA)=\Vert A \Vert_F^2<br>$</p><p><strong>Schur不等式</strong><br>$$<br>\sum\limits_{i=1}^n|\lambda_i|^2 \le \sum\limits_{i=1}^n\sum\limits_{j=1}^n|a_{ij}|^2<br>$$<br>其中$\lambda_i$是矩阵$A$的特征值，并且Schur不等式中等号成立的充要条件是$A$为正规矩阵<br>证明：<br>有Schur定理可得，存在$n$阶酉矩阵$U$使得$A=URU^H$</p>$$\begin{equation}\begin{aligned}\sum\limits_{i=1}^n\sum\limits_{j=1}^n|a_{ij}|^2=\Vert A \Vert_F^2=\Vert URU^H \Vert_F^2 = \Vert R \Vert_F^2 = \sum\limits_{i=1}^n\sum\limits_{j=1}^n|r_{ij}|^2 \\\ge  \sum\limits_{i=1}^n |r_{ii}|^2 = \sum\limits_{i=1}^n |\lambda_i|^2\end{aligned}\end{equation}$$<h2 id="矩阵是否可对角化的判别法则"><a href="#矩阵是否可对角化的判别法则" class="headerlink" title="矩阵是否可对角化的判别法则"></a>矩阵是否可对角化的判别法则</h2><p><strong>矩阵的Jordan分解介绍</strong><br><strong>定义2.6</strong> 设$A$为$n$阶方阵，$A$的特征多项式为：<br>$$det(\lambda I_n -A)=(\lambda - \lambda_1)^{m_1}(\lambda - \lambda_2)^{m_2}\cdots (\lambda - \lambda_s)^{m_s}$$<br>其中$m_i \quad i=1,2,\cdots,s$均为正整数，$\sum\limits_{i=1}^s m_i = n $，$\lambda_1,\lambda_2,\cdots,\lambda_s$为$A$的不同特征值，称$m_i$为特征值$\lambda_i$的代数重复度；而与特征值$\lambda_i$对应的线性无关特征向量的个数，记成$\alpha_i$，为特征值$\lambda_i$的几何重复度；<br>也是子空间$N(\lambda_i I_n - A) = span\{x|(\lambda_i I_n - A)x = 0\}$的维数；<br>$N(\lambda_i I_n - A)$称为$\lambda_i I_n - A$的零空间<br>$\alpha_i = n - rank(\lambda_i I_n - A)$</p><p><strong>定理2.11</strong> 设$A$为$n$阶方阵，$\lambda_i$为其特征值，$m_i$和$\alpha_i$分别为其代数重复度和几何重复度，则$m_i \ge \alpha_i$<br>证明：<br>构造$n \times \alpha_i$阶矩阵$V_1$，其$\alpha_i$列构成了空间$N(\lambda_i I -A)$的一组标准正交基。将$V_1$扩充成酉矩阵$V$，从而可以得到</p>$$\begin{equation}\begin{aligned}B=V^HAV=\begin{bmatrix}\lambda_i I& C \\0&D\end{bmatrix}\end{aligned}\end{equation}$$<p>其中$I$为$\alpha_i \times \alpha_i$的单位矩阵，$C$是$\alpha_i \times \alpha_i$的矩阵，$D$是$(n - \alpha_i) \times (n - \alpha_i)$的矩阵，从而有<br>$$det(zI-B)=det(zI-\lambda_i I)det(zI-D)=(z-\lambda_i)^\alpha_idet(zI-D)$$<br>$det()$为求行列式<br>因此，作为$B$的特征值$\lambda_i$的代数重复度至少为$\alpha_i$，由于相似变化不改变重数，所以$A$的特征值$\lambda_i$的代数重复度满足$m_i \ge \alpha_i$<br>解题过程中，$m_i$直接根据求特征值获取，而$\alpha_i$可以通过计算代数余子式，获取秩，利用$\alpha_i=n-r(\lambda_i I -A)$获取，或者直接求解矩阵$A$的零空间$N(\lambda_i I - A)$的维数（非零解向量数）获取</p><p><strong>定义2.7</strong> 设$A$为$n$阶方阵，$\lambda_i$为其特征值，$m_i$和$\alpha_i$分别为其代数重复度和几何重复度。如果$m_i=\alpha_i$，则称$\lambda_i$为<strong>半单</strong>的；如果$m_i &gt; \alpha_i$，则称$\lambda_i$是亏损的<br>如果矩阵$A$的某一个特征值代数重复度为1，则它一定为半单的，大于1，可能是半单的</p><p><strong>定理2.12</strong> $n$阶方阵$A$可对角化的充要条件是每一个特征值$\lambda_i$都是半单的，即$m_i=\alpha_i \quad i=1,2,\cdots,s$。$A$是不可对角化的矩阵的充要条件是它存在亏损的特征值，即存在$i_0$使得$m_i&gt;\alpha_i$<br>所以称不可对角化的矩阵为亏损矩阵</p><h2 id="矩阵的Jordan分解"><a href="#矩阵的Jordan分解" class="headerlink" title="矩阵的Jordan分解"></a>矩阵的Jordan分解</h2><p><strong>定理2.13</strong> 设$A$为$n$阶方阵，则存在$n$阶可逆矩阵使得$A=TJT^{-1}$<br>其中$J=diag\{J_{n_1}(\lambda_1),J_{n_2}(\lambda_2),\cdots,J_{n_k}(\lambda_k)\},n_1+n_2+\cdots+n_k=n$<br>称其为矩阵$A$的$Jordan$分解，$Jordan$阵$J$称为$A$的$Jordan$标准型，$T$称为变化矩阵<br>矩阵$A$的$Jordan$标准型如果不计$Jordan$块的排列次序，则是确定唯一的</p><p>注：根据相似矩阵特征值相同，使用$Jordan$标准型的对角元素就是$A$的特征值，而不同的$Jordan$块的对角元素$\lambda_i$可能相同，所以$\lambda_i$不一定是$A$的$n_i$重特征值。一般特征值$\lambda_i$的重数大于等于$n_i$</p><p><strong>$Jordan$标准型</strong><br>$Jordan$标准型是一个块对角矩阵，其对角元为矩阵$J$的特征值<br>对于特征值$\lambda_i$，其<strong>代数重复度</strong>是$Jordan$标准型中以$\lambda_i$为特征值的$Jordan$块阶数的和，其<strong>几何重复度</strong>为$\lambda_i$为特征值的$Jordan$块个数</p><p><strong>定理2.14</strong>设$A$为$n$阶方阵，$\lambda_i$为其特征值，则$A$的$Jordan$标准型$J$中以$\lambda_i$为特征值，阶数为$l$的$Jordan$块的个数为：<br>$$r_{l+1}+r_{l-1}-2r_l$$<br>其中$r_l=rank(\lambda_i I-A)^l, r_0=rank(\lambda_i I -A )^0=rank(I)=n$</p><p>利用该公式，可以判断类似4重根代数重复度为4几何重复度为2，$Jordan$块的情况（$1,3 or 2,2$），唯一确定$Jordan$标准型</p><h2 id="关于变换矩阵T"><a href="#关于变换矩阵T" class="headerlink" title="关于变换矩阵T"></a>关于变换矩阵T</h2><p>在求出$A$的Jordan标准型后，由$A=TJT^{-1}$或$AT=TJ$，将$T$按$J$的对角线上的Jordan块相应分块为$T=(T_1,T_2,\cdots,T_k)$，其中$T_i$为$n\times n_i$型矩阵。则有</p>$$\begin{equation}\begin{aligned}A(T_1,T_2,\cdots,T_k)=(T_1,T_2,\cdots,T_k)\begin{bmatrix}J_{n_1}(\lambda_1)&&&\\&J_{n_2}(\lambda_2)&&\\&&\ddots&\\&&&J_{n_k}(\lambda_k)\end{bmatrix}\end{aligned}\end{equation}$$<p>显然，$\lambda_1,\lambda_2,\cdots,\lambda_k$中可能有相同者<br>$AT_I=T_IJ_{n_i}(\lambda_i)$，若记$T_i=(t_1^i,t_2^i,\cdots,t_{n_i}^i)$，可有</p>$$\begin{equation}\begin{aligned}A(t_1^i,t_2^i,\cdots,t_{n_i}^i)=(t_1^i,t_2^i,\cdots,t_{n_i}^i)\begin{bmatrix}\lambda_i&1&&\\&\lambda_i&\ddots&\\&&\ddots&1\\&&&\lambda_i\end{bmatrix}\end{aligned}\end{equation}$$<p>即</p>$\begin{cases}At_1^i=\lambda_i t_1^i \\At_2^i=\lambda_i t_2^i + t_1^i\\\vdots \qquad\qquad\qquad t_j^i \in C^n\\At_{n_i}^i=\lambda_i t_{n_i}^i + t_{n_i - 1}^i\end{cases}\quad i=1,2,\cdots,k \quad j=1,2,\cdots,n_i$<p>称向量组$t_1^i,t_2^i,\cdots,t_{n_i}^i$为关于特征值$\lambda_i$的长度为$n_i$的Jordan链<br>该Jordan链的第一个向量是矩阵$A$关于特征值$\lambda_i$的特征向量，称其为<strong>链首</strong>。而链中的第$j$个向量则可由等价的如下方程确定<br>$$(A-\lambda_i I_n)t_j^i=t_{j-1}^i \quad j=2,3,\cdots,n_i$$<br>需要注意的是：</p><ul><li>Jordan链的链首$t_1^i$不仅要求是一个特征向量，而且还要利用上述公式求出其他向量$t_2^i,\cdots,t_{n_i}^i$（即不是任何一个特征向量都可作为Jordan链链首）</li><li>对于某个特征值$\lambda_i$的Jordan链虽然一定存在，但当与$\lambda_i$相对应的线性无关的特征向量的个数大于或等于2时，关于特征值$\lambda_i$的那些特征向量中的任何一个有可能都不能作为链首<br>所以必须从$\lambda_i$的特征子空间中选取适当的向量做Jordan链链首，根据多个特征向量进行线性组合还是特征向量的特性</li></ul><h2 id="Hamilton-Caylay定理及其应用"><a href="#Hamilton-Caylay定理及其应用" class="headerlink" title="Hamilton-Caylay定理及其应用"></a>Hamilton-Caylay定理及其应用</h2><p>设$A\in C^{n\times n} \quad \psi(\lambda) = det(\lambda I - A)$，则$\psi(A) = 0$<br>$Hamilton-Caylay$定理在简化计算中的应用</p><ul><li>求矩阵多项式$f(A)$<br>  首先根据公式求出$\psi(\lambda)$，然后根据$f(\lambda)=g(\lambda)\psi(\lambda) + h(\lambda)$<br>  由定理可知，$\psi(A)=0$，所以$f(A) = h(A)$</li><li>求矩阵的逆<br>  根据$\psi(A)=0$，可得$\psi(A)=a_nA^n + \cdots + a_1A^1 + a_0I = 0$<br>  可得$A^{-1}=t(A)$，$t(A)$为A的多项式，计算即可得逆矩阵</li><li>求$A$的$n$次幂<br>  根据$\lambda^k = g(\lambda)\psi(\lambda)+a_{n-1}\lambda^{n-1}+\cdots + a_2\lambda^2 + a_1\lambda+a_0$<br>  先解出$\lambda$，1重特征值直接代入上式子得到方程，$n$重特征值变对上式进行$0,1,\cdots,n-1$次求导代入得到方程<br>  解方程得到$a_{n-1},\cdots,a_1,a_0$，从而可得<br>  $A^k=a_{n-1}\lambda^{n-1}+\cdots + a_2\lambda^2 + a_1\lambda+a_0$</li></ul><p>证明：<br>设$\psi(\lambda)=det(\lambda I-A)=(\lambda-\lambda_1)^{n_1}(\lambda-\lambda_2)^{n_2}\cdots(\lambda-\lambda_s)^{n_s}$<br>根据<strong>定理3.3</strong>可得<br>$\psi(A)=T diag(\psi(J_1),\psi(J_2),\cdots,\psi(J_s)) T^{-1}$<br>其中$  \begin{equation}  \begin{aligned}  \psi(J_i)=  \begin{bmatrix}  \psi(\lambda_i)&\psi'(\lambda_i)&\cdots&\dfrac{\psi^{(n_i-1)}(\lambda_i)}{(n_i-1)!}\\  &\psi(\lambda_i)&\ddots&\vdots\\  &&\ddots&\psi'(\lambda_i)\\  &&&\psi(\lambda_i)  \end{bmatrix} \quad i=1,2,\cdots,s  \end{aligned}  \end{equation}  $<br>又因为$\psi(\lambda_i)=0$，所以$\psi(J_i)=0$，所以$\psi(A)=0$</p><h2 id="矩阵的奇异值定义"><a href="#矩阵的奇异值定义" class="headerlink" title="矩阵的奇异值定义"></a>矩阵的奇异值定义</h2><p>对比$Jordan$分解$A=TJT^{-1}$和$Schur$分解$A=URU^H$</p><ul><li>变换矩阵：可逆（宽松）$\Longrightarrow U$阵（严格）</li><li>标准型：双对角矩阵（严格）$\Longrightarrow $上三角矩阵（宽松）</li></ul><p><strong>定义2.8</strong>设$A \in C%{n\times n} \quad k = min(m,n)$，$Hermite$半正定矩阵$A^HA$的特征值为<br>$$<br>\lambda_1 \ge \lambda_2 \ge \cdots \lambda_k \ge 0<br>$$<br>称非负实数$\sigma_i(A)=\sqrt{\lambda_i} \quad i = 1,2,\cdots,k$为矩阵A的奇异值<br><strong>定理2.15</strong>设$A,B\in C^{m\times n}$，如果存在$m$阶，$n$阶酉阵$U,V$使得$A=UBV^H$，则矩阵$A,B$的奇异值相同<br>证明：</p>$$\begin{equation}\begin{aligned}B^HB&=(U^HAV)^H(U^HAV)\\&=V^HA^HUU^HAV \\&=V^H(A^HA)V\end{aligned}\end{equation}$$<p>所以$B^HB \sim A^HA$，所以其特征值相同，故奇异值相同</p><h2 id="矩阵的奇异值分解定理"><a href="#矩阵的奇异值分解定理" class="headerlink" title="矩阵的奇异值分解定理"></a>矩阵的奇异值分解定理</h2><p><strong>定理2.16</strong> 设$A\in C^{n \times n}$，且其秩$rank(A)=r$，则存在$m$阶$n$阶酉阵$U,V$使得</p>$$\begin{equation}\begin{aligned}A=U\begin{bmatrix}\Sigma&0\\0&0\end{bmatrix}\end{aligned}\end{equation}$$<p>其中</p>$\begin{equation}\begin{aligned}\Sigma = \begin{bmatrix}\sigma_1&&&\\&\sigma_2&& \\&&\ddots& \\&&&\sigma_r \\\end{bmatrix}V^H\end{aligned}\end{equation}$<p>$\quad \sigma_i(i=1,2,\cdots,r)$为矩阵A的非零奇异值</p><p>假定矩阵$A \in C^{m\times n},rank(A)=r$<br>$A^HA$为$Hermite$半正定矩阵，特征值均为实数且非负，又有$rank(A^HA)=rank(AA^H)=rank(A^H)=rank(A)$<br>证明：<br>若$Ax=0$，则$A^HAx=0$，反之，若$A^HAx=0$，则有<br>$$0=((A^HA)x,x)=(Ax,Ax)=\Vert Ax \Vert_2^2$$<br>于是有$Ax=0$，这说明$Ax=0$与$A^HAx=0$同解，所以其基础解系解向量个数相同<br>即$n-rank(A)=n-rank(A^HA)$<br>故有$rank(A^HA)=rank(A)=rank(A^H)$</p><p>根据$Schur$定理<strong>推论2.2</strong>，存在$n$阶矩阵$V$，使得</p>$\begin{equation}\begin{aligned}V^H(A^HA)V = \begin{bmatrix}\sigma_1^2&&&&&\\&\ddots&&&& \\&&\sigma_r^2&&& \\&&&0&& \\&&&&\ddots& \\&&&&&0 \\\end{bmatrix}=\begin{bmatrix}\Sigma^2&0\\0&0\end{bmatrix}\end{aligned}\end{equation}$<p>将$V$矩阵分块：$V=[V_1,V_2],V_1\in ^{n\times r},V_2\in C^{n\times (n-r)}$<br>则有$\begin{equation}   \begin{aligned}   V^HA^HAV&=   \begin{bmatrix}   V_1^H\\   V_2^H    \end{bmatrix}A^HA[V_1,V_2]\\    &=\begin{bmatrix}    V_1^HA^HAV_1 & V_1^HA^HAV_2    \end{bmatrix}=    \begin{bmatrix}    \Sigma^2&0\\    0&0    \end{bmatrix}    \end{aligned}    \end{equation}$<br>可以得到$V_1^HA^HAV_1=(AV_1)^H(AV_1)=\Sigma^2$，$AV_1$的列相互正交；<br>$V_2^HA^HAV_2=(AV_2)^H(AV_2)=0 \quad AV_2=0$<br>令$U_1= AV_1\Sigma^{-1}$，从而有<br>$U_1^HU_1=\Sigma^{-1}V_1^HA^HAV_1\Sigma^{-1}=\Sigma^{-1}\Sigma^{2}\Sigma^{-1}=I_r$<br>再取$U_2\in C^{m\times (m-r)}$为$U_1$的标准正交补，使得$U=[U_1,U_2]\in C^{m\times m}$<br>且有</p>$\begin{equation}\begin{aligned}U^HU=\begin{bmatrix}U_1^H\\U_2^H\end{bmatrix}[U_1, U_2] = \begin{bmatrix}I_1^H&0\\0&I_2^H\end{bmatrix}\end{aligned}\end{equation}$<p>$U_1=AV_1\Sigma^{-1} \Rightarrow U_1\Sigma = AV_1, AV_2=0,U_2^HU_1=0$<br>则有</p>$  \begin{equation}  \begin{aligned}  U^HAV&=  \begin{bmatrix}  U_1^H\\  U_2^H  \end{bmatrix}  A(V_1, V_2)\\ &=   \begin{bmatrix}  U_1^HAV_1&U_1^HAV_2\\  U_2^HAV_1&U_2^HAV_2  \end{bmatrix}  =\begin{bmatrix}   \Sigma&0\\   0&0   \end{bmatrix}    \end{aligned}  \end{equation}  $<p>即有</p>$  \begin{equation}  \begin{aligned}A=U\begin{bmatrix}      \Sigma&0\\      0&0      \end{bmatrix}V^H \end{aligned}  \end{equation}  $<p>称上式为矩阵$A$的奇异值分解，亦称为矩阵$A$的<strong>满的奇异值分解</strong>，简称<strong>SVD定理</strong><br>上式乘开可以得到$ A = U_1 \Sigma V_1$，称为矩阵$A$<strong>约化的奇异值分解</strong><br>由约化的奇异值分解可得<br>$AV_1=U_1\Sigma$和$U_1^HA=\Sigma V_1^H$<br>由于$V_1=(v_1,v_2,\cdots,v_r), U_1=(u_1,u_2,\cdots,u_r)$<br>进一步有$Av_i=\sigma_i u_i,u_i^HA=\sigma_i v_i^H, i = 1,2,\cdots, r$<br>分别称$v_i$和$u_i$为矩阵$A$的与奇异值$\sigma_i$对应的<strong>右奇异向量</strong>和<strong>左奇异向量</strong><br>对$U,V$的列向量$u_1,u_2,\cdots,u_m$和$v_1,v_2,\cdots,v_n$<br>满足</p>$  \begin{equation}  \begin{aligned}AA^HU&=UU^HAVV^HA^HU=U(U^HAV)(U^HAV)^H \\&=U\begin{bmatrix}         \Sigma&0\\         0&0         \end{bmatrix}    \begin{bmatrix}          \Sigma^H&0\\          0&0          \end{bmatrix}=          U\begin{bmatrix}                 \Sigma^2&0\\                 0&0                 \end{bmatrix}\\AA^HV&=VV^HAUU^HA^HV=V(U^HAV)^H(U^HAV) \\&=V\begin{bmatrix}         \Sigma^H&0\\         0&0         \end{bmatrix}    \begin{bmatrix}          \Sigma&0\\          0&0          \end{bmatrix}=          V\begin{bmatrix}                 \Sigma^2&0\\                 0&0                 \end{bmatrix}\end{aligned}  \end{equation}  $<p><strong>推论2.6</strong> 设$A\in C^{n\times n}$，且其秩$rank(A)=n$，则存在$n$阶酉阵$U,V$使得</p>$$\begin{equation}\begin{aligned}A=U\begin{bmatrix}\Sigma_1&&&\\&\Sigma_2&&\\&&\ddots&\\&&&\Sigma_2\end{bmatrix}V^H\end{aligned}\end{equation}$$<p>$\sigma_i &gt;0 \quad (i=1,2,\cdots,n)$为矩阵$A$奇异值</p><p><strong>$SVD$和特征值分解区别</strong></p><ul><li>SVD用两组不同的基（左右奇异向量），而特征值分解只用一组（特征向量）</li><li>SVD使用正交基，而特征值分解所用的基一般不是正交的</li><li>并非所有矩阵（甚至方阵）有特征值分解，但是所有的矩阵（甚至长方阵）都有奇异值分解</li></ul><p><strong>特征系统分解</strong></p><ul><li>$Schur$分解：$A\in C^{n \times n}, A=URU^H$，$U$为酉矩阵，$R$为上三角矩阵</li><li>$Jordan$分解：$A\in C^{n \times n}, A=TRT^{-1}$，$T$为逆阵，$J$为$A$的$Jordan$标准型</li><li>特征值分解：$A\in C^{n \times n}, A=TDT^{-1}$，$A$非亏损，$T$的列为$A$的特征值对应的特征向量</li><li>奇异值分解：$A\in C^{m \times n}, A=UDV^{H}$，$U,V$为酉矩阵，$D$为对角矩阵，$D$的元素为$A$的奇异值</li><li>约化奇异值分解：$A\in C^{m \times n}, A=U_1\Sigma V_1^{H}$，$\Sigma$为对角矩阵，$\Sigma$的元素为$A$的<strong>非零</strong>奇异值<br>  $U_1$的列向量为$A$的非零奇异值对应的左奇异向量，$V_1$的列向量为$A$的非零奇异值对应的右奇异向量</li></ul><h2 id="矩阵的奇异值分解步骤"><a href="#矩阵的奇异值分解步骤" class="headerlink" title="矩阵的奇异值分解步骤"></a>矩阵的奇异值分解步骤</h2><ul><li><p>$\lambda I -A^HA$得到特征值，开方得到奇异值</p></li><li>$V^H(A^HA)V=\begin{equation}\begin{aligned}\begin{bmatrix}\Sigma^2&0 \\0&0\end{bmatrix}\quad\Sigma = \begin{bmatrix}\sigma_1&&&\\&\sigma_2&&\\&&\ddots&\\&&&\sigma_r\end{bmatrix}\end{aligned}\end{equation}$<p>  其中$\sigma_i(A)=\sqrt(\sigma_i)\quad i=1,2,\cdots,r$</p></li><li><p>将$V$矩阵分块：$V=[V_1.V_2],V_1\in C^{n \times r},V_2\in C^{n \times (n-r)}\quad AV_1$的列相互正交；$AV_2=0$</p></li><li><p>令$U_1=AV_1\Sigma^{-1}\in C^{m\times r}$且满足$U_1^HU_1=I_r$</p></li><li><p>再取$U_2\in C^{m\times (m-r)}$为$U_1$的标准正交补，即$U_2^HU_1=0$，<br>  做$U=(U_1,U_2)\in C^{m\times m},U^HU=I$</p></li><li>$  \begin{equation}  \begin{aligned}  A=U  \begin{bmatrix}  \Sigma&0\\  0&0  \end{bmatrix}V^H,A=U_1\Sigma V_1^H  \end{aligned}  \end{equation}  $</li></ul><h2 id="用矩阵的奇异值讨论矩阵的性质"><a href="#用矩阵的奇异值讨论矩阵的性质" class="headerlink" title="用矩阵的奇异值讨论矩阵的性质"></a>用矩阵的奇异值讨论矩阵的性质</h2><p><strong>定理2.17</strong> 矩阵$A$的非零奇异值的个数恰为矩阵$A$的秩，即为计算矩阵$A$的秩的数值方法，同时也是判断一个向量组是否线性相关的数值方法<br><strong>定理2.18</strong> </p>$R(A)=span \{ u_1,u_2,\cdots,u_r \} ,N(A)=span\{v_{r+1},v_{r+2},\cdots,v_{n},\}$，其中$\forall A \in R^{m\times n}$<p>其中$R(A)=\{y\in R^m|Ax=y,\forall x \in R^n\}$称为$A$的<strong>值域</strong>或者<strong>像空间</strong><br> $R(A)=\{y\in R^n|Ax=0\}$称为$A$的<strong>零空间</strong>或者<strong>核</strong><br>该定理表明，借助矩阵的奇异值$(SVD)$分解，可以确定子空间$R(A)$和$N(A)$的一组标准正交基<br>由矩阵$A$的约化奇异值分解：$A=U_1\Sigma V_1^H$可得$AV_1=U_1\Sigma=(\sigma_1u_1,\sigma_2u_2,\cdots,\sigma_ru_r)$<br>又由$V_2^HA^HAV_2=(AV_2)^H(AV_2)=0$得出$AV_2=0$<br>而$U_1=(u_1,u_2,\cdots,u_r),V_2=(v_{r+1},v_{r+2},\cdots,v_{n})$<br>分别构成标准正交向量组，生成$r$维和$n-r$维两个子空间<br>$y=\sum\limits_{i=1}^r \alpha_i u_i \in span{u_1,u_2,\cdots,u_r} \Rightarrow Ax=y$<br>$x=\sum\limits_{i=1}^{n-r} \alpha_i v_{r+i} \in span{v_{r+1},v_{r+2},\cdots,v_n} \Rightarrow Ax=0$</p><p><strong>定理2.19</strong>设$A$的非零奇异值为$\sigma_1 \ge \sigma_2 \ge \cdots \ge \sigma_r \ge 0$，则<br>$$\Vert A \Vert_2 = \sigma_1,\Vert A \Vert_F=\sqrt{\sigma_1^2+\sigma_2^2+\cdots+\sigma_r^2}$$<br>证明：</p>$$\begin{equation}\begin{aligned}\Vert A \Vert_F^2=\left\Vert U\begin{bmatrix}\Sigma&0\\0&0\end{bmatrix}V^H\right\Vert_F^2=\left\Vert\begin{bmatrix}\Sigma&0\\0&0\end{bmatrix}\right\Vert_F^2=\sigma_1^2+\sigma_2^2+\cdots+\sigma_r^2\end{aligned}\end{equation}$$<p>该定理表明，借助矩阵的奇异值（SVD）分解，我们可以确定矩阵$A$的2范数和$F$范数</p><p>由<strong>推论2.6</strong>可知，当$A$可逆时，存在$n$阶酉矩阵$U,V,U_1,V_1$使得</p>\begin{equation}\begin{aligned}\sigma_i(A)=\sqrt{\lambda_i(A^HA)},\sigma_i(A^{-1})=\sqrt{\lambda_i((A^HA)^{-1})},i=1,2,\cdots,n\\\lambda_i((A^HA)^{-1})=\dfrac{1}{\lambda_i(A^HA)},i=1,2,\cdots,n \quad 特别的有\lambda_1(A{-1})=\dfrac{1}{\lambda_n(A)}\end{aligned}\end{equation}  <p>由<strong>定理2.19</strong>可得<br>$\Vert A\Vert_2=\sqrt{\lambda_{max}(A^HA)},\Vert A^{-1}\Vert_2=\sqrt{\dfrac{1}{\lambda_{max}(A^HA)}}$<br>则$cond_2(A)=\Vert A\Vert_2 \Vert A^{-1}\Vert_2=\sqrt{\dfrac{\lambda_{max}(A^HA)}{\lambda_{min}(A^HA)}}$</p><p><strong>定理2.20</strong> 如果$A$为$Hermite$矩阵，则$A$的奇异值即为$A^H=A$的特征值的绝对值<br>证明：由$A^HA=A^2$<br>$$\sigma_i(A)=\sqrt{\lambda_{i}(A^HA)}=\sqrt{\lambda_{i}(A^2)}=\sqrt{\lambda_{i}(A)}=|\lambda_i(A)|$$</p><p><strong>定理2.21</strong> 如果$A$为$n$阶方阵，则$|det(A)|=\prod\limits_{i=1}^n\sigma_i(A)$<br>证明：</p>$$\begin{equation}\begin{aligned}|det(A)|&=\sqrt{[det(A)]^2} \\&=\sqrt{det(A^H)det(A)}=\sqrt{det(A^HA)}\\&=\sqrt{\prod\limits_{i=1}^n\lambda_i(A^HA)}=\sqrt{\prod\limits_{i=1}^n\sigma_i^2(A)}\\&=\prod\limits_{i=1}^n\sigma_i(A)\end{aligned}\end{equation}$$<p><strong>定理2.22</strong> 秩为$r$的$m\times n$矩阵$A$可以表示为$r$个秩为1的矩阵的和<br>$$A=\sigma_1u_1v_1+\sigma_2u_2v_2+\cdots+\sigma_ru_rv_r$$<br>证明：由矩阵$A$约化的奇异值分解$A=U\Sigma V_1^H$可知<br>$$U_1=(u_1,u_2,\cdots,u_r)\quad V_1^H=(v_1^H,v_2^H,\cdots,v_r^H)^T$$<br>$$U_1\Sigma=(\sigma_1 u_1,\sigma_2 u_2,\cdots,\sigma_r u_r)$$</p>\begin{equation}\begin{aligned}A=U_1\Sigma V_1^H&=(u_1,u_2,\cdots,u_r)\quad V_1^H=(v_1^H,v_2^H,\cdots,v_r^H)\begin{bmatrix}v_1^H\\v_2^H\\\vdots\\v_r^H\end{bmatrix}\\&=\sigma_1u_1v_1+\sigma_2u_2v_2+\cdots+\sigma_ru_rv_r\end{aligned}\end{equation}<h1 id="矩阵分析基础"><a href="#矩阵分析基础" class="headerlink" title="矩阵分析基础"></a>矩阵分析基础</h1><h2 id="矩阵序列及其收敛定义和性质"><a href="#矩阵序列及其收敛定义和性质" class="headerlink" title="矩阵序列及其收敛定义和性质"></a>矩阵序列及其收敛定义和性质</h2><p><strong>矩阵序列</strong><br>按整数$k$的序列，将$C^{m\times n}$中的矩阵排成一列$A_1,A_2,A_3,\cdots,A_k,\cdots$<br>称这列有序的矩阵为<strong>矩阵序列</strong>，称$A_k$为<strong>矩阵序列的一般项</strong></p><p><strong>定义3.1</strong> $\{A_k\}_{k=1}^\infty$为$C^{m\times n}$中的矩阵序列，其中$A_k=(a_{ij}^{(k)}), A=(a_{ij})\in C^{m\times n}$。如果$\lim\limits_{k\rightarrow \infty} a_{ij}^{(k)}=a_{ij}$对$i=1,2,3,\cdots,m\quad j=1,2,3,\cdots,n$均成立，则称矩阵序列$\{A_k\}_{k=1}^\infty$收敛，而$A$称为矩阵序列$\{A_k\}_{k=1}^\infty$的极限，记为$\lim\limits_{k\rightarrow \infty}A_k=A$。不收敛的矩阵序列称为发散的</p><p><strong>矩阵序列的性质</strong><br><strong>定理3.1</strong> 设$\{A_k\}_{k=1}^\infty$为$C^{m\times n}$中的矩阵序列，$\Vert \cdot\Vert$为$C^{m\times n}$中的一种矩阵范数，则矩阵序列$\{A_k\}_{k=1}^\infty$收敛于矩阵$A$的充要条件是$\Vert A_k - A\Vert$收敛于0.<br>证明：根据范式的等价性可得，对于$C^{m\times n}$中的任意两个矩阵范数$\Vert \cdot\Vert_t$和$\Vert \cdot\Vert_s$，存在常数$c_2\ge c_1\ge 0$，使得<br>$$c_2\cdot \Vert A_k - A\Vert_t \le \Vert A_k - A\Vert_s \le c_1\cdot \Vert A_k - A\Vert_t$$<br>即有$\lim\limits_{k\rightarrow \infty}\Vert A_k - A\Vert_t=0=\lim\limits_{k\rightarrow \infty}\Vert A_k - A\Vert_s$<br>即任意范数收敛于零是一致的</p><p><strong>推论3.1</strong> 设$\{A_k\}_{k=1}^\infty,A\in C^{m\times n}$，并且$\lim\limits_{k\rightarrow \infty}A_k=A$，则$\lim\limits_{k\rightarrow \infty}\Vert A_k\Vert =\Vert A\Vert$<br>证明：<br>因为$\left\vert \Vert A_k\Vert-\Vert A \Vert \right\vert \le |A_k-A|$，所以结论成立，但反过来不一定成立，例如$A_k$存在元素为$(-1)^k$发散，但是在$F$范数下，与$A$中对应位置元素相等</p><p><strong>性质3.1</strong> 设$\{A_k\}_{k=1}^\infty$和$\{B_k\}_{k=1}^\infty$为$C^{m\times n}$中的矩阵序列，<br>并且$\lim\limits_{k\rightarrow \infty}A_k=A,\lim\limits_{k\rightarrow \infty}B_k=B$则有<br>$$ \lim\limits_{k\rightarrow \infty}(\alpha A_k + \beta B_k)=\alpha A + \beta B\quad \forall \alpha,\beta \in C$$<br>证明：<br>$$\Vert (\alpha A_k + \beta B_k) - (\alpha A + \beta B)\Vert \le |\alpha|\Vert A_k-A \Vert + |\beta|\Vert B_k-B \Vert = 0$$</p><p><strong>性质3.2</strong> 设$\{A_k\}_{k=1}^\infty$和$\{B_k\}_{k=1}^\infty$分为$C^{m\times n}$和$C^{n\times l}$中的矩阵序列，并且$\lim\limits_{k\rightarrow \infty}A_k=A,\lim\limits_{k\rightarrow \infty}B_k=B$则有<br>$$ \lim\limits_{k\rightarrow \infty}(A_k B_k)= AB$$<br>证明：</p>$$\begin{equation}\begin{aligned}\Vert A_kB_k - AB\Vert &= \Vert A_kB_k - A_kB + A_kB - AB\Vert \\&\le  \Vert A_k \Vert\Vert B_k - B\Vert +\Vert B \Vert\Vert A_k - A\Vert = 0\end{aligned}\end{equation}$$<p><strong>性质3.3</strong> 设$\{A_k\}_{k=1}^\infty \in C^{n\times n}$中的矩阵序列，$\lim\limits_{k\rightarrow \infty}A_k =A$且有$A_k(k=1,2,\cdots)$和$A\in C^{n\times n}$<strong>均为可逆矩阵</strong>，则$\lim\limits_{k\rightarrow \infty}A_k^{-1}=A^{-1}$<br>证明：</p>$$\begin{equation}\begin{aligned}&\because (A_k)^{-1}和A^{-1}存在 \\&\therefore \lim\limits_{k\rightarrow \infty} det(A_k)=det(A)\not=0 \\&\therefore \lim\limits_{k\rightarrow \infty}\tilde{A_k}=\lim\limits_{k\rightarrow \infty}\tilde{A}\not=0 \\&\therefore \lim\limits_{k\rightarrow \infty}(A_k)^{-1}=\lim\limits_{k\rightarrow \infty}\dfrac{\tilde{A_k}}{det(A_k)}= \dfrac{\tilde{A}}{det(A)} = A^{-1}\end{aligned}\end{equation}$$<h2 id="收敛矩阵"><a href="#收敛矩阵" class="headerlink" title="收敛矩阵"></a>收敛矩阵</h2><p>一般矩阵序列$\{A_k\}_{k=1}^\infty \in C^{m\times n}$，即$A_1, A_2, \cdots, A_k$<br>在矩阵序列中，最常见的是由一个方阵的幂构成的序列：$$\{A_k\}_{k=1}^\infty \in C^{n\times n}$$，即$I,A,A^2,\cdots,A^k$</p><p><strong>定义3.2</strong> 设$A\in C^{n\times n}$，若$\lim\limits_{k\rightarrow \infty}A^k=0$，则称$A$为<strong>收敛矩阵</strong><br><strong>收敛定理</strong> 设$A\in C^{n\times n}$，证明$\lim\limits_{k\rightarrow \infty}A^k=0$的充要条件为$\rho(A) &lt; 1$<br>证明：</p><ul><li>必要性：$\lim\limits_{k\rightarrow \infty}A^k=0$的充要条件为对任意矩阵范数均有<br>$\lim\limits_{k\rightarrow \infty}\Vert A^k - 0 \Vert=\lim\limits_{k\rightarrow \infty}\Vert A^k \Vert=0$<br>所以对于充分大的$k$，必有$\Vert A^k \Vert &lt; 1$，根据谱半径定义以及相容矩阵范数性质可得<br>  $$(\rho(A))^k=\rho(A^k)\le \Vert A^k \Vert &lt; 1$$<br>  所以有$\rho(A)&lt;1$</li><li>充分性：根据<strong>定理2.9</strong>，令$\varepsilon = \dfrac{1}{2}(1-\rho(A))&gt;0$，一定存在一种相容的矩阵范数使$\Vert A \Vert \le \rho(A) + \varepsilon$<br>  因为$\rho(A) &lt; 1$，所以有$\rho(A) + \varepsilon = \dfrac{1}{2}(1+\rho(A)) &lt; 1$<br>  则有$\Vert A^k \Vert \le \Vert A \Vert^k \le (\rho(A) + \varepsilon)^k \le 1$<br>  所以$\lim\limits_{k\rightarrow \infty}\Vert A^k\Vert=0$</li></ul><p><strong>推论3.2</strong> 设$A \in C^{n\times n}$，若对 $C^{m\times n}$上的某种范数有$\Vert A\Vert &lt; 1$，则$\lim\limits_{k\rightarrow \infty}A^k=0$</p><h2 id="矩阵级数"><a href="#矩阵级数" class="headerlink" title="矩阵级数"></a>矩阵级数</h2><p><strong>定义3.3</strong> 设$\{A_k\}_{k=1}^\infty$为$C^{m\times n}$中的矩阵序列，称$A_1+A_2+\cdots+A_k+\cdots$为由矩阵序列$\{A_k\}_{k=1}^\infty$构成的矩阵级数，记为$\sum\limits_{k=1}^{\infty}A_k$</p><p><strong>定义3.4</strong> 记$S_k = \sum\limits_{i=1}^{k}A_i$，称之为矩阵级数$\sum\limits_{k=1}^{\infty}A_k$的前$k$项部分和。若矩阵序列$\{S_k\}_{k=1}^\infty$收敛且$\lim\limits_{k\rightarrow \infty}S_k=S$，则称矩阵级数$\sum\limits_{k=1}^{\infty}A_k$收敛，而矩阵$S$称为矩阵级数的和矩阵，记为$S=\sum\limits_{k=1}^{\infty}A_k$，不收敛的矩阵级数称为发散的<br>显然，和$\sum\limits_{k=1}^{\infty}A_k=S=(s_{ij})$的意义指的是：<br>$\sum\limits_{k=1}^{\infty}a_{ij}^{(k)}=s_{ij}$$ \quad i=1,2,\cdots,m \quad j=1,2,\cdots,n$，即$m\times n$个数项级数$\sum\limits_{k=1}^{\infty}a_{ij}^{(k)}$均为收敛的</p><p><strong>定义3.5</strong> 设$A$为$n$阶方阵，则有</p><ul><li>$\sum\limits_{k=0}^{\infty}A^k = I +A +A^2+\cdots + A^k+ \cdots$收敛的充要条件是$\rho(A)&lt;1$</li><li>当$\sum\limits_{k=0}^{\infty}A^k$收敛时，有$\sum\limits_{k=0}^{\infty}A^k=(I-A)^{-1}$<br>  而且存在$C^{n\times n}$上的算子范数$\Vert \cdot\Vert$使得<br>  $\left\Vert(I-A)^{-1} - \sum\limits_{k=0}^{m}A_k \right\Vert \le \dfrac{\Vert A\Vert^{m+1}}{1-\Vert A\Vert}$   </li></ul><p>证明：</p><ul><li><p>必要性：若矩阵级数$\sum\limits_{k=1}^{\infty}A_k$收敛，则有$S = \lim\limits_{k\rightarrow \infty}S_k$<br>  级数$I +A +A^2+\cdots + A^k+ \cdots$的前$k$项部分和与前$k+1$项部分和分别为：<br>  $$S_k = I +A +A^2+\cdots + A^{k-1}\quad S_{k+1}I +A +A^2+\cdots + A^k$$<br>  所以$A_k = S_{k+1}-S_k, \lim\limits_{k\rightarrow \infty}A_k = \lim\limits_{k\rightarrow \infty}(S_{k+1}-S_k)=0$<br>  所以$\rho(A)&lt;1$（由收敛定理得）</p></li><li><p>充分性：由$AS_k=A(I +A +A^2+\cdots + A^{k-1})$$=A+A^2+\cdots+A^k$，可得$S_k-AS_{k}=I-A^k$，即$(I-A)S_k=I-A^k$<br>  因为$\rho(A)&lt;1$，可知存在某种矩阵范数，使得$\Vert A\Vert &lt; 1$，且$(I-A)$可逆（<strong>定理1.9</strong>），又因为$\lim\limits_{k\rightarrow \infty}A^k=0$</p>  $ \begin{equation}    \begin{aligned}    \sum\limits_{k=1}^{\infty}A_k=\lim\limits_{k\rightarrow \infty}S_k&=\lim\limits_{k\rightarrow \infty}[(I-A)^{-1}(I-A^k)]\\                   &=(I-A)^{-1}\lim\limits_{k\rightarrow \infty}(I-A^k)=(I-A)^{-1}    \end{aligned}    \end{equation}$<p>  进一步根据$\sum\limits_{k=0}^{\infty}A_k=(I-A)^{-1}$有</p>  $ \begin{equation}    \begin{aligned}    \left\Vert (I-A)^{-1} -  \sum\limits_{k=0}^{m}A^k\right\Vert = \left\Vert \sum\limits_{k=m+1}^{\infty}A^k\right\Vert \\ \le \sum\limits_{k=m+1}^{\infty}\Vert A\Vert^k = \dfrac{\Vert A\Vert^{m+1}(1 - \lim\limits_{k \rightarrow \infty}A^k)}{1-\Vert A\Vert}=\dfrac{\Vert A\Vert^{m+1}}{1-\Vert A\Vert}    \end{aligned}    \end{equation}$</li></ul><p><strong>性质3.4</strong> 设$\sum\limits_{k=1}^{\infty}A_k =A$和$\sum\limits_{k=1}^{\infty}B_k =B$，其中$A_k,A,B_k,B\in C^{m\times n}$，则<br>$\sum\limits_{k=1}^{\infty}(\alpha A_k + \beta B_k) = \alpha \sum\limits_{k=1}^{\infty}A_k + \beta \sum\limits_{k=1}^{\infty}B_k, \forall \alpha,\beta \in C$<br>证明：<br>因为$S_N=\sum\limits_{k=1}^{N}(\alpha A_k + \beta B_k) = \alpha \sum\limits_{k=1}^{N}A_k + \beta \sum\limits_{k=1}^{N}B_k, \forall \alpha,\beta \in C$<br>所以<br>$\sum\limits_{k=1}^{\infty}(\alpha A_k + \beta B_k) = \lim\limits_{N\rightarrow \infty}S_N= \alpha \lim\limits_{N\rightarrow \infty} \sum\limits_{k=1}^{N}A_k+\beta \lim\limits_{N\rightarrow \infty}\sum\limits_{k=1}^{N}B_k = \alpha A +\beta B$</p><h2 id="矩阵级数绝对收敛定义及性质"><a href="#矩阵级数绝对收敛定义及性质" class="headerlink" title="矩阵级数绝对收敛定义及性质"></a>矩阵级数绝对收敛定义及性质</h2><p><strong>定义3.6</strong> 设$\sum\limits_{k=1}^\infty A_k$为$C^{m\times n}$ 中的矩阵级数，其中$A_k = (a_{ij}^{(k)})$。如果$\sum\limits_{k=1}^\infty  (a_{ij}^{(k)})$对于仍以的$1 \le i \le m, 1 \le j \le n$均为绝对收敛，则称矩阵级数$\sum\limits_{k=1}^\infty A_k$绝对收敛</p><p><strong>性质3.5</strong> 若矩阵级数$\sum\limits_{k=1}^\infty A_k$是绝对收敛的，则它一定是收敛的，并且任意调换各项的顺序所得到的级数还是收敛的，且级数和不变</p><p><strong>性质3.6</strong> 若矩阵级数$\sum\limits_{k=1}^\infty A_k$为绝对收敛的充要条件是正项级数$\sum\limits_{k=1}^\infty \Vert A_k\Vert $收敛<br>证明：</p><ul><li>必要性：如果$\sum\limits_{k=1}^\infty A_k$绝对收敛，根据定义有对任意$1 \le i \le m, 1 \le j \le n$  $\sum\limits_{k=1}^\infty (a_{ij}^{(k)})$ 均绝对收敛，即存在充分大的$N$和与$N$无关的正数$M$，使得<br>$$\sum\limits_{k=1}^N |(a_{ij}^{(k)})| &lt; M ,(i=1,2,\cdots,m\quad j=1,2,\cdots,n)$$<br>从而有$\sum\limits_{k=1}^N\Vert A_k\Vert_\infty = \sum\limits_{k=1}^N\left( \max\limits_i\sum\limits_{j=1}^n |(a_{ij}^{(k)})|  \right) = \max\limits_i \left\{ \sum\limits_{j=1}^n \sum\limits_{k=1}^N |(a_{ij}^{(k)})|  \right\} $$\le \sum\limits_{i=1}^m\sum\limits_{j=1}^n\sum\limits_{k=1}^N |(a_{ij}^{(k)})| &lt; n\cdot m\cdot M$<br>因此$\sum\limits_{k=1}^N\Vert A_k\Vert_\infty$为收敛的正项级数</li><li>充分性：如果$\sum\limits_{k=1}^N\Vert A_k\Vert_\infty$为收敛的正项级数，那么有<br>$\sum\limits_{k=1}^N|(a_{ij}^{(k)})| \le \sum\limits_{k=1}^N\left( \max\limits_i\sum\limits_{j=1}^n |(a_{ij}^{(k)})| \right) = \sum\limits_{k=1}^N\Vert A_k \Vert_\infty &lt; M$<br>$i=1,2,\cdots,m\quad j=1,2,\cdots,n$<br>可知$m \times n$个级数$\sum\limits_{k=1}^\infty a_{ij}^{(k)}$均为绝对收敛的，根据<strong>定义3.4</strong>可知矩阵级数$\sum\limits_{k=1}^\infty A_k$绝对收敛</li></ul><p><strong>性质3.7</strong> 设$\sum\limits_{k=1}^\infty A_k$为$C^{m\times n}$中的绝对收敛的矩阵级数，$\sum\limits_{k=1}^\infty B_k$为$C^{n\times l}$中的绝对收敛的级数，并且$A=\sum\limits_{k=1}^\infty A_k,B=\sum\limits_{k=1}^\infty B_k$，则$\sum\limits_{k=1}^\infty A_k$ $\sum\limits_{k=1}^\infty B_k$ 按任何方式排列得到的级数也绝对收敛，且和为$AB$</p><p><strong>性质3.8</strong> 设$P\in C^{p\times m}$和$P\in C^{n\times q}$为给定<strong>常数矩阵</strong>，如果$m\times n$型矩阵级数$\sum\limits_{k=0}^\infty A_k$ 收敛（或绝对收敛），则$p\times q$型矩阵级数$\sum\limits_{k=0}^\infty PA_kQ$也收敛（或绝对收敛），且有<br>$$\sum\limits_{k=0}^\infty PA_kQ = P\left( \sum\limits_{k=0}^\infty A_k \right)Q$$<br>证明：设$\sum\limits_{k=0}^\infty A_k$ 收敛于矩阵$S$，即$S=\sum\limits_{k=0}^\infty A_k = \lim\limits_{n \rightarrow \infty}\sum\limits_{k=0}^n A_k$，而由等式$\sum\limits_{k=0}^n PA_kQ=P\left( \sum\limits_{k=0}^n A_k \right)Q$<br>取极限有：$\sum\limits_{k=0}^\infty PA_kQ = P\left( \lim\limits_{n \rightarrow \infty}\sum\limits_{k=0}^n A_k \right)Q = PSQ = P\sum\limits_{k=0}^\infty A_kQ$<br>即$\sum\limits_{k=0}^\infty PA_kQ$收敛，且有$\sum\limits_{k=0}^\infty PA_kQ = P\left( \sum\limits_{k=0}^\infty A_k \right)Q$</p><h2 id="矩阵幂级数"><a href="#矩阵幂级数" class="headerlink" title="矩阵幂级数"></a>矩阵幂级数</h2><p><strong>收敛半径</strong><br>对于幂级数$\sum\limits_{n=0}^\infty a_nx^n$，$\rho=\lim\limits_{n \rightarrow \infty}\dfrac{|a_{n+1}|}{|a_n|}$，$r= \dfrac{1}{\rho}$<br>且有，当$\rho=0,r=+\infty$，处处收敛，当$\rho=+\infty,r=0$，仅在$x=0$处收敛</p><p><strong>定理3.2</strong> 设$\sum\limits_{k=0}^\infty a_kt^k$为收敛半径为$r$的幂级数，$A$为$n$阶方阵，则</p><ul><li>$\rho(A) &lt; r$时，矩阵幂级数$\sum\limits_{k=0}^\infty a_kA^k$绝对收敛<br>证明：$\rho(A) &lt; r$时，取$\varepsilon = \dfrac{1}{2}[r - \rho(A)] &gt; 0$<br>  一定存在一种相容的矩阵范数，使得$\Vert A\Vert \le \rho(A) + \varepsilon = \dfrac{r + \rho(A)}{2} &lt; r$<br>  所以数项级数$\sum\limits_{k=0}^\infty \Vert a_kA^k \Vert$收敛，再根据数项级数比较判别法可得<br>  $\sum\limits_{k=0}^\infty \Vert a_kA^k \Vert = \sum\limits_{k=0}^\infty |a_k|\Vert A^k \Vert \le \sum\limits_{k=0}^\infty |a_k|\Vert A \Vert^k=\sum\limits_{k=0}^\infty |a_k\Vert A \Vert^k|$收敛<br>  从而有$\sum\limits_{k=0}^\infty a_kA^k$绝对收敛</li><li>$\rho(A) &gt; r$时，矩阵幂级数$\sum\limits_{k=0}^\infty a_kA^k$发散<br>反证法证明：设$Ax=\lambda_i x$，其中$|\lambda_i|=\rho(A)$，且设$x$为其单位长度特征向量，即$x^HAx=\lambda_i$<br>  如果它收敛，根据<strong>性质3.8</strong>可得<br>  $\sum\limits_{k=0}^\infty a_k\lambda_i^k=\sum\limits_{k=0}^\infty a_k(x^HA^kx)=x^H\left(\sum\limits_{k=0}^\infty a_kA^k\right)x = x^HSx &lt; \infty$<br>  即此数项级数收敛，但$|\lambda_i|=\rho(A)&gt;r$，数项级数$\sum\limits_{k=0}^\infty a_k\lambda_i^k$在收敛圆外发散，所以矛盾</li></ul><p><strong>推论3.3</strong> 从零点推广到任意点，设$\sum\limits_{k=0}^\infty a_k(z-z_0)^k$为收敛半径为$r$的幂级数，$A$为$n$阶方阵，如果$A$的特征值均落在收敛圆内，即$|\lambda-z_0| &lt; r$，其中$\lambda$为任意特征值，则矩阵幂级数$\sum\limits_{k=0}^\infty a_k(A-z_0I)^k$绝对收敛；若存在某个$\lambda_{i_0}$使得$|\lambda-z_0| &gt; r$，则幂级数$\sum\limits_{k=0}^\infty a_k(A-z_0I)^k$发散</p><h2 id="矩阵函数定义及其相关引理"><a href="#矩阵函数定义及其相关引理" class="headerlink" title="矩阵函数定义及其相关引理"></a>矩阵函数定义及其相关引理</h2><p>根据幂级数性质，幂级数的和函数是收敛圆内的解析函数（任意次可微，在任一点处均可展成$Taylor$级数），而一个圆内解析的函数可以展开成收敛的幂级数。于是，如果$f(z)$是$|z-z_0|&lt;r$内的解析函数，其展成绝对收敛的幂级数为<br>$$f(z)=\sum\limits_{k=0}^\infty a_k(z-z_0)^k$$<br>则当矩阵$A\in C^{n \times n}$的特征值落在收敛圆$|z-z_0|&lt;r$内时，则有<br>$$f(A)\triangleq\sum\limits_{k=0}^\infty a_k(A-z_0I)^k$$<br>称之为$A$关于解析函数$f(z)$的矩阵函数</p><p><strong>引理3.1</strong> 设$f(z)=\sum\limits_{k=1}^\infty a_kz^k$是收敛半径为$r$的幂级数，$J_i$是特征值为$\lambda_i$的$n_i$阶$Jordan$块，且$|\lambda_i|&lt;r$，则有</p>$$\begin{equation}\begin{aligned}f(J_i)=\begin{bmatrix}f(\lambda_i)&f'(\lambda_i)&\cdots&\dfrac{f^{(n_i-1)}(\lambda_i)}{(n_i-1)!}\\&f(\lambda_i)&\ddots&\vdots\\&&\ddots&f'(\lambda_i)\\&&&f(\lambda_i)\end{bmatrix}\end{aligned}\end{equation}$$<p>证明：<br>因为$\rho(J_i)=|\lambda_{max}|&lt;r$，根据<strong>定理3.2</strong>，矩阵级数$\sum\limits_{k=0}^\infty a_kJ_i^k$绝对收敛，记其和函数为$f(J_i)$<br>考虑到其前$m+1$项部分和$S_{m+1}=\sum\limits_{k=0}^\infty a_kJ_i^k$，<br>且有$f(J_i)=\lim\limits_{m \rightarrow \infty}S_{m+1}=\sum\limits_{k=0}^\infty a_kJ_i^k$<br>因为$J_i=\lambda_iI+N，N^0=I$，针对$N_{n_i \times n_i}$有如下特性<br>$N^j = [0,\cdots, e_1,\cdots,e_{n-j} ] \quad 1\le j \le n_i-1 \quad or\quad  N^j=0 \quad j \ge n_i$<br>注意有：$(\lambda_iI_{n_i})N=N(\lambda_iI_{n_i})$<br>因此有<br>$J_i^k=(\lambda_i I+N)=\sum\limits_{k=0}^k C_k^j\lambda_i^{k-j}N^j = \lambda_i^k I + C_k^1 \lambda_i^{k-1}N + \cdots + C_k^j \lambda_i^{k-j}N^j+ \cdots$</p>$j \le min\{ k,n_i-1 \}$<p>进一步有</p>$$\begin{equation}\begin{aligned}S_{m+1}=\sum\limits_{k=0}^m a_kJ_i^k=\begin{bmatrix}\sum\limits_{k=0}^m a_k\lambda_i^k&\sum\limits_{k=1}^m a_kC_k^1\lambda_i^{k-1}&\cdots&\sum\limits_{k=n_i-1}^m a_kC_k^{n_i-1}\lambda_i^{k-n_i+1}\\&\sum\limits_{k=0}^m a_k\lambda_i^k&\ddots&\vdots\\&&\ddots&\sum\limits_{k=1}^m a_kC_k^1\lambda_i^{k-1}\\&&&\sum\limits_{k=0}^m a_k\lambda_i^k\end{bmatrix}\end{aligned}\end{equation}$$<p>注意到<br>$\sum\limits_{k=j}^m a_kC_k^j\lambda_i^{k-j}=\dfrac{1}{j!}\sum\limits_{k=j}^m a_kk(k-1)\cdots(k-j+1)\lambda_i^{k-j}$<br>$=\dfrac{1}{j!}\sum\limits_{k=j}^m a_k(\lambda_i^k)^{(j)}=\dfrac{S_{m+1}^{(j)}(\lambda_i)}{j!}$</p><p>所以有</p>$$\begin{equation}\begin{aligned}f(J_i)=\lim\limits_{m \rightarrow \infty}S_{m+1}=\begin{bmatrix}\lim\limits_{m \rightarrow \infty}S_{m+1}(\lambda_i)&\lim\limits_{m \rightarrow \infty}S_{m+1}'(\lambda_i)&\cdots&\lim\limits_{m \rightarrow \infty}\dfrac{S_{m+1}^{(n_i-1)}(\lambda_i)}{(n_i-1)!}\\&\lim\limits_{m \rightarrow \infty}S_{m+1}(\lambda_i)&\ddots&\vdots\\&&\ddots&\lim\limits_{m \rightarrow \infty}S_{m+1}'(\lambda_i)\\&&&\lim\limits_{m \rightarrow \infty}S_{m+1}(\lambda_i)\end{bmatrix}\end{aligned}\end{equation}$$<p>根据幂级数定义$f(\lambda_i)=\lim\limits_{m \rightarrow \infty}\sum\limits_{k=0}^m a_k\lambda_i^k=S_{m+1}(\lambda_i)$，故可证</p><p><strong>推论3.4</strong> 将从零点展开扩展到任意点， 设$f(z)=\sum\limits_{k=1}^\infty a_k(z-z_0)^k$是收敛半径为$r$的幂级数，$J_i$是特征值为$\lambda_i$的$Jordan$块，且$|\lambda_i-z_0|&lt;r$，则有</p>$$\begin{equation}\begin{aligned}f(J_i)=\begin{bmatrix}f(\lambda_i)&f'(\lambda_i)&\cdots&\dfrac{f^{(n_i-1)}(\lambda_i)}{(n_i-1)!}\\&f(\lambda_i)&\ddots&\vdots\\&&\ddots&f'(\lambda_i)\\&&&f(\lambda_i)\end{bmatrix}\end{aligned}\end{equation}$$<p>可知，$f(J_i)$与在哪点展开无关</p><h2 id="计算矩阵函数f-tJ-的引理"><a href="#计算矩阵函数f-tJ-的引理" class="headerlink" title="计算矩阵函数f(tJ)的引理"></a>计算矩阵函数f(tJ)的引理</h2><p><strong>推论3.5</strong> 设$f(z)=\sum\limits_{k=1}^\infty a_kz^k$是收敛半径为$r$的幂级数，$J_i$是特征值为$\lambda_i$的$Jordan$块，且$|t\lambda_i|&lt;r$，则有</p>$$\begin{equation}\begin{aligned}f(tJ_i)=\begin{bmatrix}f(t\lambda_i)&tf'(t\lambda_i)&\cdots&\dfrac{t^{n_i-1}f^{(n_i-1)}(t\lambda_i)}{(n_i-1)!}\\&f(t\lambda_i)&\ddots&\vdots\\&&\ddots&tf'(t\lambda_i)\\&&&f(t\lambda_i)\end{bmatrix}\end{aligned}\end{equation}$$<p>证明方法同上，只需注意<br>$\sum\limits_{k=n_i-1}^m a_kC_k^{n_i-1}\lambda_i^{k-n_i+1} = t^{n_i-1}\sum\limits_{k=n_i-1}^m a_kC_k^{n_i-1}(t\lambda_i)^{k-n_i+1}$</p><h2 id="矩阵函数的计算"><a href="#矩阵函数的计算" class="headerlink" title="矩阵函数的计算"></a>矩阵函数的计算</h2><p><strong>定理3.3</strong> 设$f(z)=\sum\limits_{k=0}^\infty a_kz^k$是收敛半径为$r$的幂级数，$A$为$n$阶方阵，$A=TJT^{-1}$为其$Jordan$分解，$J=diag(J_,J_2,\cdots,J_s)$。当$A$的特征值均落在收敛圆内时，即$|\lambda| &lt;r$，其中$\lambda$为$A$的任意特征值，则矩阵幂级数$\sum\limits_{k=0}^\infty a_kA^k$绝对收敛，且和矩阵为<br>$$f(A)=Tdiag(f(J_1),f(J_2),\cdots,f(J_s))T^{-1}$$</p><p>注意有，若$A$的特征值为$\lambda_1,\lambda_2,\cdots,\lambda_n$，则$f(A)$的特征值应为$f(\lambda_1),f(\lambda_2),\cdots,f(\lambda_n)$</p><p>证明：</p>$$\begin{equation}\begin{aligned}f(A)&=\sum\limits_{k=0}^\infty a_kA^k =  \sum\limits_{k=0}^\infty a_k(TJT^{-1})^k = \sum\limits_{k=0}^\infty a_k(TJ^kT^{-1}) \\&=T\left(\sum\limits_{k=0}^\infty a_kJ^k\right)T^{-1}=T diag\left(\sum\limits_{k=0}^\infty a_kJ_1^k,\sum\limits_{k=0}^\infty a_kJ_2^k,\cdots,\sum\limits_{k=0}^\infty a_kJ_s^k  \right) \\&=T diag(f(J_1),f(J_2),\cdots,f(J_s))T^{-1}\end{aligned}\end{equation}$$<p>同时易证$f(tA)=T diag(f(tJ_1),f(tJ_2),\cdots,f(tJ_s))T^{-1}$</p><h2 id="计算矩阵函数的有限待定系数法"><a href="#计算矩阵函数的有限待定系数法" class="headerlink" title="计算矩阵函数的有限待定系数法"></a>计算矩阵函数的有限待定系数法</h2><p>利用<strong>$Hamilton-Caylay$定理</strong><br>设$A\in C^{n \times n}$，且<br>$\psi(\lambda)=det(\lambda I -A)=(\lambda-\lambda_1)^{m_1}(\lambda-\lambda_2)^{m_2}\cdots(\lambda-\lambda_s)^{m_s}$<br>其中$m_i(i=1,2,\cdots,s)均为正整数$，$\sum\limits_{k=1}^\infty m_i = n\quad \lambda_1,\lambda_2,\cdots,\lambda_s$为$A$的不同特征值<br>为计算矩阵函数$f(tA)=\sum\limits_{k=0}^\infty a_kt^kA^k$，记$f(t\lambda)=\sum\limits_{k=0}^\infty a_kt^k\lambda^k$，并改写为$f(t\lambda)=p(\lambda,t)\psi(\lambda)+q(\lambda,t)$<br>其中$p(\lambda,t)$是含参数$t$的$\lambda$的幂级数，$q(\lambda,t)$是含参数$t$且次数不超过$n-1$的$\lambda$的多项式，即<br>$q(\lambda,t)=b_{n-1}(t)\lambda^{n-1}+b_{n-2}(t)\lambda^{n-2}+\cdots+b_0(t)$<br>又根据$Hamilton-Caylay$定理有，$\psi(A)=0$，所以有$f(tA)=q(A,t)$<br>以及$\psi^{(j)}(\lambda_i) = 0 \quad(j=0,1,\cdots,m_i-1;i=1,2,\cdots,s)$<br>所以根据$f(t\lambda)=q(\lambda,t)$分别进行$1,2,\cdots,n-1$次求导，<br>解出$b_0(t),b_1(t),\cdots.b_{n-1}(t)$即可求解</p><p>一些规律</p><ul><li>$\forall A \in C^{n \times n}$，总有<ol><li>$sin(-A)=-sin(A),cos(-A)=cos(A)$</li><li>$e^{iA}=cosA+isinA,cosA=\dfrac{1}{2}(e^{iA}+e^{-iA}),sinA=\dfrac{1}{2}(e^{iA}-e^{-iA})$</li></ol></li><li>$A,B\in C^{n\times n}$，且$AB=BA$，则<ol><li>$e^{A+B}=e^Ae^B=e^Be^A$</li><li>$sin(A+B)=sinAcosB+cosAsinB$</li><li>$cos(A+B)=cosAcosB-sinAsinB$</li></ol></li><li>$A\in C^{n\times n}$<ol><li>$cos2A=cos^2A-sin^2A$</li><li>$sin2A=2sinAcosA$</li></ol></li><li>其他<ol><li>$det(e^A)=e^{trA}$<br> 证明：根据$f(A)$的特征值为$f(\lambda_i)$可得<br> $det(e^A)=e^{\lambda_1}e^{\lambda_2}\cdots e^{\lambda_n}=e^{\lambda_1+\lambda_2+\cdots+\lambda_n}=e^{trA}$</li><li>$(e^A)^{-1}=e^{-A}$<br> 证明：由于$det(e^A)=e^{trA}\not=0$，所以$e^A$总是可逆的，所以有<br> $e^Ae^{-A}=I \Rightarrow (e^A)^{-1}=e^{-A}$</li><li>$\Vert e^A\Vert \le e^{\Vert A\Vert}$<br> 证明：$\Vert S_N\Vert = \Vert \sum\limits_{k=0}^N\dfrac{1}{k!}A^k \Vert\le \sum\limits_{k=0}^N\dfrac{1}{k!}\Vert A\Vert^k $<br> 当$N\rightarrow \infty$时，有$\Vert e^A \Vert \le e^{\Vert A \Vert}$</li><li>若$A$为$Hermite$阵，则$e^{iA}$为酉矩阵<br> 证明：因为$f(A^T)=f(A)^T$，所以<br> $(e^{iA})^H=e^{(iA)^{H}}=e^{-iA^H}=e^{-iA}$<br> $(e^{iA})^He^{iA}=I$<br> 所以$e^{iA}$为酉阵</li></ol></li></ul><h2 id="相对于数量变量的微分与积分"><a href="#相对于数量变量的微分与积分" class="headerlink" title="相对于数量变量的微分与积分"></a>相对于数量变量的微分与积分</h2><p><strong>定义3.7</strong> 如果矩阵$A(t)={(a_{ij}(t))}_{m\times n}$的每一个元素<br>$a_{ij}(t)\quad i=1,2,\cdots,m;j=1,2,\cdots,n$在$[a,b]$上均为变量$t$的可微函数，则称$A(t)$可微，且导数定义为<br>$$A’(t)=\dfrac{\mathrm{d} }{\mathrm{d} t}A(t)=\left( \dfrac{\mathrm{d} }{\mathrm{d} t} a_{ij}(t) \right)_{m\times n}$$</p><p><strong>定理3.4</strong><br>设$A(t),B(t)$是可进行运算的两个可微矩阵，则以下的运算规则成立</p><ul><li>$\dfrac{\mathrm{d} }{\mathrm{d} t}(A(t)+B(t))=\dfrac{\mathrm{d} }{\mathrm{d} t}A(t)+\dfrac{\mathrm{d} }{\mathrm{d} t}B(t)$</li><li>$\dfrac{\mathrm{d} }{\mathrm{d} t}(A(t)B(t))=\left(\dfrac{\mathrm{d} }{\mathrm{d} t}A(t) \right)B(t)+A(t)\left(\dfrac{\mathrm{d} }{\mathrm{d} t}B(t) \right)$</li><li>$\dfrac{\mathrm{d} }{\mathrm{d} t}(\alpha A(t))=\alpha \cdot \dfrac{\mathrm{d} }{\mathrm{d} t}A(t)$，其中$\alpha$为任意常数</li><li>当$u=f(t)$关于$t$可微时，有$\dfrac{\mathrm{d} }{\mathrm{d} t}(A(u))=f’(t)\dfrac{\mathrm{d} }{\mathrm{d} u}A(u)$</li><li>当$A^{-1}(t)$为可微矩阵时，有$\dfrac{\mathrm{d} }{\mathrm{d} t}(A^{-1}(t))=-A^{-1}(t)\left( \dfrac{\mathrm{d} }{\mathrm{d} t}A(t) \right)A^{-1}(t)$</li></ul><p>由于$\dfrac{\mathrm{d} }{\mathrm{d} t}A(t)$仍是矩阵函数，如果它仍是可导函数矩阵，则可定义其高阶导数<br>$$\dfrac{\mathrm{d}^k }{\mathrm{d} t^k}A(t)=\dfrac{\mathrm{d} }{\mathrm{d} t}\left( \dfrac{\mathrm{d}^{k-1} }{\mathrm{d} t^{k-1}} A(t) \right)$$</p><p><strong>定理3.5</strong><br>设$n$阶方阵$A$与$t$无关，则有</p><ul><li>$\dfrac{\mathrm{d} }{\mathrm{d} t}e^{tA}=Ae^{tA}=e^{tA}A$</li><li>$\dfrac{\mathrm{d} }{\mathrm{d} t}sin(tA)=Acos(tA)=cos(tA)A$</li><li>$\dfrac{\mathrm{d} }{\mathrm{d} t}cos(tA)=-Asin(tA)=-sin(tA)A$</li></ul><p><strong>定义3.8</strong> 如果矩阵$A(t)=(a_{ij}(t))_{m\times n}$的每一个元素$a_{ij}(t)$都是区间$[t_0,t_1]$上的可积函数，则定义$A(t)$在区间$[t_0,t_1]$上的积分为<br>$$\int_{t_0}^{t_1}A(t)dt = \left(\int_{t_0}^{t_1}a_{ij}(t)dt\right)_{m\times n}$$</p><p>具有如下运算法则：</p><ul><li>$\int_{t_0}^{t_1} (\alpha A(t)+\beta B(t))dt = \alpha\int_{t_0}^{t_1}A(t)dt + \beta\int_{t_0}^{t_1}B(t)dt \quad \forall \alpha,\beta \in C$</li><li>$\int_{t_0}^{t_1}(A(t)B)=\int_{t_0}^{t_1}A(t)dt\cdot B\quad$其中$B$为常数矩阵</li><li>$\int_{t_0}^{t_1}(AB(t))=A\cdot\int_{t_0}^{t_1}B(t)dt\cdot \quad$其中$A$为常数矩阵</li><li>当$A(t)$在$[a,b]$上连续可微时，对任意$t\in (a,b)$，有<br>  $$\dfrac{\mathrm{d} }{\mathrm{d} t}\left( \int_{a}^{t} A(t)dt \right) = A(t) $$</li><li>当$A(t)$在$[a,b]$上连续可微时，对任意$t\in (a,b)$，有<br>  $$ \int_{a}^{b} \dfrac{\mathrm{d} }{\mathrm{d} t}A(t)dt = A(b) -A(a) $$</li></ul><h2 id="相对于矩阵变量的微分"><a href="#相对于矩阵变量的微分" class="headerlink" title="相对于矩阵变量的微分"></a>相对于矩阵变量的微分</h2><p><strong>定义3.9</strong>设$X=(x_{ij})_{m \times n}$，函数$f(X)=f(x_{11},x_{12},\cdots,x_{1n},x_{21},\cdots,x_{mn})$为$mn$元的多元函数，且$\dfrac{\partial f}{\partial x_{ij}}\quad (i=1,2,\cdots,m;j=1,2,\cdots,n)$都存在，定义$f(X)$对矩阵$X$的导数为：</p>$$\begin{equation}\begin{aligned}\dfrac{\partial f(X)}{\partial X}=\left( \dfrac{\partial f}{\partial x_{ij}} \right)_{m\times n}=  \begin{bmatrix}\dfrac{\partial f}{\partial x_{11}}&\cdots&\dfrac{\partial f}{\partial x_{1n}}\\\vdots&\ddots&\vdots\\\dfrac{\partial f}{\partial x_{m1}}&\cdots&\dfrac{\partial f}{\partial x_{mn}}\end{bmatrix}\end{aligned}\end{equation}$$  <p>设$x=(\xi_1,\xi_2,\cdots,\xi_n)^T$，$n$元函数$f(x)=f(\xi_1,\xi_2,\cdots,\xi_n)$</p><ul><li>$\dfrac{\mathrm{d}f }{\mathrm{d} x^T}=\left( \dfrac{\partial f}{\partial \xi_1},\dfrac{\partial f}{\partial \xi_2},\cdots,\dfrac{\partial f}{\partial \xi_n} \right)$</li><li>$\triangledown f(x)=\dfrac{\mathrm{d}f }{\mathrm{d} x}= \left( \dfrac{\partial f}{\partial \xi_1},\dfrac{\partial f}{\partial \xi_2},\cdots,\dfrac{\partial f}{\partial \xi_n} \right)^T$<br>  称为数量函数对向量变量的导数，即为梯度向量，也记为$gradf$</li></ul><p>设$a=(a_1,a_2,\cdots,a_n)^T$为常向量，$x=(\xi_1,\xi_2,\cdots,\xi_n)^T$为向量变量，<br>且$f(x)=(x,a)=a^Tx=x^Ta$<br>则$\dfrac{\mathrm{d}f }{\mathrm{d} x} = a$<br>因为$f(x)=\sum\limits_{i=1}^n a_i\xi_i,\dfrac{\partial f}{\partial x_{j}}=a_j\quad j=1,2,\cdots,n$</p><p>设$x=(\xi_1,\xi_2,\cdots,\xi_n)^T,A=(a_{ij})_{n\times n}$，$n$元函数$f(x)=x^TAx$<br>$\dfrac{\mathrm{d}f }{\mathrm{d} x}=(A+A^T)x$<br>因为</p>$f(x)=\sum\limits_{i=1}^n\sum\limits_{j=1}^n a_{ij}\xi_i\xi_j=\xi_1\sum\limits_{j=1}^n a_{1j}\xi_j+ \cdots+\xi_k\sum\limits_{j=1}^n a_{kj}\xi_j+\cdots+\xi_n\sum\limits_{j=1}^n a_{nj}\xi_j$<p>所以<br>$\dfrac{\partial f(x)}{\partial \xi_{k}}=\xi_1a_{1k}+ \cdots + \xi_{k-1}a_{(k-1)k}+\left( \sum\limits_{j=1}^n a_{kj}\xi_j + \xi_k a_{kk} \right) + \xi_{k+1}a_{(k+1)k} + \cdots + \xi_na_{nk}$<br>$\qquad\qquad=\sum\limits_{j=1}^n a_{kj}\xi_j + \sum\limits_{i=1}^n a_{ik}\xi_i \quad k=1,2,\cdots,n$<br>故有</p>$$\begin{equation}\begin{aligned}\dfrac{\mathrm{d}f }{\mathrm{d} x}=\begin{bmatrix}\dfrac{\partial f(x)}{\partial \xi_{1}}\\\dfrac{\partial f(x)}{\partial \xi_{2}}\\\vdots \\\dfrac{\partial f(x)}{\partial \xi_{n}}\end{bmatrix}=\begin{bmatrix}\sum\limits_{j=1}^n a_{1j}\xi_j\\\sum\limits_{j=1}^n a_{2j}\xi_j\\\vdots \\\sum\limits_{j=1}^n a_{nj}\xi_j\end{bmatrix}+\begin{bmatrix}\sum\limits_{i=1}^n a_{i1}\xi_i\\\sum\limits_{i=1}^n a_{i2}\xi_i\\\vdots \\\sum\limits_{i=1}^n a_{in}\xi_i\end{bmatrix}=Ax+A^Tx\end{aligned}\end{equation}$$<p>特别的，当$A$为对称矩阵时，$\dfrac{\mathrm{d}f }{\mathrm{d} x}=2Ax$</p><h2 id="矩阵在微分方程中的应用"><a href="#矩阵在微分方程中的应用" class="headerlink" title="矩阵在微分方程中的应用"></a>矩阵在微分方程中的应用</h2><p><strong>一阶线性常系数齐次微分方程组</strong></p>$\begin{equation}\begin{aligned}\begin{cases}\dfrac{\mathrm{d} x_1(t)}{\mathrm{d} t}=a_{11}x_1(t)+a_{12}x_2(t)+\cdots+a_{1n}x_n(t) \\\dfrac{\mathrm{d} x_2(t)}{\mathrm{d} t}=a_{21}x_1(t)+a_{22}x_2(t)+\cdots+a_{2n}x_n(t) \\\qquad \vdots \\ \dfrac{\mathrm{d} x_n(t)}{\mathrm{d} t}=a_{n1}x_1(t)+a_{n2}x_2(t)+\cdots+a_{nn}x_n(t) \end{cases}\end{aligned}\end{equation}$<p>给定初始条件：$x_i(0)\quad i=1,2,\cdots,n$，记$A=(a_{ij})\in C^{n\times n}$<br>$X(0)=(x_1(0),x_2(0),\cdots,x_n(0))^T$<br>则上述微分方程可写成</p>$\begin{equation}\begin{aligned}\begin{cases}\dfrac{\mathrm{d} X(t)}{\mathrm{d} t}=AX(t) \\X(0)=(x_1(0),x_2(0),\cdots,x_n(0))^T \end{cases}\end{aligned}\end{equation}$<p>根据矩阵微分性质有</p>$\begin{equation}\begin{aligned}\dfrac{\mathrm{d} (e^{-At}X(t))}{\mathrm{d} t}&=\dfrac{\mathrm{d} e^{-At}}{\mathrm{d} t}X(t)+e^{-At}\dfrac{\mathrm{d}X(t) }{\mathrm{d} t}\\&=-e^{-At}AX(t)+e^{-At}\dfrac{\mathrm{d}X(t) }{\mathrm{d} t} \\&=e^{-At}\left( \dfrac{\mathrm{d}X(t) }{\mathrm{d} t}-AX(t) \right)=0\end{aligned}\end{equation}$<p>所以$e^{-At}X(t)=C,X(t)=e^{At}C$，又因为$X(0)=C$，所以$X(t)=e^{At}X(0)$</p><p><strong>定理3.6</strong> 一阶线性常系数齐次微分方程组的定解问题</p>$$\begin{equation}\begin{aligned}\begin{cases}\dfrac{\mathrm{d} X(t)}{\mathrm{d} t}=AX(t) \\X(0)=(x_1(0),x_2(0),\cdots,x_n(0))^T \end{cases}\end{aligned}\end{equation}$$<p>有唯一解$X(t)=e^{At}X(0)$</p><p><strong>一阶线性常系数非齐次微分方程组</strong></p>$\begin{equation}\begin{aligned}\begin{cases}\dfrac{\mathrm{d} X(t)}{\mathrm{d} t}=AX(t) +F(t)\\X(0)=(x_1(0),x_2(0),\cdots,x_n(0))^T \end{cases}\end{aligned}\end{equation}$<p>其中$F(t)=(f_1(t),f_2(t),\cdots,f_n(t),)^T$是已知向量函数<br>根据一阶线性常系数齐次微分方程组性质，可得<br>$\dfrac{\mathrm{d} (e^{-At}X(t))}{\mathrm{d} t}=e^{-At}F(t)$<br>对此方程在$[t_0,t]$上进行积分，得<br>$e^{-At}X(t)-e^{-At_0}X(t_0)=\int_{t_0}^t e^{-A\tau}F(\tau)d\tau$<br>$X(t)=e^{A(t-t_0)}X(t_0)+\int_{t_0}^t e^A{t-\tau}F(\tau)d\tau$</p><h1 id="逐次迭代法"><a href="#逐次迭代法" class="headerlink" title="逐次迭代法"></a>逐次迭代法</h1><h2 id="简单迭代法"><a href="#简单迭代法" class="headerlink" title="简单迭代法"></a>简单迭代法</h2><p>将$Ax=b$变形为$x=Bx+f$，其中$B\in R^{n\times n},f\in R^n,x\in R^n$，拥有同样的解，称$B$矩阵为迭代矩阵<br>迭代法一般形式为：$x^{(k+1)}=Bx^{(k)}+f\quad (k=0,1,2,\cdots)$<br>如果对任意$x^{(0)}$，都有当$k\rightarrow \infty$时，$x^{(k)}\rightarrow x^{*}$，其中$x^{(k)}=(x_1^{(k)},x_2^{(k)},\cdots,x_n^{(k)})^T,x^{*}=(x_1^{*},x_2^{*},\cdots,x_n^{*})^T$<br>即$\lim\limits_{k \rightarrow \infty}x_i^{(k)}=x_i^{*}\quad i=1,2,\cdots,n$<br>称该迭代法收敛，否则称迭代法发散<br>由于$\lim\limits_{k \rightarrow \infty}x^{(k+1)}=B\lim\limits_{k \rightarrow \infty}x^{(k)}+f$，所以收敛迭代法的极限向量$x^*$满足$x^*=Bx^*+f$</p><h2 id="Jacobi迭代和G-S迭代格式"><a href="#Jacobi迭代和G-S迭代格式" class="headerlink" title="Jacobi迭代和G-S迭代格式"></a>Jacobi迭代和G-S迭代格式</h2><p>线性方程组的一般形式</p>$$\begin{equation}\begin{aligned}\begin{cases}a_{11}x_1+a_{12}x_2+\cdots +a_{1n}x_n=b_1\\a_{21}x_1+a_{22}x_2+\cdots +a_{2n}x_n=b_2\\\qquad\qquad \vdots\\a_{n1}x_1+a_{n2}x_2+\cdots +a_{nn}x_n=b_n\\\end{cases}\end{aligned}\end{equation}$$<p>其中$A=(a_{ij})_{n\times n}$为非奇异，且$a_{ij} \not= 0(i=1,2,\cdots,n)$<br>将上式变形可得</p>$$\begin{equation}\begin{aligned}\begin{cases}x_1=\dfrac{1}{a_{11}}(b_1-a_{12}x_2-\cdots-a_{1n}x_n)\\\qquad\qquad \vdots\\x_i=\dfrac{1}{a_{ii}}(b_i-a_{i1}x_1-\cdots-a_{ii-1}x_{i-1}-a_{ii+1}x_{i+1}-\cdots-a_{in}x_n)\\\qquad\qquad \vdots\\x_n=\dfrac{1}{a_{nn}}(b_1-a_{n1}x_1-\cdots-a_{nn-1}x_{n-1})\\\end{cases}\end{aligned}\end{equation}$$<p>写成迭代格式有</p>$$\begin{equation}\begin{aligned}x_i^{(k+1)}=\dfrac{1}{a_{ii}}\left( b_i - \sum\limits_{\substack{j=1\\j\not=i}}^n a_{ij}x_j^{(k)} \right)(i=1,2,\cdots,n)\end{aligned}\end{equation}$$<p>或者写成<br>$$x_i^{(k+1)}=x_i^{(k)}+\dfrac{1}{a_{ii}}\left( b_i - \sum\limits_{j=1}^n a_{ij}x_j^{(k)} \right)(i=1,2,\cdots,n)$$</p><p>称为<strong>Jacobi迭代法</strong></p><p>而考虑到Jacobi迭代法中，计算$x_{i+1}^{(k+1)}$时用到$x_{i}^{(k)}$，便将Jacobi迭代中的$x_{i}^{(k+1)}$用计算过的$x_{i+1}^{(k+1)}$替代，得到如下迭代格式</p>$$\begin{equation}\begin{aligned}\begin{cases}x_i^{(k+1)}=\dfrac{1}{a_{ii}}\left( b_i-\sum\limits_{j=1}^{i-1}a_{ij}x_j^{(k+1)}-\sum\limits_{j=i+1}^{n}a_{ij}x_j^{(k)} \right)\\k=0,1,2,\cdots\\i=1,2,\cdots,n\end{cases}\end{aligned}\end{equation}$$<p>称为$Gauss-Seidel$迭代法</p><h2 id="迭代法的收敛性"><a href="#迭代法的收敛性" class="headerlink" title="迭代法的收敛性"></a>迭代法的收敛性</h2><p><strong>定理4.1</strong> $\lim\limits_{k\rightarrow \infty}\varepsilon^{(k)}=0$（$\varepsilon^{(k)}=x^{(k)}-k^{*}$，即$x_i^{(k)}\rightarrow x_i^{*}, i = 1,2,\cdots,n$）的充要条件是$\lim\limits_{k\rightarrow \infty}B^k=0_{n\times n} \Leftrightarrow \rho(B)&lt;1$<br><strong>定理4.2</strong> 迭代法$x^{(k+1)}=Bx^{(k)}+f$对任意$x^{(0)}$和$f$均收敛的充要条件为$\rho(B)&lt;1$<br><strong>定理4.3</strong> 若$\Vert B\Vert&lt;1$，则迭代法收敛，且有<br>$$\Vert x^{(k)}-x^{*}\Vert \le \dfrac{\Vert B\Vert}{1-\Vert B\Vert}\Vert x^{(k)}-x^{(k-1)}\Vert \le \dfrac{\Vert B \Vert^k}{1-\Vert B \Vert}\Vert x^{(1)}-x^{(0)}\Vert$$<br>证明：</p>$$\begin{equation}\begin{aligned}x^{(k+1)}-x^{(k)}&=Bx^{(k)}-Bx^{(k-1)}=B(x^{(k)}-x^{(k-1)})\\x^{(k)}-x^{*}&=x^{(k)}-x^{(k+1)}+x^{(k+1)}-x^{*}\\&=B(x^{(k-1)}-x^{(k)})+B(x^{(k)}-x^{*})\\\Vert x^{(k)} -x^{*} \Vert &\le \Vert B\Vert\Vert x^{(k)}-x^{(k-1)}\Vert+\Vert B\Vert\Vert x^{(k)}-x^{*} \Vert\\\Vert x^{(k)}-x^{*}\Vert &\le \dfrac{\Vert B\Vert}{1-\Vert B\Vert}\Vert x^{(k)}-x^{(k-1)}\le \dfrac{\Vert B \Vert^k}{1-\Vert B \Vert}\Vert x^{(1)}-x^{(0)}\Vert\end{aligned}\end{equation}$$<h2 id="Jacobi迭代和G-S迭代的收敛性"><a href="#Jacobi迭代和G-S迭代的收敛性" class="headerlink" title="Jacobi迭代和G-S迭代的收敛性"></a>Jacobi迭代和G-S迭代的收敛性</h2><p>若$   \begin{equation}   \begin{aligned}   A=\begin{bmatrix}   a_{11}&a_{12}&\cdots&a_{1i}&\cdots&a_{1n}\\   a_{21}&a_{22}&\cdots&a_{2i}&\cdots&a_{2n}\\   \vdots&\ddots&\ddots&\vdots&\vdots&\vdots\\   a_{i1}&\cdots&a_{ii-1}&a_{ii}&\cdots&a_{in}\\   \vdots&&\vdots&\ddots&\ddots&\vdots\\   a_{n1}&\cdots&a_{ni-1}&\cdots&a_{nn-1}&a_{nn}\\   \end{bmatrix}   \end{aligned}   \end{equation}   $<br>令$D=diag\{a_{11},a_{12},\cdots,a_{nn}\}$</p>$   \begin{equation}   \begin{aligned}   L=\begin{bmatrix}   0&&&&&0\\   -a_{21}&0&&&&\\   \vdots&\ddots&\ddots&&&\\   -a_{i1}&\cdots&-a_{ii-1}&0&&\\   \vdots&&\vdots&\ddots&\ddots&\\   a_{n1}&\cdots&a_{ni-1}&\cdots&a_{nn-1}&0\\   \end{bmatrix}\\   U=\begin{bmatrix}        0&-a_{12}&\cdots&-a_{1i}&\cdots&-a_{1n}\\        &\ddots&\ddots&\vdots&&\ddots\\        &&0&-a_{i-1i}&\cdots&-a_{i-1n}\\        &&&\vdots&\vdots&\ddots\\        &&&&0&-a_{n-1n}\\        0&&&&&0\\        \end{bmatrix}   \end{aligned}   \end{equation}   $<p>于是有$A=D-L-U$<br>观察$Jacobi$迭代法的矩阵表示形式</p>$$\begin{equation}\begin{aligned}\begin{bmatrix}x_1^{(k+1)}\\x_2^{(k+1)}\\\ddots\\x_n^{(k+1)}\\\end{bmatrix}=\begin{bmatrix}0&-\dfrac{a_{12}}{a_{11}}&\cdots&-\dfrac{a_{1n}}{a_{11}}\\-\dfrac{a_{21}}{a_{22}}&0&\cdots&-\dfrac{a_{2n}}{a_{22}}\\\ddots&\ddots&\vdots&\ddots\\-\dfrac{a_{n1}}{a_{nn}}&-\dfrac{a_{n2}}{a_{nn}}&\cdots&0\\\end{bmatrix}\begin{bmatrix}x_1^{(k)}\\x_2^{(k)}\\\ddots\\x_n^{(k)}\\\end{bmatrix}+\begin{bmatrix}\dfrac{b_1}{a_{11}}\\\dfrac{b_2}{a_{22}}\\\ddots\\\dfrac{b_n}{a_{nn}}\\\end{bmatrix}\end{aligned}\end{equation}$$<p>所以有$x^{(k+1)}=D^{-1}(L+U)x^{(k)}+D^{-1}b$，<br>其中令$B_J=D^{-1}(L+U),f_J=D^{-1}b$，便可得到等价方程组$x=B_Jx+f_J$<br>同理可得$G-S$迭代为$x^{(k+1)}=(D-L)^{-1}Ux^{(k)}+(D-L)^{-1}b$</p><p><strong>G-S迭代与Jacobi迭代互相独立，Jacobi迭代收敛性与收敛速度与G-S迭代无关</strong></p><h2 id="判别收敛的充分条件"><a href="#判别收敛的充分条件" class="headerlink" title="判别收敛的充分条件"></a>判别收敛的充分条件</h2><p><strong>定义4.1</strong> 如果矩阵$A=(a_{ij})_{n\times n}$的元素满足不等式</p>$$\begin{equation}\begin{aligned}|a_{ii}|\ge \sum\limits_{\substack{j=1\\j\not=i}}^n |a_{ij}| \quad (i=1,2,\cdots,n)\end{aligned}\end{equation}$$<p>则称矩阵$A$为对角占优阵，如果严格不等式成立，称$A$位严格对角占优阵<br>对于严格对角占优阵$A$，其行列式$det(A)\not= 0$<br>证明：<br>假设$A$为奇异矩阵，则$Ax=0$有非零解$c_1,c_2,\cdots,c_n$<br>令$|c_i|=\max\limits_{i\le j\le n}\{|c_j|\}$<br>则有$a_{i1}c_1+a_{i2}c_2+\cdots+a_{in}c_n=0$</p>$\begin{equation}\begin{aligned}\begin{cases}\Rightarrow a_{ii}c_i=-\sum\limits_{j\not= i}a_{ij}c_j\\\Rightarrow |a_{ii}||c_i|\le\sum\limits_{j\not= i}|a_{ij}||c_j|\\\Rightarrow |a_{ii}|\le\sum\limits_{j\not= i}|a_{ij}|\dfrac{|c_j|}{|c_i|}\le\sum\limits_{j\not= i}|a_{ij}|\\\end{cases}\end{aligned}\end{equation}$<p>与$A$为严格对角占优矩阵矛盾</p><p><strong>定理4.4</strong> 若线性方程组$Ax=b$中的$A$为严格对角占优阵，则$Jacobi$迭代法与$G-S$迭代法均收敛<br>证明：</p><ul><li>$Jacobi$迭代法<br>  因为$B_J=D^{-1}(L+U)$<br>  所以$B_J$的行绝对值和为$\dfrac{1}{|a_{ii}}|\sum\limits_{j\not= i}|a_{ij}|\quad (i=1,2,\cdots,n)$<br>  因为$A$严格对角占优，所以$|a_{ii}&gt;\sum\limits_{j\not= i}|a_{ij}|$<br>  所以有$\Vert B_J\Vert &lt; 1$，故$Jacobi$迭代法收敛</li><li>$G-S$迭代法<br>  因为$B_G=(D-L)^{-1}U$<br>  $det[\lambda I-(D-L)^{-1}U]=det(D-L)^{-1}det[\lambda(D-L)-U]=0$<br>  又因为$det(D-L)^{-1}\not=0$，所以$det[\lambda(D-L)-U]=0$<br>  用反证法证明$|\lambda| &lt; 1$<br>  假设$|\lambda| &gt; 1$，且$A$为严格对角占优，所以有<br>  $|\lambda||a_{ii}|&gt;|\lambda|\sum\limits_{j\not= i}|a_{ij}|=\sum\limits_{j\not= i}|\lambda||a_{ij}|$<br>  $\le\sum\limits_{j=1}^{i-1}|\lambda||a_{ij}|+\sum\limits_{j=i+1}^n|a_{ij}| \quad (i=1,2,\cdots,n)$<br>  所以矩阵$\lambda(D-L)-U$严格对角占优，$det[\lambda(D-L)-U]\not=0$<br>  所以$\lambda &lt; 1$，即$\rho(B_G)&lt;1$，故$G-S$迭代法收敛</li></ul><h2 id="迭代改善法"><a href="#迭代改善法" class="headerlink" title="迭代改善法"></a>迭代改善法</h2><p>对良态或者不十分严重病态的线性方程组，与直接法结合对已得近似解进行精度改善</p><ul><li><p>用带列主元的$LU$分解求$Ax=b$得到计算解$\tilde{x}$</p></li><li><p>求$\tilde{x}$的修正向量$z$<br>  用<strong>双精度</strong>计算余向量<br>  $r=b-A\tilde{x}=Ax-A\tilde{x}=Az$  </p>  $    \begin{equation}    \begin{aligned}    PAz=LUz=Pr\Rightarrow     \begin{cases}    Ly=Pr\\    Uz=y    \end{cases}    \end{aligned}    \end{equation}    $<p>  令$x=\tilde{x}+z\qquad Ax=A\tilde{x}+Az=b-r+Az=b$<br>  故$x=\tilde{x}+z$即为近似解$\tilde{x}$的改进解</p></li><li><p>反复对近似解进行改善，即反复执行上述过程</p></li></ul><h2 id="非线性方程简介"><a href="#非线性方程简介" class="headerlink" title="非线性方程简介"></a>非线性方程简介</h2><p>常见非线性方程有，代数方程（二次，三次等），超越方程（三角方程，指数、对数方程等）<br>如果$f(x)=0$在区间$[a,b]$上仅有一个根，则称$[a,b]$为方程的<strong>单根区间</strong>；若方程在$[a,b]$上仅有多个根，则称$[a,b]$为方程的<strong>多根区间</strong></p><h2 id="简单迭代法的一般性理论"><a href="#简单迭代法的一般性理论" class="headerlink" title="简单迭代法的一般性理论"></a>简单迭代法的一般性理论</h2><p>首先将方程$f(x)=0$化为一个与它同解的方程$x=\varphi(x)$，其中$\varphi(x)$为$x$的连续函数。<br>求解非线性方程的<strong>简单迭代法</strong>或<strong>迭代过程</strong>或<strong>迭代格式</strong>为<br>$x_{k+1}=\varphi(x_k)\quad (k=0,1,2,\cdots)$，$\varphi(x)$称为迭代函数，$x_k$称第$k$步的<strong>迭代值</strong>或<strong>简称迭代值</strong><br>如果由迭代格式产生的数列收敛，即$\lim\limits_{k\rightarrow \infty}x_k = \alpha$，则称迭代法收敛，否则称迭代法发散。若迭代法收敛于$\alpha$，则$\alpha$为方程的根<br><strong>迭代法的收敛与发散，依赖于迭代函数的构造</strong></p><h2 id="迭代收敛的充分条件"><a href="#迭代收敛的充分条件" class="headerlink" title="迭代收敛的充分条件"></a>迭代收敛的充分条件</h2><p>当迭代函数满足$|\varphi’(x)|&lt;1$时，迭代法收敛，当$|\varphi’(x)|&gt;1$时，迭代法发散<br><strong>定理4.5</strong><br>设迭代函数$\varphi(x)$满足</p><ul><li>当$x\in [a,b]$时，$a\le \varphi(x)\le b$</li><li>存在正数$0&lt;L&lt;1$，对任意的$x\in [a,b]$均有$|\varphi’(x)|\le L$</li></ul><p>则$x=\varphi(x)$在$[a,b]$内存在唯一根$\alpha$，且对任意初始值$x_0\in [a,b]$，迭代法$x_{k+1}=\varphi(x_k)\quad (k=0,1,2,\cdots)$收敛于$\alpha$，且有</p><ul><li>$|x_k-\alpha|\le \dfrac{L}{1-L}|x_k-x_{k-1}|$</li><li>$|x_k-\alpha|\le \dfrac{L^k}{1-L}|x_1-x_{0}|$</li></ul><p>证明：令$f(x)=x-\varphi(x)$，因为$x\in [a,b]$有$a\le \varphi(x)\le b$<br>$f(a)=a-\varphi(a)\le 0 \quad f(b)=b-\varphi(b)\ge 0$<br>$|\varphi’(x)| \le L &lt; 1 \Rightarrow f’(x)=1-\varphi’(x) &gt; 0$<br>连续函数$f(x)$在$[a,b]$上单调，且在端点取值异号，故在$[a,b]$上有唯一根<br>$0=f(\alpha)=\alpha-\varphi(\alpha)\Leftrightarrow \alpha=\varphi(\alpha)$<br>根据微分中值定理有<br>$x_{k+1}-\alpha = \varphi(x_k)-\varphi(\alpha)=\varphi’(\xi_1)(x_k-\alpha)$<br>$x_{k+1}-x_k = \varphi(x_k)-\varphi(x_{k-1})=\varphi’(\xi_2)(x_k-x_{k-1})$<br>其中$\xi_1,\xi_2\in [a,b]$<br>所以有<br>$|x_{k+1}-\alpha| = |\varphi’(\xi_1)||(x_k-\alpha)|\le L|(x_k-\alpha)|$<br>$|x_{k+1}-x_k| = |\varphi’(\xi_2)||(x_k-x_{k-1})|\le L|(x_k-x_{k-1})|$<br>又因为<br>$|x_{k}-\alpha|\le |x_{k}-x_{k+1}|+|x_{k+1}-\alpha|\le L|(x_k-x_{k-1})|+ L|(x_k-\alpha)|$<br>所以得证<br>根据$L&lt;1$可知，$\lim\limits_{k\rightarrow \infty}|x_k-\alpha|=0$，即$\lim\limits_{k\rightarrow\infty}x_k=\alpha$，故迭代法收敛</p><p>可根据$|x_k-\alpha|\le \dfrac{L^k}{1-L}|x_k-x_{0}| &lt; \delta \Rightarrow k\le \log_L\dfrac{\delta(1-L)}{|x_1-x_0|}$</p><h2 id="实用收敛性的判断及收敛阶"><a href="#实用收敛性的判断及收敛阶" class="headerlink" title="实用收敛性的判断及收敛阶"></a>实用收敛性的判断及收敛阶</h2><p>假定$\varphi’(x)$在$\alpha$的附近连续，且满足$|\varphi’(\alpha)|&lt;1$，则根据连续函数的性质，一定存在$\alpha$的某个领域$S:|x-\alpha|\le \delta$，$\varphi(x)$在$S$上满足<strong>定理4.5</strong><br>故在$S$中任取初始值$x_0$，迭代格式$x_k=\varphi(x_{k-1})$收敛于方程的根$\alpha$，即$f(\alpha)\equiv 0$，称此收敛为<strong>局部收敛</strong></p><p>当$L$或者$\varphi’(x)$在$[a,b]$上的值越小，迭代过程的收敛速度就越快。当$L&lt;1$且接近于$1$时，迭代法虽然收敛但是收敛很慢<br><strong>定义4.2</strong> 设迭代格式$x_{k+1}=\varphi(x_k)$，当$k\rightarrow \infty$时，$x_{k+1}\rightarrow \alpha$，并记$e_k=x_k-\alpha$<br>若存在实数$p\ge 1$和$c&gt;0$满足$\lim\limits_{k\rightarrow \infty}\dfrac{|e_{k+1}|}{|e_k|^p}=c$，则称迭代法是<strong>$p$阶收敛</strong>。当$p=1$时，称线性收敛，当$p&gt;1$时，称超线性收敛，当$p=2$时，称平方收敛</p><p>$p$越大迭代法的收敛速度越快。使用$Taylor$展开式是一种常用方法<br>如果$\varphi(x)$在根$\alpha$处充分光滑，则可对$\varphi(x)$在$\alpha$处进行$Taylor$展开，得到<br>$x_{k+1}=\varphi(x_k)=\varphi(\alpha)+\varphi’(\alpha)(x_k-\alpha)+\dfrac{\varphi’’(\alpha)}{2!}(x_k-\alpha)^2+\cdots$<br>$+\dfrac{\varphi^{(p-1)}(\alpha)}{(p-1)!}(x_k-\alpha)^{p-1}+\dfrac{\varphi^{(p)}(\xi_k)}{p!}(x_k-\alpha)^p$<br>若$\varphi’(\alpha)=\varphi’’(\alpha)=\cdots=\varphi^{(p-1)}(\alpha)=0$<br>则有$\dfrac{|x_{k+1}-\alpha|}{|x_k-\alpha|^p}= \dfrac{|\varphi^{(p)|}(\xi_k)}{p!}$<br>从而有$\lim\limits_{k \rightarrow \infty}\dfrac{|x_{k+1}-\alpha|}{|x_k-\alpha|^p} = \lim\limits_{k \rightarrow \infty}\dfrac{|e_{k+1}|}{|e_k|^p} = \lim\limits_{k \rightarrow \infty}\dfrac{|\varphi^{(p)}(\xi_k)|}{p!}=\dfrac{|\varphi^{(p)}(\alpha)|}{p!}$</p><p>上式说明迭代法具有$p$阶收敛</p><p><strong>定理4.6</strong> 如果$x=\varphi(x)$中的迭代函数$\varphi(x)$在根$\alpha$附近满足</p><ul><li>$\varphi(x)$存在$p$阶导数且连续</li><li>$\varphi’(\alpha)=\varphi’’(\alpha)=\cdots=\varphi^{(p-1)}(\alpha)=0,\varphi^{(p)}(\alpha)\not= 0$<br>则迭代法$x_{k+1}=\varphi(x_k)$是$p$阶收敛</li></ul><h2 id="Newton-迭代法及其变形"><a href="#Newton-迭代法及其变形" class="headerlink" title="$Newton$迭代法及其变形"></a>$Newton$迭代法及其变形</h2><p>不管非线性方程$f(x)=0$的形式如何，总可以构造<br>$x=\varphi(x)=x-k(x)f(x)\quad (k(x)\not=0)$<br>作为方程$f(x)=0$求解的迭代函数，因为<br>$\varphi’(x)=1-k’(x)f(x)-k(x)f’(x)$<br>而且$|\varphi’(x)|$在根$\alpha$附近越小，其局部收敛速度越快<br>所以可令<br>$\varphi’(\alpha)=1-k’(\alpha)f(\alpha)-k(\alpha)f’(\alpha)=1-k(\alpha)f’(\alpha)=0$<br>若$f’(\alpha)\not= 0$（即$\alpha$不是$f(x)$的重根），则<br>$k(\alpha)=\dfrac{1}{f’(\alpha)}$<br>故可取$k(x)=\dfrac{1}{f’(x)}$，得<br>$x=x-\dfrac{f(x)}{f’(x)}$</p><p><strong>定理4.7</strong> 设方程$f(x)=0$的根为$\alpha$，且$f’(\alpha)\not=0$，则迭代法<br>$$x_{k+1}=x_k-\dfrac{f(x_k)}{f’(x_k)}\quad (k=0,1,2,\cdots)$$<br>至少是平方收敛，并称为<strong>$Newton$迭代法</strong>，也称为切线法</p><p>用导数近似式替代$f’(x)$可得<br>$x_{k+1}=x_k-\dfrac{f(x_k)}{f(x_k)-f(x_{k-1})}(x_k-x_{k-1})\quad (k=0,1,2,\cdots)$<br>称为<strong>弦截法</strong>，也称<strong>割线法</strong>，其收敛阶为$p=\dfrac{1+\sqrt{5}}{2}\approx 1.618$</p><p><strong>单步弦截法</strong><br>$x_{k+1}=x_k-\dfrac{f(x_k)}{f(x_k)-f(x_{0})}(x_k-x_{0})\quad (k=0,1,2,\cdots)$</p><p><strong>平行线法</strong><br>$x_{k+1}=x_k-\dfrac{f(x_k)}{f’(x_{0})}\quad (k=0,1,2,\cdots)$</p><h2 id="几个数值例子"><a href="#几个数值例子" class="headerlink" title="几个数值例子"></a>几个数值例子</h2><p>使用$Newton$迭代法时，为了防止迭代发散，我们在迭代格式中附加一个条件$|f(x_{k+1})|&lt;|f(x_k)|$<br>即要求$|f(x_k)|$的值单调下降，为此，引入$0&lt;\lambda \le 0$，建立<br>$x_{k+1}=x_k-\lambda\dfrac{f(x_k)}{f’(x_k)}\quad 0&lt;\lambda\le 1$<br>使得$|f(x_{k+1})|\le|f(x_k)|$，其中$\lambda$称为下山因子，称迭代法为$Newton$下山法<br>下山因子的选择一般采用试算法。即由迭代得到计算值$x_k$后，取不同的$\lambda$值试算，例如取$\lambda=1,\dfrac{1}{2},\dfrac{1}{2^2},\dfrac{1}{2^3},\cdots$<br>每次计算$f(x_{k+1})$均需要进行此步骤，如果计算过程中碰到一个迭代值$x_k$取不到满足要求的$\lambda$，则称<strong>下山失败</strong>，需要<strong>重新取初始值$x_0$</strong></p><h2 id="多根区间上的单根计算"><a href="#多根区间上的单根计算" class="headerlink" title="多根区间上的单根计算"></a>多根区间上的单根计算</h2><p>$[a,b]$是$f(x)=0$仅有单根的多根区间</p><ul><li>求单根区间<br>  设$f(x)=0$在$[a,b]$上有$m$个根。将$[a,b]$分成$n$个小区间：<br>  $[b_0,b_1],[b_1,b_2],\cdots,[b_{n-1},b_n]$，（其中$b_0=a,b_n=b$）然后计算$f(b_i)(i=1,2,\cdots,n)$的值，当$f(b_i)f(b_{i+1})&lt;0$时，$f(x)=0$在$[b_i,b_{i+1}]$上至少有一根</li><li>在单根区间$[c,d]$上求根<br>  利用二分法求根，在二分法求根过程中，有根区间趋于零的速度较慢时，可以从该区间开始使用其他迭代法求解</li></ul><h2 id="重根的计算"><a href="#重根的计算" class="headerlink" title="重根的计算"></a>重根的计算</h2><p>$f(x)=0$在$[a,b]$上有重根<br>设$\alpha$是$f(x)=0$的$m$重根，其中$m\ge 2$且为整数，则有<br>$f(x)=(x-\alpha)^mg(x)$且$g(\alpha)\not= 0$<br>此时$f(\alpha)=f’(\alpha)=f’’(\alpha)=\cdots=f^{(m-1)}(\alpha)=0\quad f^{(m)}(\alpha)\not=0$<br>若使用$Newton$迭代法</p>$\begin{equation}\begin{aligned}\varphi(x)&=x-\dfrac{f(x)}{f'(x)}=x-\dfrac{(x-\alpha)^mg(x)}{m(x-\alpha)^{m-1}g(x)+(x-\alpha)^mg'(x)}\\\varphi'(x)&=1-\dfrac{g(x)}{mg(x)+(x-\alpha)g'(x)}-(x-\alpha)\left[ \dfrac{g(x)}{mg(x)+(x-\alpha)g'(x)} \right]'\\\varphi'(\alpha)&=1-\dfrac{g(\alpha)}{mg(\alpha)+0}-0=1-\dfrac{1}{m}\not=0\end{aligned}\end{equation}$<p>若在这种条件下的$Newton$迭代法如果收敛，必定是线性收敛。为了提高收敛阶可取$\varphi(x)=x-m\dfrac{f(x)}{f’(x)}$<br>从而使$\varphi’(x)=1-\dfrac{m}{m}=0$，至少为平方收敛</p><h2 id="迭代的加速-SOR"><a href="#迭代的加速-SOR" class="headerlink" title="迭代的加速-SOR"></a>迭代的加速-SOR</h2><p>超松弛法（SOR法）<br>G-S迭代格式<br>$\overline{x_i}^{(k+1)}=\dfrac{1}{a_{ii}}\left( b_i - \sum\limits_{j=1}^{i-1} a_{ij}x_j^{(k+1)}-\sum\limits_{j=i+1}^n a_{ij}x_j^{(k)} \right)(i=1,2,\cdots,n)$<br>取$x_i^{(k+1)}=\beta_0x_i^{(k)}+\beta_1\overline{x_i}^{(k+1)}\quad \beta_0+\beta_1=1$<br>令$\beta_1=\omega,\beta_0=1-\omega$其中$\omega$称为松弛因子</p>$$\begin{equation}\begin{aligned}x_i^{(k+1)}&=(1-\omega)x_i^{(k)}+\dfrac{\omega}{a_{ii}}\left(  b_i - \sum\limits_{j=1}^{i-1} a_{ij}x_j^{(k+1)}-\sum\limits_{j=i+1}^n a_{ij}x_j^{(k)} \right)\\&=x_i^{(k)}+\dfrac{\omega}{a_{ii}}\left( b_i - \sum\limits_{j=1}^{i-1} a_{ij}x_j^{(k+1)}-\sum\limits_{j=i}^n a_{ij}x_j^{(k)} \right)\\\end{aligned}\end{equation}$$<p>$SOR$法的收敛速度与$\omega$有关，当$\omega=1$时，它就是$G-S$法<br>考虑$SOR$法的矩阵格式和收敛性<br>$a_{ii}x_i^{(k+1)}=(1-\omega)a_{ii}x_i^{(k)}+\omega\left(  b_i - \sum\limits_{j=1}^{i-1} a_{ij}x_j^{(k+1)}-\sum\limits_{j=i+1}^n a_{ij}x_j^{(k)} \right)$<br>设$A=D-L-U$<br>有$Dx_i^{(k+1)}=(1-\omega)Dx_i^{(k)}+\omega(  b - Lx_j^{(k+1)}-Ux_j^{(k)} )$<br>整理后得$(D-\omega L)x^{(k+1)}=[(1-\omega)D+\omega U]x^{(k)}+\omega b$<br>$x^{(k+1)}=(D-\omega L)^{-1}[(1-\omega)D+\omega U]x^{(k)}+\omega (D-\omega L)^{-1}b$<br>令$L_\omega = (D-\omega L)^{-1}[(1-\omega)D+\omega U],f=\omega (D-\omega L)^{-1}$<br>则$x^{(k+1)}=L_\omega x^{(k)}+f$</p><p>$SOR$法收敛的充要条件是$\rho(L_\omega)&lt;1$</p>$$\begin{equation}\begin{aligned}det(L_\omega)&=det((D-\omega L)^{-1})det((1-\omega)D+\omega U)\\&=1\dot (1-\omega)^n=\lambda_1\cdots \lambda_n\end{aligned}\end{equation}$$<p>令$$\begin{equation}\begin{aligned}|\lambda_1|\ge \cdots\ge |\lambda_n|&\Rightarrow|\lambda_1|\cdots|\lambda_n|=(1-\omega)^n\\&\Rightarrow\rho(L_\omega)\ge |1-\omega|\end{aligned}\end{equation}$$</p><p>根据收敛充要条件$1-\omega|\le \rho(L_\omega) &lt;1 \Rightarrow 0&lt;\omega&lt;2$</p><p>可以证明的是，如果$A$是对称正定矩阵，则满足$0&lt;\omega&lt;2$的任意$\omega$和初始向量$x^{(0)}$，$SOR$法均收敛。从而有<br><strong>如果$A$是对称正定矩阵，则$G-S$迭代法必收敛</strong><br>使$SOR$法收敛最快的松弛因子称为最优松弛因子，记为$\omega_{opt}$，使得$\rho(L_\omega)$最小</p><h2 id="迭代的加速-Aitken"><a href="#迭代的加速-Aitken" class="headerlink" title="迭代的加速-Aitken"></a>迭代的加速-Aitken</h2><p>设数列$\{x_k\}$为线性收敛，即$\lim\limits_{k\rightarrow\infty}\dfrac{|x_{k+1}-\alpha|}{|x_{k}-\alpha|}=c&gt;0$</p>$$\begin{equation}\begin{aligned}&\dfrac{x_{k+1}-\alpha}{x_{k}-\alpha}\approx c,\dfrac{x_{k}-\alpha}{x_{k-1}-\alpha}\approx c,\dfrac{x_{k+1}-\alpha}{x_{k}-\alpha}\approx\dfrac{x_{k}-\alpha}{x_{k-1}-\alpha}\\&\Rightarrow (x_k-\alpha)^2\approx (x_{k+1}-\alpha)(x_{k-1}-\alpha)\\&\Rightarrow x_k^2-2\alpha x_k + \alpha^2\approx x_{k+1}x_{k-1}-\alpha (x_{k+1}+x_{k-1})+\alpha^2\\&\Rightarrow \alpha\approx \dfrac{x_{k+1}x_{k-1}-x_k^2}{x_{k+1}-2x_k+x_{k-1}}=x_{k+1}-\dfrac{(x_{k+1}-x_k)^2}{x_{k+1}-2x_k+x_{k-1}}\end{aligned}\end{equation}$$<p>令$\overline{x_k}=x_{k+1}-\dfrac{(x_{k+1}-x_k)^2}{x_{k+1}-2x_k+x_{k-1}}$即对数列$\{x_k\}$进行$Aitken$加速</p><p>$Aitken$加速的两种基本方式</p><ul><li>对于没有（显式）迭代格式的数列加速后的新数列不改变原数列</li><li>对于有显式迭代格式的数列$x_{k+1}=\varphi(x_k)$，加速引入到迭代过程，原数列被改变</li></ul><h2 id="共轭梯度法（GC法）"><a href="#共轭梯度法（GC法）" class="headerlink" title="共轭梯度法（GC法）"></a>共轭梯度法（GC法）</h2><p>对于$Ax=b$</p><ul><li>任取$x_0\in R^n$</li><li>$r_0=b-Ax_o$，取$p_0=r_0$</li><li>对$k=0,1,\cdots$  $$    \begin{equation}    \begin{aligned}        \alpha_k&=\dfrac{(r_k,r_k)}{(p_k,Ap_k)}\\        x_{k+1}&=x_k+\alpha_kp_k\\        r_{k+1}&=r_k-\alpha_kAp_k\\        \beta_k&=\dfrac{(r_{k+1},r_{k+1})}{(r_{k},r_{k})}\\        p_{k+1}&=r_{k+1}+\beta_kp_k\\    \end{aligned}    \end{equation}    $$</li><li>若$r_l=0$或$(p_k,Ap_k)=0$时，计算终止</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;计算方法知识点归纳&lt;/br&gt;误差，矩阵，迭代部分&lt;/center&gt;
    
    </summary>
    
    
      <category term="Course" scheme="http://yoursite.com/categories/Course/"/>
    
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="Course" scheme="http://yoursite.com/tags/Course/"/>
    
  </entry>
  
  <entry>
    <title>Hexo日常使用以及Markdown语法</title>
    <link href="http://yoursite.com/2019/10/17/HexoAndMarkdown/"/>
    <id>http://yoursite.com/2019/10/17/HexoAndMarkdown/</id>
    <published>2019-10-17T01:55:50.000Z</published>
    <updated>2019-10-21T08:37:07.423Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Hexo日常使用"><a href="#Hexo日常使用" class="headerlink" title="Hexo日常使用"></a>Hexo日常使用</h1><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方文档</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//新建页面</span><br><span class="line">hexo new page &quot;page title&quot;</span><br><span class="line">//新建文章</span><br><span class="line">hexo new &quot;post title&quot;</span><br><span class="line">//生成静态文件，可简写为hexo g</span><br><span class="line">hexo generate</span><br><span class="line">//启动服务器，默认本地访问网址为：http://localhost:4000，可简写为hexo s</span><br><span class="line">hexo server</span><br><span class="line">//部署网站，可简写为hexo d -g，-g为部署前生成静态文件</span><br><span class="line">hexo deploy -g</span><br><span class="line">//清除缓存文件 (db.json) 和已生成的静态文件 (public)</span><br><span class="line">hexo clean</span><br></pre></td></tr></table></figure><h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p>推荐一款轻便简洁的Markdown编辑器<a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a></p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一阶标题      </span></span><br><span class="line"><span class="section">## 二阶标题     </span></span><br><span class="line"><span class="section">### 三阶标题    </span></span><br><span class="line"><span class="section">#### 四阶标题   </span></span><br><span class="line"><span class="section">##### 五阶标题  </span></span><br><span class="line"><span class="section">###### 六阶标题</span></span><br></pre></td></tr></table></figure><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线的内容<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**加粗的内容**</span></span><br></pre></td></tr></table></figure><h2 id="斜体字"><a href="#斜体字" class="headerlink" title="斜体字"></a>斜体字</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*倾斜的内容*</span></span><br></pre></td></tr></table></figure><h2 id="空格符"><a href="#空格符" class="headerlink" title="空格符"></a>空格符</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;ensp;  //一个空格</span><br><span class="line">&amp;emsp;  //两个空格</span><br></pre></td></tr></table></figure><h2 id="居中文本"><a href="#居中文本" class="headerlink" title="居中文本"></a>居中文本</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span>这是要居中的文本内容<span class="xml"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">***</span> </span><br><span class="line">或</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~删除线删除的内容~~</span><br></pre></td></tr></table></figure><h2 id="有序表"><a href="#有序表" class="headerlink" title="有序表"></a>有序表</h2><p>使用<code>数字 + . + 空格 + 输入内容</code>，需注意虽然不按如此格式输入显示仍是表的样式，但在HTML源码中不是表的格式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>数据1</span><br><span class="line"><span class="bullet">    1. </span>数据1的子数据1</span><br><span class="line"><span class="bullet">    2. </span>数据1的子数据2</span><br><span class="line"><span class="code">    ...</span></span><br><span class="line"><span class="bullet">2. </span>数据2</span><br><span class="line"><span class="bullet">3. </span>数据3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="无序表"><a href="#无序表" class="headerlink" title="无序表"></a>无序表</h2><p>使用<code>+</code>，<code>-</code>，<code>*</code>均可</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>数据1</span><br><span class="line"><span class="bullet">    - </span>数据1的子数据1</span><br><span class="line"><span class="bullet">    - </span>数据1的子数据2</span><br><span class="line"><span class="code">    ...</span></span><br><span class="line"><span class="bullet">+ </span>数据2</span><br><span class="line"><span class="bullet">+ </span>数据3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">图片描述（不会显示在页面中）</span>](<span class="link">图片路径</span>)</span><br></pre></td></tr></table></figure><h2 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">链接描述（带下划线文本形式显示）</span>](<span class="link">链接URL</span>)</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>在表格绘制中，<code>|</code>表示分列，<code>-</code>控制分行，<code>:</code>控制对齐方式<br><code>:-</code>表示左对齐，<code>:-:</code>表示居中对齐，<code>-:</code>表示右对齐<br>注意控制分行符号<code>-</code>数量对显示没有影响，下面多个<code>-</code>纯属为了排版好看</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 列名1    | 列名2    | 列名3   |  </span><br><span class="line">| :------ | :------: | ------: |</span><br><span class="line">| 列1数据1 | 列2数据1 | 列3数据1 |   </span><br><span class="line">| 列1数据2 | 列2数据2 | 列3数据2 | </span><br><span class="line">| 列1数据3 | 列2数据3 | 列3数据3 |</span><br></pre></td></tr></table></figure><p>此处需注意在Hexo中，对Markdown表格解析结果为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span>列名1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span>列名2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>列名3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span>列1数据1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span>列2数据1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>列3数据1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br></pre></td></tr></table></figure><p>无法实现文本内容居中，居右表示，只能默认居左表示<br>目前只想到通过修改当前页面全局CSS来改变位置，在文章前面加入如下CSS来实现居中显示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">th</span>&#123;<span class="attribute">text-align</span>: center&#125;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">td</span>&#123;<span class="attribute">text-align</span>: center&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="插入代码"><a href="#插入代码" class="headerlink" title="插入代码"></a>插入代码</h2><h3 id="单行代码"><a href="#单行代码" class="headerlink" title="单行代码"></a>单行代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`单行代码内容`</span></span><br></pre></td></tr></table></figure><p>在Hexo中会解析为<code>&lt;code&gt;</code>标签的内容，故可在<code>themes/hexo-theme-next/source/css/_custom/custom.styl</code>下修改其CSS样式</p><h3 id="多行代码"><a href="#多行代码" class="headerlink" title="多行代码"></a>多行代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">```</span></span><br><span class="line"><span class="code">   此处为多行代码填写位置，可以选择Markdown自带的一些代码类型，从而实现部分高亮显示</span></span><br><span class="line"><span class="code">   不存在的类型（例如cmd中命令行语句），选择text格式即可 </span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure><h2 id="LaTeX公式"><a href="#LaTeX公式" class="headerlink" title="LaTeX公式"></a>LaTeX公式</h2><p>数学公式的默认定界符</p><ol><li>行内公式为<code>$...$</code>和<code>\\(..\\)</code></li><li>块级公式为<code>$$...$$</code>和<code>\\[..\\]</code></li></ol><p>使用LaTeX需在站点配置文件中找到<code>mathjax</code>，并将<code>enable</code>改为<strong>true</strong><br><a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">详细使用方法</a></p><h2 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h2><p>将下面src中的链接替换为视频外链即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">height</span>=<span class="string">498</span> <span class="attr">width</span>=<span class="string">570</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">"https://www.bilibili.com/html/html5player.html?cid=24237876&amp;aid=14875829&amp;pre_ad=0"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">frameborder</span>=<span class="string">0</span> <span class="attr">allowfullscreen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="禁用Markdown渲染"><a href="#禁用Markdown渲染" class="headerlink" title="禁用Markdown渲染"></a>禁用Markdown渲染</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">    禁用渲染的内容，如LaTeX换行符\\，常用在矩阵中</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><hr><p>最后编辑于2019.10.19</p>]]></content>
    
    <summary type="html">
    
      &lt;center&gt;Hexo常用指令&lt;/br&gt;Markdown语法使用方法&lt;/br&gt;使用LaTeX编写公式&lt;/center&gt;
    
    </summary>
    
    
      <category term="Blog" scheme="http://yoursite.com/categories/Blog/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
</feed>
